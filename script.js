// Translations
const translations = {
    de: {
        "game.title": "UNO",
        "start.playerCount": "Anzahl Computer-Gegner:",
        "start.players2": "Du + 1 Computer",
        "start.players3": "Du + 2 Computer", 
        "start.players4": "Du + 3 Computer",
        "start.difficulty": "Schwierigkeitsgrad w√§hlen:",
        "difficulty.easy": "Einfach",
        "difficulty.easyDesc": "Defensiver Computer",
        "difficulty.medium": "Mittel",
        "difficulty.mediumDesc": "Ausgewogener Computer",
        "difficulty.hard": "Schwer",
        "difficulty.hardDesc": "Strategischer Computer",
        "start.rules": "Spielregeln",
        "start.startGame": "Spiel starten",
        "game.yourTurn": "Dein Zug",
        "game.computerTurn": "Computer {0} ist dran",
        "game.drawCard": "Karte ziehen",
        "game.uno": "UNO!",
        "game.currentColor": "Aktuelle Farbe:",
        "game.cards": "Karten",
        "game.chooseColor": "Farbe w√§hlen:",
        "game.computerChooses": "Computer w√§hlt: {0}",
        "game.unoCalled": "UNO gerufen!",
        "game.computerCallsUno": "Computer {0} ruft UNO!",
        "game.unoForgotten": "UNO vergessen! +2 Karten",
        "game.won": "Gewonnen! üéâ",
        "game.lost": "Verloren üòî", 
        "game.wonText": "Herzlichen Gl√ºckwunsch! Du hast das Spiel gewonnen!",
        "game.lostText": "Computer {0} hat gewonnen. Versuch es nochmal!",
        "game.playAgain": "Nochmal spielen",
        "game.restart": "M√∂chtest du das Spiel wirklich neu starten?",
        "game.empty": "Leer",
        "colors.red": "Rot",
        "colors.blue": "Blau", 
        "colors.green": "Gr√ºn",
        "colors.yellow": "Gelb",
        "settings.title": "Einstellungen",
        "settings.background": "üé® Hintergrund",
        "settings.bg.default": "Standard",
        "settings.bg.ocean": "Ozean",
        "settings.bg.sunset": "Sonnenuntergang",
        "settings.bg.forest": "Wald",
        "settings.bg.space": "Weltraum",
        "settings.bg.gradient": "Farbverlauf",
        "settings.close": "Fertig"
    },
    en: {
        "game.title": "UNO",
        "start.playerCount": "Number of Computer Opponents:",
        "start.players2": "You + 1 Computer",
        "start.players3": "You + 2 Computers",
        "start.players4": "You + 3 Computers", 
        "start.difficulty": "Choose Difficulty:",
        "difficulty.easy": "Easy",
        "difficulty.easyDesc": "Defensive Computer",
        "difficulty.medium": "Medium",
        "difficulty.mediumDesc": "Balanced Computer",
        "difficulty.hard": "Hard",
        "difficulty.hardDesc": "Strategic Computer",
        "start.rules": "Game Rules",
        "start.startGame": "Start Game",
        "game.yourTurn": "Your Turn",
        "game.computerTurn": "Computer {0}'s Turn",
        "game.drawCard": "Draw Card",
        "game.uno": "UNO!",
        "game.currentColor": "Current Color:",
        "game.cards": "Cards",
        "game.chooseColor": "Choose Color:",
        "game.computerChooses": "Computer chooses: {0}",
        "game.unoCalled": "UNO called!",
        "game.computerCallsUno": "Computer {0} calls UNO!",
        "game.unoForgotten": "UNO forgotten! +2 Cards",
        "game.won": "You Won! üéâ",
        "game.lost": "You Lost üòî",
        "game.wonText": "Congratulations! You won the game!",
        "game.lostText": "Computer {0} won. Try again!",
        "game.playAgain": "Play Again",
        "game.restart": "Do you really want to restart the game?",
        "game.empty": "Empty",
        "colors.red": "Red",
        "colors.blue": "Blue",
        "colors.green": "Green", 
        "colors.yellow": "Yellow",
        "settings.title": "Settings",
        "settings.background": "üé® Background",
        "settings.bg.default": "Default",
        "settings.bg.ocean": "Ocean",
        "settings.bg.sunset": "Sunset",
        "settings.bg.forest": "Forest",
        "settings.bg.space": "Space",
        "settings.bg.gradient": "Gradient",
        "settings.close": "Done"
    },
    hu: {
        "game.title": "UNO",
        "start.playerCount": "Sz√°m√≠t√≥g√©pes ellenfelek sz√°ma:",
        "start.players2": "Te + 1 Sz√°m√≠t√≥g√©p",
        "start.players3": "Te + 2 Sz√°m√≠t√≥g√©p",
        "start.players4": "Te + 3 Sz√°m√≠t√≥g√©p",
        "start.difficulty": "Neh√©zs√©gi szint:",
        "difficulty.easy": "K√∂nny≈±",
        "difficulty.easyDesc": "Defenz√≠v sz√°m√≠t√≥g√©p",
        "difficulty.medium": "K√∂zepes",
        "difficulty.mediumDesc": "Kiegyens√∫lyozott sz√°m√≠t√≥g√©p",
        "difficulty.hard": "Neh√©z",
        "difficulty.hardDesc": "Strat√©giai sz√°m√≠t√≥g√©p",
        "start.rules": "J√°t√©kszab√°lyok",
        "start.startGame": "J√°t√©k ind√≠t√°sa",
        "game.yourTurn": "Te k√∂vetkezel",
        "game.computerTurn": "{0}. sz√°m√≠t√≥g√©p k√∂vetkezik",
        "game.drawCard": "K√°rtya h√∫z√°sa",
        "game.uno": "UNO!",
        "game.currentColor": "Jelenlegi sz√≠n:",
        "game.cards": "K√°rty√°k",
        "game.chooseColor": "Sz√≠n v√°laszt√°sa:",
        "game.computerChooses": "A sz√°m√≠t√≥g√©p v√°laszt: {0}",
        "game.unoCalled": "UNO mondva!",
        "game.computerCallsUno": "{0}. sz√°m√≠t√≥g√©p UNO-t mond!",
        "game.unoForgotten": "UNO elfelejtve! +2 K√°rtya",
        "game.won": "Nyert√©l! üéâ",
        "game.lost": "Vesztett√©l üòî",
        "game.wonText": "Gratul√°lok! Megnyerted a j√°t√©kot!",
        "game.lostText": "{0}. sz√°m√≠t√≥g√©p nyert. Pr√≥b√°ld √∫jra!",
        "game.playAgain": "√öjra j√°t√©k",
        "game.restart": "Biztosan √∫jra szeretn√©d ind√≠tani a j√°t√©kot?",
        "game.empty": "√úres",
        "colors.red": "Piros",
        "colors.blue": "K√©k",
        "colors.green": "Z√∂ld",
        "colors.yellow": "S√°rga",
        "settings.title": "Be√°ll√≠t√°sok",
        "settings.background": "üé® H√°tt√©r",
        "settings.bg.default": "Alap√©rtelmezett",
        "settings.bg.ocean": "√ìce√°n",
        "settings.bg.sunset": "Naplemente",
        "settings.bg.forest": "Erd≈ë",
        "settings.bg.space": "Vil√°g≈±r",
        "settings.bg.gradient": "Sz√≠n√°tmenet",
        "settings.close": "K√©sz"
    },
    ru: {
        "game.title": "–£–ù–û",
        "start.playerCount": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤:",
        "start.players2": "–¢—ã + 1 –ö–æ–º–ø—å—é—Ç–µ—Ä",
        "start.players3": "–¢—ã + 2 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.players4": "–¢—ã + 3 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.difficulty": "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å:",
        "difficulty.easy": "–õ–µ–≥–∫–æ",
        "difficulty.easyDesc": "–û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.medium": "–°—Ä–µ–¥–Ω–µ",
        "difficulty.mediumDesc": "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.hard": "–°–ª–æ–∂–Ω–æ",
        "difficulty.hardDesc": "–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "start.rules": "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã",
        "start.startGame": "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
        "game.yourTurn": "–í–∞—à —Ö–æ–¥",
        "game.computerTurn": "–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {0}",
        "game.drawCard": "–í–∑—è—Ç—å –∫–∞—Ä—Ç—É",
        "game.uno": "–£–ù–û!",
        "game.currentColor": "–¢–µ–∫—É—â–∏–π —Ü–≤–µ—Ç:",
        "game.cards": "–ö–∞—Ä—Ç—ã",
        "game.chooseColor": "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:",
        "game.computerChooses": "–ö–æ–º–ø—å—é—Ç–µ—Ä –≤—ã–±–∏—Ä–∞–µ—Ç: {0}",
        "game.unoCalled": "–£–ù–û –æ–±—ä—è–≤–ª–µ–Ω–æ!",
        "game.computerCallsUno": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –æ–±—ä—è–≤–ª—è–µ—Ç –£–ù–û!",
        "game.unoForgotten": "–£–ù–û –∑–∞–±—ã—Ç–æ! +2 –ö–∞—Ä—Ç—ã",
        "game.won": "–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏! üéâ",
        "game.lost": "–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ üòî",
        "game.wonText": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –∏–≥—Ä—É!",
        "game.lostText": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –≤—ã–∏–≥—Ä–∞–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!",
        "game.playAgain": "–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞",
        "game.restart": "–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É?",
        "game.empty": "–ü—É—Å—Ç–æ",
        "colors.red": "–ö—Ä–∞—Å–Ω—ã–π",
        "colors.blue": "–°–∏–Ω–∏–π",
        "colors.green": "–ó–µ–ª—ë–Ω—ã–π",
        "colors.yellow": "–ñ—ë–ª—Ç—ã–π",
        "settings.title": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings.background": "üé® –§–æ–Ω",
        "settings.bg.default": "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings.bg.ocean": "–û–∫–µ–∞–Ω",
        "settings.bg.sunset": "–ó–∞–∫–∞—Ç",
        "settings.bg.forest": "–õ–µ—Å",
        "settings.bg.space": "–ö–æ—Å–º–æ—Å",
        "settings.bg.gradient": "–ì—Ä–∞–¥–∏–µ–Ω—Ç",
        "settings.close": "–ì–æ—Ç–æ–≤–æ"
    }
};

// UNO Game Implementation
class UnoGame {
    constructor() {
        this.colors = ['red', 'blue', 'green', 'yellow'];
        this.numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.actions = ['skip', 'reverse', 'draw-two'];
        this.wilds = ['wild', 'wild-draw-four'];
        
        // Lustige Computer-Namen nach Sprachen
        this.computerNamesByLanguage = {
            de: [
                'KartenKaiser', 'UnoUlrich', 'BlitzBerta', 'TurboTina', 'MegaMax',
                'FlitzerFritz', 'ZaubererZoe', 'RaketenRudi', 'SuperSusi', 'BlitzerBob',
                'GigaGerta', 'TurbineTom', 'FlashFiona', 'BoosterBruno', 'ZoomZara',
                'SpeediSepp', 'RaserRita', 'TurboTeddy', 'FlitzerFee', 'RocketRalf',
                'UnoUlla', 'KartenKurt', 'BlitzBrigitte', 'PowerPaul', 'MegaMaria',
                'TurboThomas', 'SpeedySandra', 'FlashFelix', 'ZoomZoe', 'RaketaRose',
                'SuperSchnecke', 'BlitzBirne', 'TurboTomate', 'FlitzerFisch', 'UnoUhu',
                'KartenKaktus', 'BlitzBanane', 'PowerPinguin', 'MegaMaulwurf', 'TurboTiger'
            ],
            en: [
                'CardKing', 'UnoUnicorn', 'FlashFred', 'TurboTom', 'MegaMax',
                'SpeedySpike', 'WizardWanda', 'RocketRob', 'SuperSam', 'BlitzBella',
                'GigaGrace', 'TurboTed', 'FlashFiona', 'BoosterBen', 'ZoomZoe',
                'QuickQuinn', 'RushRuby', 'TurboTerry', 'FlashFay', 'RocketRyan',
                'UnoUrsula', 'CardCarl', 'BlitzBrian', 'PowerPat', 'MegaMia',
                'TurboTracy', 'SpeedySarah', 'FlashFinn', 'ZoomZack', 'RocketRose',
                'SuperSnail', 'BlitzBerry', 'TurboTomato', 'FlashFish', 'UnoOwl',
                'CardCactus', 'BlitzBanana', 'PowerPenguin', 'MegaMole', 'TurboTiger'
            ],
            hu: [
                'K√°rtyaKir√°ly', 'UnoUnikorn', 'Vill√°mVilma', 'Turb√≥Tam√°s', 'MegaMarci',
                'Sebess√©giSzabi', 'Var√°zsl√≥Vera', 'Rak√©taR√≥bert', 'SzuperSzilvi', 'Vill√°mViktor',
                'GigaGabi', 'Turb√≥Tibor', 'Vill√°mVanda', 'Er≈ës√≠t≈ëErn≈ë', 'ZoomZolt√°n',
                'GyorsGerg≈ë', 'Rohamn√©Rita', 'Turb√≥T√ºnde', 'Vill√°mVivien', 'Rak√©taR√©ka',
                'Uno√örsula', 'K√°rtyaK√°lm√°n', 'Vill√°mViktor', 'Er≈ësErika', 'MegaM√≥nika',
                'Turb√≥Ter√©z', 'GyorsSzandra', 'Vill√°mFerenc', 'ZoomZsuzsa', 'Rak√©taR√≥zsa',
                'SzuperCsiga', 'Vill√°mBogy√≥', 'Turb√≥Paradicsom', 'Vill√°mHal', 'UnoBagoly',
                'K√°rtyaKaktusz', 'Vill√°mBan√°n', 'Er≈ësPingvin', 'MegaVakond', 'Turb√≥Tigris'
            ],
            ru: [
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Ä–æ–ª—å', '–£–Ω–æ–Æ–Ω–∏–∫–æ—Ä–Ω', '–ú–æ–ª–Ω–∏—è–ú–∞—à–∞', '–¢—É—Ä–±–æ–¢–æ–Ω—è', '–ú–µ–≥–∞–ú–∞–∫—Å',
                '–°–∫–æ—Ä–æ—Å—Ç–Ω–æ–π–°–µ—Ä–≥–µ–π', '–í–æ–ª—à–µ–±–Ω–∏–∫–í–µ—Ä–∞', '–†–∞–∫–µ—Ç–∞–†–æ–º–∞–Ω', '–°—É–ø–µ—Ä–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–ú–∏—à–∞',
                '–ì–∏–≥–∞–ì–∞–ª–∏–Ω–∞', '–¢—É—Ä–±–æ–¢–∏–º—É—Ä', '–ú–æ–ª–Ω–∏—è–í–∞–Ω–¥–∞', '–ë—É—Å—Ç–µ—Ä–ë–æ—Ä–∏—Å', '–ó—É–º–ó–æ—è',
                '–ë—ã—Å—Ç—Ä—ã–π–ë–æ—Ä–∏—Å', '–°–ø–µ—à–∫–∞–°–≤–µ—Ç–∞', '–¢—É—Ä–±–æ–¢–∞—Ç—å—è–Ω–∞', '–ú–æ–ª–Ω–∏—è–í–∏–∫—Ç–æ—Ä', '–†–∞–∫–µ—Ç–∞–†–∏—Ç–∞',
                '–£–Ω–æ–£–ª—å—è–Ω–∞', '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Å—Ç—è', '–ú–æ–ª–Ω–∏—è–ú–∞—Ä–∏–Ω–∞', '–°–∏–ª–∞–°–µ—Ä–≥–µ–π', '–ú–µ–≥–∞–ú–∞—Ä–∏—è',
                '–¢—É—Ä–±–æ–¢–∞–Ω—è', '–°–∫–æ—Ä—ã–π–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–§—ë–¥–æ—Ä', '–ó—É–º–ó–∏–Ω–∞–∏–¥–∞', '–†–∞–∫–µ—Ç–∞–†–æ–∑–∞',
                '–°—É–ø–µ—Ä–£–ª–∏—Ç–∫–∞', '–ú–æ–ª–Ω–∏—è–Ø–≥–æ–¥–∞', '–¢—É—Ä–±–æ–ü–æ–º–∏–¥–æ—Ä', '–ú–æ–ª–Ω–∏—è–†—ã–±–∞', '–£–Ω–æ–°–æ–≤–∞',
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–∞–∫—Ç—É—Å', '–ú–æ–ª–Ω–∏—è–ë–∞–Ω–∞–Ω', '–°–∏–ª—å–Ω—ã–π–ü–∏–Ω–≥–≤–∏–Ω', '–ú–µ–≥–∞–ö—Ä–æ—Ç', '–¢—É—Ä–±–æ–¢–∏–≥—Ä'
            ]
        };
        this.usedNames = [];  // Bereits verwendete Namen in diesem Spiel
        
        this.deck = [];
        this.players = []; // Array of all players (index 0 = human player)
        this.discardPile = [];
        this.currentColor = null;
        this.currentValue = null;
        this.currentPlayerIndex = 0; // Index of current player
        this.gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        this.difficulty = 'medium';
        this.playerCount = 2; // Total players (human + computers)
        
        this.calledUno = []; // Track UNO calls for each player
        this.gameInProgress = false; // Prevent multiple simultaneous actions
        this.currentLanguage = localStorage.getItem('unoLanguage') || 'de';
        this.currentBackground = localStorage.getItem('unoBackground') || 'default';
        
        this.initializeElements();
        this.setupEventListeners();
        this.initializeLanguage();
        this.initializeBackground();
    }
    
    initializeElements() {
        // Screen elements
        this.startScreen = document.getElementById('startScreen');
        this.gameScreen = document.getElementById('gameScreen');
        
        // Game elements
        this.playerCardsContainer = document.getElementById('playerCards');
        this.playersContainer = document.getElementById('playersContainer');
        this.discardPileElement = document.getElementById('discardPile');
        this.drawPileElement = document.getElementById('drawPile');
        
        // UI elements
        this.currentTurnElement = document.getElementById('currentTurn');
        this.colorDisplay = document.getElementById('colorDisplay');
        this.drawCardBtn = document.getElementById('drawCard');
        this.callUnoBtn = document.getElementById('callUno');
        
        // Modals
        this.colorModal = document.getElementById('colorModal');
        this.gameOverModal = document.getElementById('gameOverModal');
        this.rulesModal = document.getElementById('rulesModal');
        this.settingsModal = document.getElementById('settingsModal');
        
        // Start screen elements
        this.playerCountButtons = document.querySelectorAll('.player-count-btn');
        this.difficultyButtons = document.querySelectorAll('.difficulty-btn');
        this.startGameBtn = document.getElementById('startGame');
        
        // Game control elements
        this.restartBtn = document.getElementById('restartButton');
        this.rulesBtn = document.getElementById('rulesButton');
        this.rulesBtnGame = document.getElementById('rulesButtonGame');
        
        // Language elements
        this.languageButtons = document.querySelectorAll('.language-btn');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settingsButton');
        this.backgroundOptions = document.querySelectorAll('.background-option');
    }
    
    setupEventListeners() {
        // Player count selection
        this.playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.playerCountButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.playerCount = parseInt(btn.dataset.players);
                this.checkStartButtonEnabled();
            });
        });
        
        // Difficulty selection
        this.difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.difficultyButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = btn.dataset.difficulty;
                this.checkStartButtonEnabled();
            });
        });
        
        // Start game
        this.startGameBtn.addEventListener('click', () => {
            this.startGame();
        });
        
        // Game actions
        this.drawCardBtn.addEventListener('click', () => {
            this.drawCard(0);
        });
        
        this.callUnoBtn.addEventListener('click', () => {
            this.callUno(0);
        });
        
        // Color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectColor(btn.dataset.color);
            });
        });
        
        // Play again
        document.getElementById('playAgain').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Restart button
        this.restartBtn.addEventListener('click', () => {
            if (confirm('M√∂chtest du das Spiel wirklich neu starten?')) {
                this.resetGame();
            }
        });
        
        // Rules button (start screen)
        this.rulesBtn.addEventListener('click', () => {
            this.showRules();
        });
        
        // Rules button (in game)
        this.rulesBtnGame.addEventListener('click', () => {
            this.showRules();
        });
        
        // Close rules modal
        document.getElementById('closeRules').addEventListener('click', () => {
            this.hideRules();
        });
        
        document.getElementById('closeRulesBtn').addEventListener('click', () => {
            this.hideRules();
        });
        
        // Language selection
        this.languageButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.switchLanguage(btn.dataset.lang);
            });
        });
        
        // Settings
        this.settingsBtn.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            this.hideSettings();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.hideSettings();
        });
        
        // Background selection
        this.backgroundOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeBackground(option.dataset.bg);
            });
        });
        
        // Draw pile click
        this.drawPileElement.addEventListener('click', () => {
            if (this.currentPlayerIndex === 0 && this.deck.length > 0) {
                this.drawCard(0);
            }
        });
    }
    
    checkStartButtonEnabled() {
        const playerCountSelected = Array.from(this.playerCountButtons).some(btn => btn.classList.contains('selected'));
        const difficultySelected = Array.from(this.difficultyButtons).some(btn => btn.classList.contains('selected'));
        this.startGameBtn.disabled = !(playerCountSelected && difficultySelected);
    }
    
    getRandomComputerName() {
        // Hole die Namen f√ºr die aktuelle Sprache
        const computerNames = this.computerNamesByLanguage[this.currentLanguage] || this.computerNamesByLanguage['de'];
        
        // Wenn alle Namen verwendet wurden, leere die Liste
        if (this.usedNames.length >= computerNames.length) {
            this.usedNames = [];
        }
        
        // W√§hle einen Namen, der noch nicht verwendet wurde
        let availableNames = computerNames.filter(name => !this.usedNames.includes(name));
        const randomIndex = Math.floor(Math.random() * availableNames.length);
        const selectedName = availableNames[randomIndex];
        
        // Markiere den Namen als verwendet
        this.usedNames.push(selectedName);
        
        return selectedName;
    }
    
    createDeck() {
        this.deck = [];
        
        // Number cards (0-9) - 0 has 1 of each color, 1-9 have 2 of each color
        this.colors.forEach(color => {
            this.deck.push({ color, value: '0', type: 'number' });
            for (let i = 1; i <= 9; i++) {
                this.deck.push({ color, value: i.toString(), type: 'number' });
                this.deck.push({ color, value: i.toString(), type: 'number' });
            }
        });
        
        // Action cards (2 of each per color)
        this.colors.forEach(color => {
            this.actions.forEach(action => {
                this.deck.push({ color, value: action, type: 'action' });
                this.deck.push({ color, value: action, type: 'action' });
            });
        });
        
        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
            this.deck.push({ color: 'wild', value: 'wild', type: 'wild' });
            this.deck.push({ color: 'wild', value: 'wild-draw-four', type: 'wild' });
        }
        
        this.shuffleDeck();
    }
    
    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }
    
    dealInitialCards() {
        // Initialize players array
        this.players = [];
        this.calledUno = [];
        
        for (let i = 0; i < this.playerCount; i++) {
            this.players[i] = [];
            this.calledUno[i] = false;
        }
        
        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < this.playerCount; j++) {
                this.players[j].push(this.deck.pop());
            }
        }
        
        // Place first card on discard pile (cannot be wild or action card)
        let firstCard;
        do {
            firstCard = this.deck.pop();
        } while (firstCard.type === 'wild' || firstCard.type === 'action');
        
        this.discardPile = [firstCard];
        this.currentColor = firstCard.color;
        this.currentValue = firstCard.value;
    }
    
    startGame() {
        this.startScreen.classList.add('hidden');
        this.gameScreen.classList.remove('hidden');
        
        this.createDeck();
        this.dealInitialCards();
        this.setupPlayersUI();
        this.currentPlayerIndex = 0;
        this.gameInProgress = true;
        this.updateUI();
        this.updateTurnDisplay();
        
        // Enable UNO button when human player has 2 cards
        this.updateUnoButton();
    }
    
    setupPlayersUI() {
        // Clear existing computer players
        this.playersContainer.innerHTML = '';
        
        // Reset used names for a new game
        this.usedNames = [];
        
        // Create computer player UI elements (skip index 0 = human player)
        for (let i = 1; i < this.playerCount; i++) {
            const computerName = this.getRandomComputerName();
            const playerDiv = document.createElement('div');
            playerDiv.className = 'computer-player';
            playerDiv.id = `player-${i}`;
            
            playerDiv.innerHTML = `
                <div class="player-info">
                    <h3>${computerName}</h3>
                    <div class="card-count">
                        <span id="cardCount-${i}">${this.players[i].length}</span>
                        <span class="cards-text">Karten</span>
                    </div>
                </div>
                <div class="computer-cards" id="computerCards-${i}">
                    <!-- Computer cards will be added here -->
                </div>
            `;
            
            this.playersContainer.appendChild(playerDiv);
            
            // Store the computer name for later use
            if (!this.computerPlayerNames) {
                this.computerPlayerNames = {};
            }
            this.computerPlayerNames[i] = computerName;
        }
    }
    
    resetGame() {
        this.gameInProgress = false; // Stop any ongoing actions
        this.gameOverModal.classList.add('hidden');
        this.gameScreen.classList.add('hidden');
        this.startScreen.classList.remove('hidden');
        
        // Reset game state
        this.calledUno = [];
        this.gameDirection = 1;
        this.currentPlayerIndex = 0;
        this.computerPlayerNames = {}; // Reset computer names
        this.usedNames = []; // Reset used names
        
        // Reset button states
        this.startGameBtn.disabled = true;
        this.playerCountButtons.forEach(btn => btn.classList.remove('selected'));
        this.difficultyButtons.forEach(btn => btn.classList.remove('selected'));
    }
    
    updateUI() {
        this.updatePlayerCards();
        this.updateComputerCards();
        this.updateDiscardPile();
        this.updateDrawPile();
        this.updateCardCounts();
        this.updateColorDisplay();
        this.updateActivePlayer();
    }
    
    updatePlayerCards() {
        this.playerCardsContainer.innerHTML = '';
        this.players[0].forEach((card, index) => {
            const cardElement = this.createCardElement(card, true);
            cardElement.addEventListener('click', () => {
                if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                    this.playCard(0, index);
                }
            });
            
            // Add playable highlight
            if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                cardElement.classList.add('playable');
            }
            
            this.playerCardsContainer.appendChild(cardElement);
        });
    }
    
    updateComputerCards() {
        for (let i = 1; i < this.playerCount; i++) {
            const computerCardsContainer = document.getElementById(`computerCards-${i}`);
            if (computerCardsContainer) {
                computerCardsContainer.innerHTML = '';
                this.players[i].forEach(() => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'computer-card';
                    computerCardsContainer.appendChild(cardElement);
                });
            }
        }
    }
    
    updateDiscardPile() {
        const topCard = this.discardPile[this.discardPile.length - 1];
        this.discardPileElement.innerHTML = '';
        const cardElement = this.createCardElement(topCard, true);
        this.discardPileElement.appendChild(cardElement);
    }
    
    updateDrawPile() {
        this.drawPileElement.innerHTML = '';
        
        if (this.deck.length > 0) {
            // Show card back when cards are available
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            this.drawPileElement.appendChild(cardBack);
            
            // Enable draw button
            this.drawCardBtn.disabled = false;
            this.drawPileElement.style.cursor = 'pointer';
        } else {
            // Show empty state when no cards left
            const emptyPile = document.createElement('div');
            emptyPile.className = 'empty-pile';
            emptyPile.innerHTML = '<span>Leer</span>';
            this.drawPileElement.appendChild(emptyPile);
            
            // Disable draw button and pile
            this.drawCardBtn.disabled = true;
            this.drawPileElement.style.cursor = 'not-allowed';
        }
    }
    
    updateCardCounts() {
        // Update card counts for all computer players
        for (let i = 1; i < this.playerCount; i++) {
            const cardCountElement = document.getElementById(`cardCount-${i}`);
            if (cardCountElement) {
                cardCountElement.textContent = this.players[i].length;
            }
        }
    }
    
    updateActivePlayer() {
        // Remove active class from all players
        for (let i = 1; i < this.playerCount; i++) {
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                playerElement.classList.remove('active');
            }
        }
        
        // Add active class to current player (if computer)
        if (this.currentPlayerIndex > 0) {
            const activePlayerElement = document.getElementById(`player-${this.currentPlayerIndex}`);
            if (activePlayerElement) {
                activePlayerElement.classList.add('active');
            }
        }
    }
    
    updateColorDisplay() {
        // Remove all color classes
        this.colorDisplay.className = 'color-display';
        
        // Add current color class
        if (this.currentColor && this.currentColor !== 'wild') {
            this.colorDisplay.classList.add(this.currentColor);
        }
    }
    
    updateTurnDisplay() {
        if (this.currentPlayerIndex === 0) {
            this.currentTurnElement.textContent = this.t('game.yourTurn');
            this.currentTurnElement.style.background = 'rgba(76, 175, 80, 0.9)';
        } else {
            const computerName = this.computerPlayerNames && this.computerPlayerNames[this.currentPlayerIndex] 
                ? this.computerPlayerNames[this.currentPlayerIndex] 
                : `Computer ${this.currentPlayerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerTurn', computerName);
            this.currentTurnElement.style.background = 'rgba(244, 67, 54, 0.9)';
        }
    }
    
    updateUnoButton() {
        // Enable UNO button when human player has exactly 2 cards and hasn't called UNO yet
        this.callUnoBtn.disabled = !(this.players[0].length === 2 && !this.calledUno[0]);
    }
    
    createCardElement(card, showFace = true) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.color}`;
        
        if (showFace) {
            if (card.type === 'number') {
                cardElement.innerHTML = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                const actionText = {
                    'skip': 'STOP',
                    'reverse': '‚ü≤',
                    'draw-two': '+2'
                };
                cardElement.innerHTML = `<span class="card-value">${actionText[card.value]}</span>`;
            } else if (card.type === 'wild') {
                const wildText = card.value === 'wild' ? 'WILD' : '+4';
                cardElement.innerHTML = `<span class="card-value">${wildText}</span>`;
            }
        }
        
        return cardElement;
    }
    
    canPlayCard(card) {
        // Wild cards can always be played
        if (card.type === 'wild') {
            return true;
        }
        
        // Regular cards must match color or value
        return card.color === this.currentColor || card.value === this.currentValue;
    }
    
    playCard(playerIndex, cardIndex) {
        const hand = this.players[playerIndex];
        const card = hand[cardIndex];
        
        if (!this.canPlayCard(card)) {
            return false;
        }
        
        // Remove card from hand and add to discard pile
        hand.splice(cardIndex, 1);
        this.discardPile.push(card);
        
        // Add playing animation
        if (playerIndex === 0) {
            const cardElements = this.playerCardsContainer.children;
            if (cardElements[cardIndex]) {
                cardElements[cardIndex].classList.add('playing');
            }
        }
        
        // Handle card effects
        this.handleCardEffect(card);
        
        // Update current color and value
        if (card.type === 'wild') {
            if (playerIndex === 0) {
                this.showColorSelector();
                return true; // Color selector will handle turn switching
            } else {
                // Computer chooses color
                this.currentColor = this.chooseColorForComputer();
                this.showComputerColorChoice();
                // Continue to handle card effects below
            }
        } else {
            this.currentColor = card.color;
        }
        this.currentValue = card.value;
        
        // Check for win condition
        if (hand.length === 0) {
            this.endGame(playerIndex);
            return true;
        }
        
        // Check UNO call requirement
        if (hand.length === 1) {
            if (playerIndex === 0 && !this.calledUno[0]) {
                // Player forgot to call UNO - penalty
                this.penalizePlayer(0);
            } else if (playerIndex > 0 && !this.calledUno[playerIndex]) {
                // Computer calls UNO automatically
                this.callUno(playerIndex);
            }
        }
        
        // Update UI
        this.updateUI();
        this.updateUnoButton();
        
        // Switch turns (card effects handle their own turn logic)
        if (card.value === 'skip' || card.value === 'reverse' || 
            card.value === 'draw-two' || card.value === 'wild-draw-four' || 
            card.value === 'wild') {
            // Action cards and wild cards handle their own turn switching
            return true;
        } else {
            // Regular number cards
            this.switchTurns();
        }
        
        return true;
    }
    
    handleCardEffect(card) {
        switch (card.value) {
            case 'skip':
                // Skip next player's turn - switch twice to skip them
                this.switchTurns(); // Go to next player
                this.switchTurns(); // Skip that player
                break;
                
            case 'reverse':
                this.gameDirection *= -1;
                // In 2-player game, reverse acts like skip
                if (this.playerCount === 2) {
                    this.switchTurns(); // Go to next player
                    this.switchTurns(); // Skip that player (reverse effect)
                } else {
                    this.switchTurns(); // Just change direction
                }
                break;
                
            case 'draw-two':
                const drawTwoTarget = this.getNextPlayerIndex();
                this.drawCards(drawTwoTarget, 2);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild-draw-four':
                const drawFourTarget = this.getNextPlayerIndex();
                this.drawCards(drawFourTarget, 4);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild':
                // Regular wild card - just switch turns normally
                this.switchTurns();
                break;
        }
    }
    
    drawCard(playerIndex) {
        if (this.deck.length === 0) {
            this.reshuffleDeck();
        }
        
        // Check if we still have no cards after reshuffling (shouldn't happen normally)
        if (this.deck.length === 0) {
            console.warn('No cards available to draw!');
            return;
        }
        
        const card = this.deck.pop();
        this.players[playerIndex].push(card);
        
        this.updateUI();
        this.updateUnoButton();
        
        // Reset UNO call status when drawing cards
        this.calledUno[playerIndex] = false;
        
        // After drawing, human player auto-ends turn, computer continues
        if (playerIndex === 0 && this.currentPlayerIndex === 0) {
            // Auto-end human turn after drawing
            setTimeout(() => {
                if (this.currentPlayerIndex === 0) { // Double-check we're still on human turn
                    this.switchTurns();
                }
            }, 1000);
        }
    }
    
    drawCards(playerIndex, count) {
        for (let i = 0; i < count; i++) {
            this.drawCard(playerIndex);
        }
    }
    
    reshuffleDeck() {
        // Keep top card of discard pile, shuffle the rest back into deck
        const topCard = this.discardPile.pop();
        this.deck = [...this.discardPile];
        this.discardPile = [topCard];
        this.shuffleDeck();
    }
    
    getNextPlayerIndex() {
        let nextIndex = this.currentPlayerIndex + this.gameDirection;
        if (nextIndex >= this.playerCount) {
            nextIndex = 0;
        } else if (nextIndex < 0) {
            nextIndex = this.playerCount - 1;
        }
        return nextIndex;
    }
    
    switchTurns() {
        if (!this.gameInProgress) {
            return; // Game ended, don't continue
        }
        
        this.currentPlayerIndex = this.getNextPlayerIndex();
        this.updateTurnDisplay();
        this.updateUI();
        
        if (this.currentPlayerIndex > 0) {
            // Computer's turn
            setTimeout(() => {
                if (this.gameInProgress && this.currentPlayerIndex > 0) {
                    this.computerPlay();
                }
            }, 1500); // Delay for realism
        }
    }
    
    computerPlay() {
        // Safety check - make sure it's actually a computer's turn
        if (this.currentPlayerIndex === 0) {
            console.warn('computerPlay called but it\'s human player\'s turn!');
            return;
        }
        
        const playerIndex = this.currentPlayerIndex;
        const playableCards = this.players[playerIndex]
            .map((card, index) => ({ card, index }))
            .filter(({ card }) => this.canPlayCard(card));
        
        if (playableCards.length > 0) {
            const chosenCard = this.chooseCardForComputer(playableCards, playerIndex);
            this.playCard(playerIndex, chosenCard.index);
        } else {
            // Must draw a card
            this.drawCard(playerIndex);
            // Only switch turns if we're still at the same player (draw didn't trigger other effects)
            if (this.currentPlayerIndex === playerIndex) {
                this.switchTurns();
            }
        }
    }
    
    chooseCardForComputer(playableCards, playerIndex) {
        switch (this.difficulty) {
            case 'easy':
                return this.chooseCardEasy(playableCards, playerIndex);
            case 'medium':
                return this.chooseCardMedium(playableCards, playerIndex);
            case 'hard':
                return this.chooseCardHard(playableCards, playerIndex);
            default:
                return playableCards[0];
        }
    }
    
    chooseCardEasy(playableCards, playerIndex) {
        // Easy: Random selection, prefers regular cards over action cards
        const regularCards = playableCards.filter(({ card }) => card.type === 'number');
        const actionCards = playableCards.filter(({ card }) => card.type === 'action');
        const wildCards = playableCards.filter(({ card }) => card.type === 'wild');
        
        if (regularCards.length > 0 && Math.random() < 0.7) {
            return regularCards[Math.floor(Math.random() * regularCards.length)];
        } else if (actionCards.length > 0 && Math.random() < 0.6) {
            return actionCards[Math.floor(Math.random() * actionCards.length)];
        } else if (wildCards.length > 0) {
            return wildCards[Math.floor(Math.random() * wildCards.length)];
        }
        
        return playableCards[Math.floor(Math.random() * playableCards.length)];
    }
    
    chooseCardMedium(playableCards, playerIndex) {
        // Medium: Balanced strategy, considers card effects
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Check if human player has few cards
        const humanPlayerLowCards = this.players[0].length <= 3;
        
        // Prefer action cards when advantageous
        if (actionCards.length > 0 && humanPlayerLowCards) {
            const preferredActions = actionCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'skip'
            );
            if (preferredActions.length > 0) {
                return preferredActions[0];
            }
        }
        
        // Use wild cards strategically
        if (wildCards.length > 0 && this.players[playerIndex].length <= 2) {
            return wildCards[0];
        }
        
        // Otherwise prefer regular cards
        if (regularCards.length > 0) {
            return regularCards[0];
        }
        
        return playableCards[0];
    }
    
    chooseCardHard(playableCards, playerIndex) {
        // Hard: Advanced strategy, considers multiple factors
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Aggressive play when human player has few cards
        if (this.players[0].length <= 2) {
            const drawCards = playableCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'wild-draw-four'
            );
            if (drawCards.length > 0) {
                // Prefer wild-draw-four over draw-two
                const wildDrawFour = drawCards.find(({ card }) => card.value === 'wild-draw-four');
                return wildDrawFour || drawCards[0];
            }
            
            // Skip player's turn
            const skipCards = actionCards.filter(({ card }) => card.value === 'skip');
            if (skipCards.length > 0) {
                return skipCards[0];
            }
        }
        
        // Color management strategy
        const colorCounts = this.countColorsByFrequency(playerIndex);
        const bestColorCards = regularCards.filter(({ card }) => 
            card.color === colorCounts[0]?.color
        );
        
        if (bestColorCards.length > 0) {
            return bestColorCards[0];
        }
        
        // Save wild cards for last resort unless hand is small
        if (this.players[playerIndex].length <= 3 && wildCards.length > 0) {
            return wildCards[0];
        }
        
        // Default to first available card
        return regularCards[0] || actionCards[0] || wildCards[0] || playableCards[0];
    }
    
    categorizeCards(playableCards) {
        return {
            regularCards: playableCards.filter(({ card }) => card.type === 'number'),
            actionCards: playableCards.filter(({ card }) => card.type === 'action'),
            wildCards: playableCards.filter(({ card }) => card.type === 'wild')
        };
    }
    
    countColorsByFrequency(playerIndex) {
        const colorCounts = {};
        this.players[playerIndex].forEach(card => {
            if (card.color !== 'wild') {
                colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
        });
        
        return Object.entries(colorCounts)
            .map(([color, count]) => ({ color, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    chooseColorForComputer() {
        const colorCounts = this.countColorsByFrequency();
        return colorCounts.length > 0 ? colorCounts[0].color : this.colors[Math.floor(Math.random() * this.colors.length)];
    }
    
    showColorSelector() {
        this.colorModal.classList.remove('hidden');
    }
    
    selectColor(color) {
        this.currentColor = color;
        this.colorModal.classList.add('hidden');
        this.updateUI();
        this.switchTurns();
    }
    
    showComputerColorChoice() {
        // Show feedback about computer's color choice
        const colorNames = {
            'red': 'Rot',
            'blue': 'Blau', 
            'green': 'Gr√ºn',
            'yellow': 'Gelb'
        };
        
        const colorName = colorNames[this.currentColor];
        const originalText = this.currentTurnElement.textContent;
        
        this.currentTurnElement.textContent = `Computer w√§hlt: ${colorName}`;
        this.currentTurnElement.style.background = 'rgba(255, 193, 7, 0.9)';
        
        setTimeout(() => {
            this.updateTurnDisplay();
        }, 2000);
    }
    
    callUno(playerIndex) {
        this.calledUno[playerIndex] = true;
        
        if (playerIndex === 0) {
            this.callUnoBtn.disabled = true;
            
            // Show feedback
            this.currentTurnElement.textContent = this.t('game.unoCalled');
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        } else {
            // Show computer UNO call
            const computerName = this.computerPlayerNames && this.computerPlayerNames[playerIndex] 
                ? this.computerPlayerNames[playerIndex] 
                : `Computer ${playerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerCallsUno', computerName);
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        }
    }
    
    penalizePlayer(playerIndex) {
        // Draw 2 penalty cards for not calling UNO
        this.drawCards(playerIndex, 2);
        
        if (playerIndex === 0) {
            this.currentTurnElement.textContent = 'UNO vergessen! +2 Karten';
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 2000);
        }
    }
    
    endGame(winnerIndex) {
        this.gameInProgress = false; // Stop all game actions
        
        const gameResult = document.getElementById('gameResult');
        const gameResultText = document.getElementById('gameResultText');
        
        if (winnerIndex === 0) {
            gameResult.textContent = this.t('game.won');
            gameResult.style.color = '#4caf50';
            gameResultText.textContent = this.t('game.wonText');
        } else {
            gameResult.textContent = this.t('game.lost');
            gameResult.style.color = '#f44336';
            const computerName = this.computerPlayerNames && this.computerPlayerNames[winnerIndex] 
                ? this.computerPlayerNames[winnerIndex] 
                : `Computer ${winnerIndex}`;
            gameResultText.textContent = this.t('game.lostText', computerName);
        }
        
        this.gameOverModal.classList.remove('hidden');
    }
    
    showRules() {
        this.rulesModal.classList.remove('hidden');
    }
    
    hideRules() {
        this.rulesModal.classList.add('hidden');
    }
    
    // Language System
    initializeLanguage() {
        this.updateLanguageButtons();
        this.updateAllTexts();
    }
    
    switchLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('unoLanguage', lang);
        this.updateLanguageButtons();
        this.updateAllTexts();
        
        // Wenn ein Spiel l√§uft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
    }
    
    regenerateComputerNames() {
        // Reset verwendet Namen und generiere neue Namen f√ºr alle Computer
        this.usedNames = [];
        for (let i = 1; i < this.playerCount; i++) {
            const newName = this.getRandomComputerName();
            this.computerPlayerNames[i] = newName;
            
            // Update UI
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                const nameElement = playerElement.querySelector('.player-info h3');
                if (nameElement) {
                    nameElement.textContent = newName;
                }
            }
        }
        
        // Update turn display with new names
        this.updateTurnDisplay();
    }
    
    updateLanguageButtons() {
        this.languageButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.lang === this.currentLanguage);
        });
    }
    
    t(key, ...args) {
        const translation = translations[this.currentLanguage]?.[key] || translations['de'][key] || key;
        return args.length > 0 ? this.formatString(translation, ...args) : translation;
    }
    
    formatString(str, ...args) {
        return str.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
    }
    
    updateAllTexts() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = this.t(key);
        });
        
        // Update dynamic texts if game is running
        if (this.gameInProgress) {
            this.updateTurnDisplay();
        }
    }
    
    // Settings System
    showSettings() {
        this.settingsModal.classList.remove('hidden');
    }
    
    hideSettings() {
        this.settingsModal.classList.add('hidden');
    }
    
    initializeBackground() {
        this.applyBackground(this.currentBackground);
        this.updateBackgroundOptions();
    }
    
    changeBackground(bgName) {
        this.currentBackground = bgName;
        localStorage.setItem('unoBackground', bgName);
        this.applyBackground(bgName);
        this.updateBackgroundOptions();
    }
    
    applyBackground(bgName) {
        // Remove all background classes
        document.body.className = document.body.className.replace(/bg-\w+/g, '');
        // Add new background class
        document.body.classList.add(`bg-${bgName}`);
    }
    
    updateBackgroundOptions() {
        this.backgroundOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.bg === this.currentBackground);
        });
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new UnoGame();
});
