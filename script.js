// Translations
const translations = {
    de: {
        game: {
            title: "UNO",
            currentColor: "Aktuelle Farbe:",
            yourTurn: "Dein Zug",
            drawCard: "Karte ziehen",
            uno: "UNO!",
            chooseColor: "Farbe w√§hlen:",
            playAgain: "Nochmal spielen"
        },
        start: {
            playerCount: "Anzahl Computer-Gegner:",
            players2: "Du + 1 Computer",
            players3: "Du + 2 Computer",
            players4: "Du + 3 Computer",
            difficulty: "Schwierigkeitsgrad w√§hlen:",
            rules: "Spielregeln",
            startGame: "Spiel starten"
        },
        difficulty: {
            easy: "Einfach",
            easyDesc: "Defensiver Computer",
            medium: "Mittel",
            mediumDesc: "Ausgewogener Computer",
            hard: "Schwer",
            hardDesc: "Strategischer Computer"
        },
        settings: {
            title: "Einstellungen",
            background: "üé® Hintergrund",
            cardTheme: "üéÆ Karten-Theme",
            bg: {
                default: "Standard",
                ocean: "Ozean",
                sunset: "Sonnenuntergang",
                forest: "Wald",
                space: "Weltraum",
                gradient: "Farbverlauf"
            },
            theme: {
                classic: "Klassisch",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Fertig",
            version: "Version 1.0.0"
        }
    },
    en: {
        game: {
            title: "UNO",
            currentColor: "Current Color:",
            yourTurn: "Your Turn",
            drawCard: "Draw Card",
            uno: "UNO!",
            chooseColor: "Choose Color:",
            playAgain: "Play Again"
        },
        start: {
            playerCount: "Number of Computer Opponents:",
            players2: "You + 1 Computer",
            players3: "You + 2 Computers",
            players4: "You + 3 Computers",
            difficulty: "Choose Difficulty:",
            rules: "Rules",
            startGame: "Start Game"
        },
        difficulty: {
            easy: "Easy",
            easyDesc: "Defensive Computer",
            medium: "Medium",
            mediumDesc: "Balanced Computer",
            hard: "Hard",
            hardDesc: "Strategic Computer"
        },
        settings: {
            title: "Settings",
            background: "üé® Background",
            cardTheme: "üéÆ Card Theme",
            bg: {
                default: "Default",
                ocean: "Ocean",
                sunset: "Sunset",
                forest: "Forest",
                space: "Space",
                gradient: "Gradient"
            },
            theme: {
                classic: "Classic",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Done",
            version: "Version 1.0.0"
        }
    },
    es: {
        game: {
            title: "UNO",
            currentColor: "Color Actual:",
            yourTurn: "Tu Turno",
            drawCard: "Robar Carta",
            uno: "¬°UNO!",
            chooseColor: "Elegir Color:",
            playAgain: "Jugar de Nuevo"
        },
        start: {
            playerCount: "N√∫mero de Oponentes Inform√°ticos:",
            players2: "T√∫ + 1 Computadora",
            players3: "T√∫ + 2 Computadoras",
            players4: "T√∫ + 3 Computadoras",
            difficulty: "Elegir Dificultad:",
            rules: "Reglas",
            startGame: "Iniciar Juego"
        },
        difficulty: {
            easy: "F√°cil",
            easyDesc: "Computadora Defensiva",
            medium: "Medio",
            mediumDesc: "Computadora Equilibrada",
            hard: "Dif√≠cil",
            hardDesc: "Computadora Estrat√©gica"
        },
        settings: {
            title: "Configuraci√≥n",
            background: "üé® Fondo",
            cardTheme: "üéÆ Tema de Cartas",
            bg: {
                default: "Predeterminado",
                ocean: "Oc√©ano",
                sunset: "Atardecer",
                forest: "Bosque",
                space: "Espacio",
                gradient: "Degradado"
            },
            theme: {
                classic: "Cl√°sico",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Hecho",
            version: "Versi√≥n 1.0.0"
        }
    },
    fr: {
        game: {
            title: "UNO",
            currentColor: "Couleur Actuelle:",
            yourTurn: "Votre Tour",
            drawCard: "Piocher une Carte",
            uno: "UNO!",
            chooseColor: "Choisir la Couleur:",
            playAgain: "Rejouer"
        },
        start: {
            playerCount: "Nombre d'Adversaires Informatiques:",
            players2: "Vous + 1 Ordinateur",
            players3: "Vous + 2 Ordinateurs",
            players4: "Vous + 3 Ordinateurs",
            difficulty: "Choisir la Difficult√©:",
            rules: "R√®gles",
            startGame: "Commencer le Jeu"
        },
        difficulty: {
            easy: "Facile",
            easyDesc: "Ordinateur D√©fensif",
            medium: "Moyen",
            mediumDesc: "Ordinateur √âquilibr√©",
            hard: "Difficile",
            hardDesc: "Ordinateur Strat√©gique"
        },
        settings: {
            title: "Param√®tres",
            background: "üé® Arri√®re-plan",
            cardTheme: "üéÆ Th√®me de Cartes",
            bg: {
                default: "Par D√©faut",
                ocean: "Oc√©an",
                sunset: "Coucher de Soleil",
                forest: "For√™t",
                space: "Espace",
                gradient: "D√©grad√©"
            },
            theme: {
                classic: "Classique",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "R√©tro"
            },
            close: "Termin√©",
            version: "Version 1.0.0"
        }
    },
    pt: {
        game: {
            title: "UNO",
            currentColor: "Cor Atual:",
            yourTurn: "Sua Vez",
            drawCard: "Comprar Carta",
            uno: "UNO!",
            chooseColor: "Escolher Cor:",
            playAgain: "Jogar Novamente"
        },
        start: {
            playerCount: "N√∫mero de Oponentes Inform√°ticos:",
            players2: "Voc√™ + 1 Computador",
            players3: "Voc√™ + 2 Computadores",
            players4: "Voc√™ + 3 Computadores",
            difficulty: "Escolher Dificuldade:",
            rules: "Regras",
            startGame: "Iniciar Jogo"
        },
        difficulty: {
            easy: "F√°cil",
            easyDesc: "Computador Defensivo",
            medium: "M√©dio",
            mediumDesc: "Computador Equilibrado",
            hard: "Dif√≠cil",
            hardDesc: "Computador Estrat√©gico"
        },
        settings: {
            title: "Configura√ß√µes",
            background: "üé® Fundo",
            cardTheme: "üéÆ Tema de Cartas",
            bg: {
                default: "Padr√£o",
                ocean: "Oceano",
                sunset: "P√¥r do Sol",
                forest: "Floresta",
                space: "Espa√ßo",
                gradient: "Gradiente"
            },
            theme: {
                classic: "Cl√°ssico",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retr√¥"
            },
            close: "Conclu√≠do",
            version: "Vers√£o 1.0.0"
        }
    },
    ja: {
        game: {
            title: "UNO",
            currentColor: "ÁèæÂú®„ÅÆËâ≤:",
            yourTurn: "„ÅÇ„Å™„Åü„ÅÆÁï™",
            drawCard: "„Ç´„Éº„Éâ„ÇíÂºï„Åè",
            uno: "UNO!",
            chooseColor: "Ëâ≤„ÇíÈÅ∏Êäû:",
            playAgain: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§"
        },
        start: {
            playerCount: "„Ç≥„É≥„Éî„É•„Éº„Çø„ÉºÂØæÊà¶Áõ∏Êâã„ÅÆÊï∞:",
            players2: "„ÅÇ„Å™„Åü + 1Âè∞„ÅÆ„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
            players3: "„ÅÇ„Å™„Åü + 2Âè∞„ÅÆ„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
            players4: "„ÅÇ„Å™„Åü + 3Âè∞„ÅÆ„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
            difficulty: "Èõ£ÊòìÂ∫¶„ÇíÈÅ∏Êäû:",
            rules: "„É´„Éº„É´",
            startGame: "„Ç≤„Éº„É†ÈñãÂßã"
        },
        difficulty: {
            easy: "Á∞°Âçò",
            easyDesc: "Èò≤Âæ°ÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
            medium: "ÊôÆÈÄö",
            mediumDesc: "„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„Åü„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
            hard: "Èõ£„Åó„ÅÑ",
            hardDesc: "Êà¶Áï•ÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº"
        },
        settings: {
            title: "Ë®≠ÂÆö",
            background: "üé® ËÉåÊôØ",
            cardTheme: "üéÆ „Ç´„Éº„Éâ„ÉÜ„Éº„Éû",
            bg: {
                default: "„Éá„Éï„Ç©„É´„Éà",
                ocean: "Êµ∑",
                sunset: "Â§ïÊó•",
                forest: "Ê£Æ",
                space: "ÂÆáÂÆô",
                gradient: "„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥"
            },
            theme: {
                classic: "„ÇØ„É©„Ç∑„ÉÉ„ÇØ",
                minecraft: "„Éû„Ç§„É≥„ÇØ„É©„Éï„Éà",
                mario: "„Éû„É™„Ç™",
                pokemon: "„Éù„Ç±„É¢„É≥",
                cyberpunk: "„Çµ„Ç§„Éê„Éº„Éë„É≥„ÇØ",
                retro: "„É¨„Éà„É≠"
            },
            close: "ÂÆå‰∫Ü",
            version: "„Éê„Éº„Ç∏„Éß„É≥ 1.0.0"
        }
    },
    hu: {
        game: {
            title: "UNO",
            currentColor: "Jelenlegi Sz√≠n:",
            yourTurn: "Te Vagy",
            drawCard: "K√°rtya H√∫z√°sa",
            uno: "UNO!",
            chooseColor: "Sz√≠n V√°laszt√°sa:",
            playAgain: "√öjra J√°tsz√°s"
        },
        start: {
            playerCount: "Sz√°m√≠t√≥g√©pes Ellenfelek Sz√°ma:",
            players2: "Te + 1 Sz√°m√≠t√≥g√©p",
            players3: "Te + 2 Sz√°m√≠t√≥g√©p",
            players4: "Te + 3 Sz√°m√≠t√≥g√©p",
            difficulty: "Neh√©zs√©g V√°laszt√°sa:",
            rules: "Szab√°lyok",
            startGame: "J√°t√©k Ind√≠t√°sa"
        },
        difficulty: {
            easy: "K√∂nny≈±",
            easyDesc: "V√©dekez≈ë Sz√°m√≠t√≥g√©p",
            medium: "K√∂zepes",
            mediumDesc: "Kiegyens√∫lyozott Sz√°m√≠t√≥g√©p",
            hard: "Neh√©z",
            hardDesc: "Strat√©giai Sz√°m√≠t√≥g√©p"
        },
        settings: {
            title: "Be√°ll√≠t√°sok",
            background: "üé® H√°tt√©r",
            cardTheme: "üéÆ K√°rtya T√©ma",
            bg: {
                default: "Alap√©rtelmezett",
                ocean: "√ìce√°n",
                sunset: "Naplemente",
                forest: "Erd≈ë",
                space: "≈∞r",
                gradient: "√Åtmenet"
            },
            theme: {
                classic: "Klasszikus",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "K√©sz",
            version: "Verzi√≥ 1.0.0"
        }
    },
    ru: {
        game: {
            title: "UNO",
            currentColor: "–¢–µ–∫—É—â–∏–π –¶–≤–µ—Ç:",
            yourTurn: "–í–∞—à –•–æ–¥",
            drawCard: "–í–∑—è—Ç—å –ö–∞—Ä—Ç—É",
            uno: "–£–ù–û!",
            chooseColor: "–í—ã–±—Ä–∞—Ç—å –¶–≤–µ—Ç:",
            playAgain: "–ò–≥—Ä–∞—Ç—å –°–Ω–æ–≤–∞"
        },
        start: {
            playerCount: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ö–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤:",
            players2: "–í—ã + 1 –ö–æ–º–ø—å—é—Ç–µ—Ä",
            players3: "–í—ã + 2 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
            players4: "–í—ã + 3 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
            difficulty: "–í—ã–±—Ä–∞—Ç—å –°–ª–æ–∂–Ω–æ—Å—Ç—å:",
            rules: "–ü—Ä–∞–≤–∏–ª–∞",
            startGame: "–ù–∞—á–∞—Ç—å –ò–≥—Ä—É"
        },
        difficulty: {
            easy: "–õ–µ–≥–∫–æ",
            easyDesc: "–ó–∞—â–∏—Ç–Ω—ã–π –ö–æ–º–ø—å—é—Ç–µ—Ä",
            medium: "–°—Ä–µ–¥–Ω–µ",
            mediumDesc: "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ö–æ–º–ø—å—é—Ç–µ—Ä",
            hard: "–°–ª–æ–∂–Ω–æ",
            hardDesc: "–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π –ö–æ–º–ø—å—é—Ç–µ—Ä"
        },
        settings: {
            title: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
            background: "üé® –§–æ–Ω",
            cardTheme: "üéÆ –¢–µ–º–∞ –ö–∞—Ä—Ç",
            bg: {
                default: "–ü–æ –£–º–æ–ª—á–∞–Ω–∏—é",
                ocean: "–û–∫–µ–∞–Ω",
                sunset: "–ó–∞–∫–∞—Ç",
                forest: "–õ–µ—Å",
                space: "–ö–æ—Å–º–æ—Å",
                gradient: "–ì—Ä–∞–¥–∏–µ–Ω—Ç"
            },
            theme: {
                classic: "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è",
                minecraft: "–ú–∞–π–Ω–∫—Ä–∞—Ñ—Ç",
                mario: "–ú–∞—Ä–∏–æ",
                pokemon: "–ü–æ–∫–µ–º–æ–Ω",
                cyberpunk: "–ö–∏–±–µ—Ä–ø–∞–Ω–∫",
                retro: "–†–µ—Ç—Ä–æ"
            },
            close: "–ì–æ—Ç–æ–≤–æ",
            version: "–í–µ—Ä—Å–∏—è 1.0.0"
        }
    },
    zh: {
        game: {
            title: "UNO",
            currentColor: "ÂΩìÂâçÈ¢úËâ≤:",
            yourTurn: "‰Ω†ÁöÑÂõûÂêà",
            drawCard: "ÊäΩÂç°",
            uno: "UNO!",
            chooseColor: "ÈÄâÊã©È¢úËâ≤:",
            playAgain: "ÂÜçÁé©‰∏ÄÊ¨°"
        },
        start: {
            playerCount: "ÁîµËÑëÂØπÊâãÊï∞Èáè:",
            players2: "‰Ω† + 1‰∏™ÁîµËÑë",
            players3: "‰Ω† + 2‰∏™ÁîµËÑë",
            players4: "‰Ω† + 3‰∏™ÁîµËÑë",
            difficulty: "ÈÄâÊã©ÈöæÂ∫¶:",
            rules: "ËßÑÂàô",
            startGame: "ÂºÄÂßãÊ∏∏Êàè"
        },
        difficulty: {
            easy: "ÁÆÄÂçï",
            easyDesc: "Èò≤Âæ°ÂûãÁîµËÑë",
            medium: "‰∏≠Á≠â",
            mediumDesc: "Âπ≥Ë°°ÂûãÁîµËÑë",
            hard: "Âõ∞Èöæ",
            hardDesc: "Á≠ñÁï•ÂûãÁîµËÑë"
        },
        settings: {
            title: "ËÆæÁΩÆ",
            background: "üé® ËÉåÊôØ",
            cardTheme: "üéÆ Âç°Áâå‰∏ªÈ¢ò",
            bg: {
                default: "ÈªòËÆ§",
                ocean: "Êµ∑Ê¥ã",
                sunset: "Êó•ËêΩ",
                forest: "Ê£ÆÊûó",
                space: "Â§™Á©∫",
                gradient: "Ê∏êÂèò"
            },
            theme: {
                classic: "ÁªèÂÖ∏",
                minecraft: "ÊàëÁöÑ‰∏ñÁïå",
                mario: "È©¨ÈáåÂ••",
                pokemon: "ÂÆùÂèØÊ¢¶",
                cyberpunk: "ËµõÂçöÊúãÂÖã",
                retro: "Â§çÂè§"
            },
            close: "ÂÆåÊàê",
            version: "ÁâàÊú¨ 1.0.0"
        }
    }
};

// Initialize language
let currentLanguage = localStorage.getItem('unoLanguage') || 'de';

// Function to translate text based on current language
function t(key, ...args) {
    const translation = translations[currentLanguage]?.[key] || translations['de'][key] || key;
    return args.length > 0 ? formatString(translation, ...args) : translation;
}

function formatString(str, ...args) {
    return str.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
}

// UNO Game Implementation
class UnoGame {
    constructor() {
        this.colors = ['red', 'blue', 'green', 'yellow'];
        this.numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.actions = ['skip', 'reverse', 'draw-two'];
        this.wilds = ['wild', 'wild-draw-four'];
        
        // Lustige Computer-Namen nach Sprachen
        this.computerNamesByLanguage = {
            de: [
                'KartenKaiser', 'UnoUlrich', 'BlitzBerta', 'TurboTina', 'MegaMax',
                'FlitzerFritz', 'ZaubererZoe', 'RaketenRudi', 'SuperSusi', 'BlitzerBob',
                'GigaGerta', 'TurbineTom', 'FlashFiona', 'BoosterBruno', 'ZoomZara',
                'SpeediSepp', 'RaserRita', 'TurboTeddy', 'FlitzerFee', 'RocketRalf',
                'UnoUlla', 'KartenKurt', 'BlitzBrigitte', 'PowerPaul', 'MegaMaria',
                'TurboThomas', 'SpeedySandra', 'FlashFelix', 'ZoomZoe', 'RaketaRose',
                'SuperSchnecke', 'BlitzBirne', 'TurboTomate', 'FlitzerFisch', 'UnoUhu',
                'KartenKaktus', 'BlitzBanane', 'PowerPinguin', 'MegaMaulwurf', 'TurboTiger'
            ],
            en: [
                'CardKing', 'UnoUnicorn', 'FlashFred', 'TurboTom', 'MegaMax',
                'SpeedySpike', 'WizardWanda', 'RocketRob', 'SuperSam', 'BlitzBella',
                'GigaGrace', 'TurboTed', 'FlashFiona', 'BoosterBen', 'ZoomZoe',
                'QuickQuinn', 'RushRuby', 'TurboTerry', 'FlashFay', 'RocketRyan',
                'UnoUrsula', 'CardCarl', 'BlitzBrian', 'PowerPat', 'MegaMia',
                'TurboTracy', 'SpeedySarah', 'FlashFinn', 'ZoomZack', 'RocketRose',
                'SuperSnail', 'BlitzBerry', 'TurboTomato', 'FlashFish', 'UnoOwl',
                'CardCactus', 'BlitzBanana', 'PowerPenguin', 'MegaMole', 'TurboTiger'
            ],
            hu: [
                'K√°rtyaKir√°ly', 'UnoUnikorn', 'Vill√°mVilma', 'Turb√≥Tam√°s', 'MegaMarci',
                'Sebess√©giSzabi', 'Var√°zsl√≥Vera', 'Rak√©taR√≥bert', 'SzuperSzilvi', 'Vill√°mViktor',
                'GigaGabi', 'Turb√≥Tibor', 'Vill√°mVanda', 'Er≈ës√≠t≈ëErn≈ë', 'ZoomZolt√°n',
                'GyorsGerg≈ë', 'Rohamn√©Rita', 'Turb√≥T√ºnde', 'Vill√°mVivien', 'Rak√©taR√©ka',
                'Uno√örsula', 'K√°rtyaK√°lm√°n', 'Vill√°mViktor', 'Er≈ësErika', 'MegaM√≥nika',
                'Turb√≥Ter√©z', 'GyorsSzandra', 'Vill√°mFerenc', 'ZoomZsuzsa', 'Rak√©taR√≥zsa',
                'SzuperCsiga', 'Vill√°mBogy√≥', 'Turb√≥Paradicsom', 'Vill√°mHal', 'UnoBagoly',
                'K√°rtyaKaktusz', 'Vill√°mBan√°n', 'Er≈ësPingvin', 'MegaVakond', 'Turb√≥Tigris'
            ],
            ru: [
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Ä–æ–ª—å', '–£–Ω–æ–Æ–Ω–∏–∫–æ—Ä–Ω', '–ú–æ–ª–Ω–∏—è–ú–∞—à–∞', '–¢—É—Ä–±–æ–¢–æ–Ω—è', '–ú–µ–≥–∞–ú–∞–∫—Å',
                '–°–∫–æ—Ä–æ—Å—Ç–Ω–æ–π–°–µ—Ä–≥–µ–π', '–í–æ–ª—à–µ–±–Ω–∏–∫–í–µ—Ä–∞', '–†–∞–∫–µ—Ç–∞–†–æ–º–∞–Ω', '–°—É–ø–µ—Ä–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–ú–∏—à–∞',
                '–ì–∏–≥–∞–ì–∞–ª–∏–Ω–∞', '–¢—É—Ä–±–æ–¢–∏–º—É—Ä', '–ú–æ–ª–Ω–∏—è–í–∞–Ω–¥–∞', '–ë—É—Å—Ç–µ—Ä–ë–æ—Ä–∏—Å', '–ó—É–º–ó–æ—è',
                '–ë—ã—Å—Ç—Ä—ã–π–ë–æ—Ä–∏—Å', '–°–ø–µ—à–∫–∞–°–≤–µ—Ç–∞', '–¢—É—Ä–±–æ–¢–∞—Ç—å—è–Ω–∞', '–ú–æ–ª–Ω–∏—è–í–∏–∫—Ç–æ—Ä', '–†–∞–∫–µ—Ç–∞–†–∏—Ç–∞',
                '–£–Ω–æ–£–ª—å—è–Ω–∞', '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Å—Ç—è', '–ú–æ–ª–Ω–∏—è–ú–∞—Ä–∏–Ω–∞', '–°–∏–ª–∞–°–µ—Ä–≥–µ–π', '–ú–µ–≥–∞–ú–∞—Ä–∏—è',
                '–¢—É—Ä–±–æ–¢–∞–Ω—è', '–°–∫–æ—Ä—ã–π–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–§—ë–¥–æ—Ä', '–ó—É–º–ó–∏–Ω–∞–∏–¥–∞', '–†–∞–∫–µ—Ç–∞–†–æ–∑–∞',
                '–°—É–ø–µ—Ä–£–ª–∏—Ç–∫–∞', '–ú–æ–ª–Ω–∏—è–Ø–≥–æ–¥–∞', '–¢—É—Ä–±–æ–ü–æ–º–∏–¥–æ—Ä', '–ú–æ–ª–Ω–∏—è–†—ã–±–∞', '–£–Ω–æ–°–æ–≤–∞',
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–∞–∫—Ç—É—Å', '–ú–æ–ª–Ω–∏—è–ë–∞–Ω–∞–Ω', '–°–∏–ª—å–Ω—ã–π–ü–∏–Ω–≥–≤–∏–Ω', '–ú–µ–≥–∞–ö—Ä–æ—Ç', '–¢—É—Ä–±–æ–¢–∏–≥—Ä'
            ],
            es: [
                'ReyCartas', 'UnoUnicornio', 'Rel√°mpagoRosa', 'TurboTeo', 'MegaMax',
                'VelocidadVera', 'MagoMario', 'CoheteCarlos', 'SuperSofia', 'Rel√°mpagoRafa',
                'GigaGloria', 'TurboTom√°s', 'FlashFrancisca', 'BoosterBenji', 'ZoomZara',
                'R√°pidoRicardo', 'PrisaPatricia', 'TurboTere', 'FlashFelipe', 'CoheteClara',
                'UnoUrsula', 'CartasCarmen', 'Rel√°mpagoRoberto', 'PoderPablo', 'MegaMar√≠a',
                'TurboTania', 'VeloceSandra', 'FlashFernando', 'ZoomZoe', 'CoheteRosa',
                'SuperCaracol', 'Rel√°mpagoUva', 'TurboTomate', 'FlashPez', 'UnoB√∫ho',
                'CartasCactus', 'Rel√°mpagoPlatano', 'PoderPing√ºino', 'MegaTopo', 'TurboTigre'
            ],
            fr: [
                'RoiCartes', 'UnoLicorne', '√âclair√âmilie', 'TurboTh√©o', 'M√©gaMax',
                'VitesseVictor', 'MagicienMarcel', 'Fus√©eFran√ßoise', 'SuperSylvie', '√âclair√âric',
                'GigaGabrielle', 'TurboThomas', 'FlashFanny', 'BoosterBenjamin', 'ZoomZo√©',
                'RapideRaymond', 'PressePauline', 'TurboTh√©r√®se', 'FlashFabien', 'Fus√©eClaire',
                'UnoUrsule', 'CartesCl√©ment', '√âclairRen√©e', 'PouvoirPierre', 'M√©gaMarie',
                'TurboTanya', 'V√©loceSandra', 'FlashF√©lix', 'ZoomZacharie', 'Fus√©eRose',
                'SuperEscargot', '√âclairRaisin', 'TurboTomate', 'FlashPoisson', 'UnoHibou',
                'CartesCactus', '√âclairBanane', 'PouvoirPingouin', 'M√©gaTaupe', 'TurboTigre'
            ],
            pt: [
                'ReiCartas', 'UnoUnic√≥rnio', 'Rel√¢mpagoRita', 'TurboTiago', 'MegaMax',
                'VelocidadeVera', 'M√°gicoM√°rio', 'FogueteFelix', 'SuperS√¥nia', 'Rel√¢mpagoRafa',
                'GigaGisele', 'TurboTom√°s', 'FlashFernanda', 'BoosterBruno', 'ZoomZara',
                'R√°pidoRicardo', 'PressaPatr√≠cia', 'TurboTina', 'FlashF√°bio', 'FogueteClara',
                'Uno√örsula', 'CartasCarlos', 'Rel√¢mpagoRenata', 'PoderPaulo', 'MegaMaria',
                'TurboT√¢nia', 'VelozSandra', 'FlashFernando', 'ZoomZ√©', 'FogueteRosa',
                'SuperCaracol', 'Rel√¢mpagoUva', 'TurboTomate', 'FlashPeixe', 'UnoCoruja',
                'CartasCacto', 'Rel√¢mpagoBanana', 'PoderPinguim', 'MegaToupeira', 'TurboTigre'
            ],
            ja: [
                '„Ç´„Éº„Éâ„Ç≠„É≥„Ç∞', '„Ç¶„Éé„É¶„Éã„Ç≥„Éº„É≥', '„Ç§„Éä„Ç∫„Éû„Ç¢„Ç§', '„Çø„Éº„Éú„Çø„É≠„Ç¶', '„É°„Ç¨„Éû„ÉÉ„ÇØ„Çπ',
                '„Çπ„Éî„Éº„Éâ„Çµ„Éà„Ç∑', '„Éû„Ç∏„Ç∑„É£„É≥„Éü„Ç´', '„É≠„Ç±„ÉÉ„Éà„É™„Éß„Ç¶', '„Çπ„Éº„Éë„Éº„Çµ„Ç≠', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„É≠„Ç¶',
                '„ÇÆ„Ç¨„Ç¥„É≠„Ç¶', '„Çø„Éº„Éú„Çø„Ç´„Ç∑', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü', '„Éñ„Éº„Çπ„Çø„Éº„Éô„É≥', '„Ç∫„Éº„É†„Çæ„Ç®',
                '„ÇØ„Ç§„ÉÉ„ÇØ„Ç±„É≥„Ç∏', '„É©„ÉÉ„Ç∑„É•„É™„Ç´', '„Çø„Éº„Éú„ÉÜ„É´', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü„Ç™', '„É≠„Ç±„ÉÉ„Éà„É™„Éä',
                '„Ç¶„Éé„Ç¶„É©„É©', '„Ç´„Éº„Éâ„Ç±„É≥', '„Ç§„Éä„Ç∫„Éû„Ç§„Ç∫„Éü', '„Éë„ÉØ„Éº„Éù„É≥', '„É°„Ç¨„Éû„Éü',
                '„Çø„Éº„Éú„Çø„Éü', '„Çπ„Éî„Éº„Éá„Ç£„Çµ„ÉÅ', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç∏', '„Ç∫„Éº„É†„Çº„É≥', '„É≠„Ç±„ÉÉ„Éà„É≠„Éº„Ç∫',
                '„Çπ„Éº„Éë„Éº„Ç´„Çø„ÉÑ„É†„É™', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„Ç¥', '„Çø„Éº„Éú„Éà„Éû„Éà', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç£„ÉÉ„Ç∑„É•', '„Ç¶„Éé„Éï„ÇØ„É≠„Ç¶',
                '„Ç´„Éº„Éâ„Ç´„ÇØ„Çø„Çπ', '„Ç§„Éä„Ç∫„Éû„Éê„Éä„Éä', '„Éë„ÉØ„Éº„Éö„É≥„ÇÆ„É≥', '„É°„Ç¨„É¢„Ç∞„É©', '„Çø„Éº„Éú„Éà„É©'
            ],
            zh: [
                'Âç°Áâå‰πãÁéã', '‰πåËØ∫Áã¨ËßíÂÖΩ', 'Èó™Áîµ‰∏Ω‰∏Ω', 'Ê∂°ËΩÆÂ∞èÊòé', 'Ë∂ÖÁ∫ßÈ∫¶ÂÖãÊñØ',
                'ÈÄüÂ∫¶Â∞èËñá', 'È≠îÊ≥ïÂ∏àÈ©¨ÈáåÂ••', 'ÁÅ´ÁÆ≠Â∞èÈ£û', 'Ë∂ÖÁ∫ßÂ∞èËãè', 'Èó™ÁîµÂ∞èÂº∫',
                'ÂçÉÂÖÜÂ∞èÂàö', 'Ê∂°ËΩÆÂ∞èÊ∂õ', 'Èó™ÂÖâÂ∞èËä≥', 'Âä©Êé®Âô®Â∞èÊú¨', 'Áº©ÊîæÂ∞èÊüî',
                'Âø´ÈÄüÂ∞èÁëû', 'ÂåÜÂøôÂ∞è‰Ω©', 'Ê∂°ËΩÆÂ∞èÂ©∑', 'Èó™ÂÖâÂ∞èÈ£û', 'ÁÅ´ÁÆ≠Â∞èÂÖã',
                '‰πåËØ∫Â∞èÈõ®', 'Âç°ÁâåÂ∞èÈôà', 'Èó™ÁîµÂ∞èËïæ', 'ÂäõÈáèÂ∞è‰øù', 'Ë∂ÖÁ∫ßÂ∞èÁéõ',
                'Ê∂°ËΩÆÂ∞èË∞≠', 'Âø´ÈÄüÂ∞èÊ°ë', 'Èó™ÂÖâÂ∞èÂ≥∞', 'Áº©ÊîæÂ∞èÊ≥Ω', 'ÁÅ´ÁÆ≠Â∞èËî∑',
                'Ë∂ÖÁ∫ßËúóÁâõ', 'Èó™ÁîµËë°ËêÑ', 'Ê∂°ËΩÆÁï™ËåÑ', 'Èó™ÂÖâÂ∞èÈ±º', '‰πåËØ∫Áå´Â§¥Èπ∞',
                'Âç°Áâå‰ªô‰∫∫Êéå', 'Èó™ÁîµÈ¶ôËïâ', 'ÂäõÈáè‰ºÅÈπÖ', 'Ë∂ÖÁ∫ßÈºπÈº†', 'Ê∂°ËΩÆËÄÅËôé'
            ]
        };
        this.usedNames = [];  // Bereits verwendete Namen in diesem Spiel
        
        this.deck = [];
        this.players = []; // Array of all players (index 0 = human player)
        this.discardPile = [];
        this.currentColor = null;
        this.currentValue = null;
        this.currentPlayerIndex = 0; // Index of current player
        this.gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        this.difficulty = 'medium';
        this.playerCount = 2; // Total players (human + computers)
        
        this.calledUno = []; // Track UNO calls for each player
        this.gameInProgress = false; // Prevent multiple simultaneous actions
        this.currentLanguage = localStorage.getItem('unoLanguage') || 'de';
        this.currentBackground = localStorage.getItem('unoBackground') || 'default';
        this.currentCardTheme = localStorage.getItem('unoCardTheme') || 'classic';
        
        this.initializeElements();
        this.setupEventListeners();
        this.initializeLanguage();
        this.initializeBackground();
        this.initializeCardTheme();
        
        // Zeige eine Benachrichtigung √ºber die automatisch erkannte Sprache beim ersten Laden
        this.showLanguageDetectionNotification();
    }
    
    initializeElements() {
        // Screen elements
        this.startScreen = document.getElementById('startScreen');
        this.gameScreen = document.getElementById('gameScreen');
        
        // Game elements
        this.playerCardsContainer = document.getElementById('playerCards');
        this.playersContainer = document.getElementById('playersContainer');
        this.discardPileElement = document.getElementById('discardPile');
        this.drawPileElement = document.getElementById('drawPile');
        
        // UI elements
        this.currentTurnElement = document.getElementById('currentTurn');
        this.colorDisplay = document.getElementById('colorDisplay');
        this.drawCardBtn = document.getElementById('drawCard');
        this.callUnoBtn = document.getElementById('callUno');
        
        // Modals
        this.colorModal = document.getElementById('colorModal');
        this.gameOverModal = document.getElementById('gameOverModal');
        this.rulesModal = document.getElementById('rulesModal');
        this.settingsModal = document.getElementById('settingsModal');
        
        // Start screen elements
        this.playerCountButtons = document.querySelectorAll('.player-count-btn');
        this.difficultyButtons = document.querySelectorAll('.difficulty-btn');
        this.startGameBtn = document.getElementById('startGame');
        
        // Game control elements
        this.restartBtn = document.getElementById('restartButton');
        this.rulesBtn = document.getElementById('rulesButton');
        this.rulesBtnGame = document.getElementById('rulesButtonGame');
        
        // Language elements
        this.languageToggle = document.getElementById('languageToggle');
        this.languageMenu = document.getElementById('languageMenu');
        this.languageOptions = document.querySelectorAll('.language-option');
        this.currentFlag = document.querySelector('.current-flag');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settingsButton');
        this.settingsBtnGame = document.getElementById('settingsButtonGame');
        this.backgroundOptions = document.querySelectorAll('.background-option');
        this.cardThemeOptions = document.querySelectorAll('.card-theme-option');
    }
    
    setupEventListeners() {
        // Player count selection
        this.playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.playerCountButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.playerCount = parseInt(btn.dataset.players);
                this.checkStartButtonEnabled();
            });
        });
        
        // Difficulty selection
        this.difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.difficultyButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = btn.dataset.difficulty;
                this.checkStartButtonEnabled();
            });
        });
        
        // Start game
        this.startGameBtn.addEventListener('click', () => {
            this.startGame();
        });
        
        // Game actions
        this.drawCardBtn.addEventListener('click', () => {
            this.drawCard(0);
        });
        
        this.callUnoBtn.addEventListener('click', () => {
            this.callUno(0);
        });
        
        // Color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectColor(btn.dataset.color);
            });
        });
        
        // Play again
        document.getElementById('playAgain').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Restart button
        this.restartBtn.addEventListener('click', () => {
            if (confirm('M√∂chtest du das Spiel wirklich neu starten?')) {
                this.resetGame();
            }
        });
        
        // Rules button (start screen)
        this.rulesBtn.addEventListener('click', () => {
            this.showRules();
        });
        
        // Rules button (in game)
        this.rulesBtnGame.addEventListener('click', () => {
            this.showRules();
        });
        
        // Close rules modal
        document.getElementById('closeRules').addEventListener('click', () => {
            this.hideRules();
        });
        
        document.getElementById('closeRulesBtn').addEventListener('click', () => {
            this.hideRules();
        });
        
        // Language dropdown
        this.languageToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleLanguageMenu();
        });
        
        this.languageOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.switchLanguage(option.dataset.lang);
                this.hideLanguageMenu();
            });
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            this.hideLanguageMenu();
        });
        
        // Settings
        this.settingsBtn.addEventListener('click', () => {
            this.showSettings();
        });
        
        this.settingsBtnGame.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            this.hideSettings();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.hideSettings();
        });
        
        // Background selection
        this.backgroundOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeBackground(option.dataset.bg);
            });
        });
        
        // Card theme selection
        this.cardThemeOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeCardTheme(option.dataset.theme);
            });
        });
        
        // Draw pile click
        this.drawPileElement.addEventListener('click', () => {
            if (this.currentPlayerIndex === 0 && this.deck.length > 0) {
                this.drawCard(0);
            }
        });
    }
    
    checkStartButtonEnabled() {
        const playerCountSelected = Array.from(this.playerCountButtons).some(btn => btn.classList.contains('selected'));
        const difficultySelected = Array.from(this.difficultyButtons).some(btn => btn.classList.contains('selected'));
        this.startGameBtn.disabled = !(playerCountSelected && difficultySelected);
    }
    
    getRandomComputerName() {
        // Hole die Namen f√ºr die aktuelle Sprache
        const computerNames = this.computerNamesByLanguage[this.currentLanguage] || this.computerNamesByLanguage['de'];
        
        // Wenn alle Namen verwendet wurden, leere die Liste
        if (this.usedNames.length >= computerNames.length) {
            this.usedNames = [];
        }
        
        // W√§hle einen Namen, der noch nicht verwendet wurde
        let availableNames = computerNames.filter(name => !this.usedNames.includes(name));
        const randomIndex = Math.floor(Math.random() * availableNames.length);
        const selectedName = availableNames[randomIndex];
        
        // Markiere den Namen als verwendet
        this.usedNames.push(selectedName);
        
        return selectedName;
    }
    
    createDeck() {
        this.deck = [];
        
        // Number cards (0-9) - 0 has 1 of each color, 1-9 have 2 of each color
        this.colors.forEach(color => {
            this.deck.push({ color, value: '0', type: 'number' });
            for (let i = 1; i <= 9; i++) {
                this.deck.push({ color, value: i.toString(), type: 'number' });
                this.deck.push({ color, value: i.toString(), type: 'number' });
            }
        });
        
        // Action cards (2 of each per color)
        this.colors.forEach(color => {
            this.actions.forEach(action => {
                this.deck.push({ color, value: action, type: 'action' });
                this.deck.push({ color, value: action, type: 'action' });
            });
        });
        
        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
            this.deck.push({ color: 'wild', value: 'wild', type: 'wild' });
            this.deck.push({ color: 'wild', value: 'wild-draw-four', type: 'wild' });
        }
        
        this.shuffleDeck();
    }
    
    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }
    
    dealInitialCards() {
        // Initialize players array
        this.players = [];
        this.calledUno = [];
        
        for (let i = 0; i < this.playerCount; i++) {
            this.players[i] = [];
            this.calledUno[i] = false;
        }
        
        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < this.playerCount; j++) {
                this.players[j].push(this.deck.pop());
            }
        }
        
        // Place first card on discard pile (cannot be wild or action card)
        let firstCard;
        do {
            firstCard = this.deck.pop();
        } while (firstCard.type === 'wild' || firstCard.type === 'action');
        
        this.discardPile = [firstCard];
        this.currentColor = firstCard.color;
        this.currentValue = firstCard.value;
    }
    
    startGame() {
        this.startScreen.classList.add('hidden');
        this.gameScreen.classList.remove('hidden');
        
        this.createDeck();
        this.dealInitialCards();
        this.setupPlayersUI();
        this.currentPlayerIndex = 0;
        this.gameInProgress = true;
        this.updateUI();
        this.updateTurnDisplay();
        
        // Enable UNO button when human player has 2 cards
        this.updateUnoButton();
    }
    
    setupPlayersUI() {
        // Clear existing computer players
        this.playersContainer.innerHTML = '';
        
        // Reset used names for a new game
        this.usedNames = [];
        
        // Create computer player UI elements (skip index 0 = human player)
        for (let i = 1; i < this.playerCount; i++) {
            const computerName = this.getRandomComputerName();
            const playerDiv = document.createElement('div');
            playerDiv.className = 'computer-player';
            playerDiv.id = `player-${i}`;
            
            playerDiv.innerHTML = `
                <div class="player-info">
                    <h3>${computerName}</h3>
                    <div class="card-count">
                        <span id="cardCount-${i}">${this.players[i].length}</span>
                        <span class="cards-text">Karten</span>
                    </div>
                </div>
                <div class="computer-cards" id="computerCards-${i}">
                    <!-- Computer cards will be added here -->
                </div>
            `;
            
            this.playersContainer.appendChild(playerDiv);
            
            // Store the computer name for later use
            if (!this.computerPlayerNames) {
                this.computerPlayerNames = {};
            }
            this.computerPlayerNames[i] = computerName;
        }
    }
    
    resetGame() {
        this.gameInProgress = false; // Stop any ongoing actions
        this.gameOverModal.classList.add('hidden');
        this.gameScreen.classList.add('hidden');
        this.startScreen.classList.remove('hidden');
        
        // Reset game state
        this.calledUno = [];
        this.gameDirection = 1;
        this.currentPlayerIndex = 0;
        this.computerPlayerNames = {}; // Reset computer names
        this.usedNames = []; // Reset used names
        
        // Reset button states
        this.startGameBtn.disabled = true;
        this.playerCountButtons.forEach(btn => btn.classList.remove('selected'));
        this.difficultyButtons.forEach(btn => btn.classList.remove('selected'));
    }
    
    updateUI() {
        this.updatePlayerCards();
        this.updateComputerCards();
        this.updateDiscardPile();
        this.updateDrawPile();
        this.updateCardCounts();
        this.updateColorDisplay();
        this.updateActivePlayer();
    }
    
    updatePlayerCards() {
        this.playerCardsContainer.innerHTML = '';
        this.players[0].forEach((card, index) => {
            const cardElement = this.createCardElement(card, true);
            cardElement.addEventListener('click', () => {
                if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                    this.playCard(0, index);
                }
            });
            
            // Add playable highlight
            if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                cardElement.classList.add('playable');
            }
            
            this.playerCardsContainer.appendChild(cardElement);
        });
    }
    
    updateComputerCards() {
        for (let i = 1; i < this.playerCount; i++) {
            const computerCardsContainer = document.getElementById(`computerCards-${i}`);
            if (computerCardsContainer) {
                computerCardsContainer.innerHTML = '';
                this.players[i].forEach(() => {
                    const cardElement = document.createElement('div');
                    cardElement.className = `computer-card ${this.currentCardTheme}-theme`;
                    cardElement.innerHTML = this.createCardBackContent();
                    computerCardsContainer.appendChild(cardElement);
                });
            }
        }
    }
    
    updateDiscardPile() {
        const topCard = this.discardPile[this.discardPile.length - 1];
        this.discardPileElement.innerHTML = '';
        const cardElement = this.createCardElement(topCard, true);
        this.discardPileElement.appendChild(cardElement);
    }
    
    updateDrawPile() {
        this.drawPileElement.innerHTML = '';
        
        if (this.deck.length > 0) {
            // Show card back when cards are available
            const cardBack = document.createElement('div');
            cardBack.className = `card-back ${this.currentCardTheme}-theme`;
            cardBack.innerHTML = this.createCardBackContent();
            this.drawPileElement.appendChild(cardBack);
            
            // Enable draw button
            this.drawCardBtn.disabled = false;
            this.drawPileElement.style.cursor = 'pointer';
        } else {
            // Show empty state when no cards left
            const emptyPile = document.createElement('div');
            emptyPile.className = 'empty-pile';
            emptyPile.innerHTML = '<span>Leer</span>';
            this.drawPileElement.appendChild(emptyPile);
            
            // Disable draw button and pile
            this.drawCardBtn.disabled = true;
            this.drawPileElement.style.cursor = 'not-allowed';
        }
    }
    
    updateCardCounts() {
        // Update card counts for all computer players
        for (let i = 1; i < this.playerCount; i++) {
            const cardCountElement = document.getElementById(`cardCount-${i}`);
            if (cardCountElement) {
                cardCountElement.textContent = this.players[i].length;
            }
        }
    }
    
    updateActivePlayer() {
        // Remove active class from all players
        for (let i = 1; i < this.playerCount; i++) {
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                playerElement.classList.remove('active');
            }
        }
        
        // Add active class to current player (if computer)
        if (this.currentPlayerIndex > 0) {
            const activePlayerElement = document.getElementById(`player-${this.currentPlayerIndex}`);
            if (activePlayerElement) {
                activePlayerElement.classList.add('active');
            }
        }
    }
    
    updateColorDisplay() {
        // Remove all color classes
        this.colorDisplay.className = 'color-display';
        
        // Add current color class
        if (this.currentColor && this.currentColor !== 'wild') {
            this.colorDisplay.classList.add(this.currentColor);
        }
    }
    
    updateTurnDisplay() {
        if (this.currentPlayerIndex === 0) {
            this.currentTurnElement.textContent = t('game.yourTurn');
            this.currentTurnElement.style.background = 'rgba(76, 175, 80, 0.9)';
        } else {
            const computerName = this.computerPlayerNames && this.computerPlayerNames[this.currentPlayerIndex] 
                ? this.computerPlayerNames[this.currentPlayerIndex] 
                : `Computer ${this.currentPlayerIndex}`;
            this.currentTurnElement.textContent = t('game.computerTurn', computerName);
            this.currentTurnElement.style.background = 'rgba(244, 67, 54, 0.9)';
        }
    }
    
    updateUnoButton() {
        // Enable UNO button when human player has exactly 2 cards and hasn't called UNO yet
        this.callUnoBtn.disabled = !(this.players[0].length === 2 && !this.calledUno[0]);
    }
    
    createCardElement(card, showFace = true) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.color} ${this.currentCardTheme}-theme`;
        
        if (showFace) {
            if (card.type === 'number') {
                cardElement.innerHTML = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                const actionText = {
                    'skip': 'STOP',
                    'reverse': '‚ü≤',
                    'draw-two': '+2'
                };
                cardElement.innerHTML = `<span class="card-value">${actionText[card.value]}</span>`;
            } else if (card.type === 'wild') {
                const wildText = card.value === 'wild' ? 'WILD' : '+4';
                cardElement.innerHTML = `<span class="card-value">${wildText}</span>`;
            }
        } else {
            // R√ºckseite der Karte mit Theme-spezifischem Design
            cardElement.innerHTML = this.createCardBackContent();
        }
        
        return cardElement;
    }
    
    createCardBackContent() {
        switch (this.currentCardTheme) {
            case 'minecraft':
                return '<div class="card-back-minecraft"><span class="pickaxe">‚õèÔ∏è</span></div>';
            case 'mario':
                return '<div class="card-back-mario"><span class="mushroom">üçÑ</span></div>';
            case 'pokemon':
                return '<div class="card-back-pokemon"><span class="pokeball">‚ö´</span></div>';
            case 'cyberpunk':
                return '<div class="card-back-cyberpunk"><span class="skull">üíÄ</span></div>';
            case 'retro':
                return '<div class="card-back-retro"><span class="alien">üëæ</span></div>';
            case 'classic':
            default:
                return '<div class="card-back-classic"><span class="uno-text">UNO</span></div>';
        }
    }
    
    canPlayCard(card) {
        // Wild cards can always be played
        if (card.type === 'wild') {
            return true;
        }
        
        // Regular cards must match color or value
        return card.color === this.currentColor || card.value === this.currentValue;
    }
    
    playCard(playerIndex, cardIndex) {
        const hand = this.players[playerIndex];
        const card = hand[cardIndex];
        
        if (!this.canPlayCard(card)) {
            return false;
        }
        
        // Remove card from hand and add to discard pile
        hand.splice(cardIndex, 1);
        this.discardPile.push(card);
        
        // Add playing animation
        if (playerIndex === 0) {
            const cardElements = this.playerCardsContainer.children;
            if (cardElements[cardIndex]) {
                cardElements[cardIndex].classList.add('playing');
            }
        }
        
        // Handle card effects
        this.handleCardEffect(card);
        
        // Update current color and value
        if (card.type === 'wild') {
            if (playerIndex === 0) {
                this.showColorSelector();
                return true; // Color selector will handle turn switching
            } else {
                // Computer chooses color
                this.currentColor = this.chooseColorForComputer();
                this.showComputerColorChoice();
                // Continue to handle card effects below
            }
        } else {
            this.currentColor = card.color;
        }
        this.currentValue = card.value;
        
        // Check for win condition
        if (hand.length === 0) {
            this.endGame(playerIndex);
            return true;
        }
        
        // Check UNO call requirement
        if (hand.length === 1) {
            if (playerIndex === 0 && !this.calledUno[0]) {
                // Player forgot to call UNO - penalty
                this.penalizePlayer(0);
            } else if (playerIndex > 0 && !this.calledUno[playerIndex]) {
                // Computer calls UNO automatically
                this.callUno(playerIndex);
            }
        }
        
        // Update UI
        this.updateUI();
        this.updateUnoButton();
        
        // Switch turns (card effects handle their own turn logic)
        if (card.value === 'skip' || card.value === 'reverse' || 
            card.value === 'draw-two' || card.value === 'wild-draw-four' || 
            card.value === 'wild') {
            // Action cards and wild cards handle their own turn switching
            return true;
        } else {
            // Regular number cards
            this.switchTurns();
        }
        
        return true;
    }
    
    handleCardEffect(card) {
        switch (card.value) {
            case 'skip':
                // Skip next player's turn - switch twice to skip them
                this.switchTurns(); // Go to next player
                this.switchTurns(); // Skip that player
                break;
                
            case 'reverse':
                this.gameDirection *= -1;
                // In 2-player game, reverse acts like skip
                if (this.playerCount === 2) {
                    this.switchTurns(); // Go to next player
                    this.switchTurns(); // Skip that player (reverse effect)
                } else {
                    this.switchTurns(); // Just change direction
                }
                break;
                
            case 'draw-two':
                const drawTwoTarget = this.getNextPlayerIndex();
                this.drawCards(drawTwoTarget, 2);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild-draw-four':
                const drawFourTarget = this.getNextPlayerIndex();
                this.drawCards(drawFourTarget, 4);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild':
                // Regular wild card - just switch turns normally
                this.switchTurns();
                break;
        }
    }
    
    drawCard(playerIndex) {
        if (this.deck.length === 0) {
            this.reshuffleDeck();
        }
        
        // Check if we still have no cards after reshuffling (shouldn't happen normally)
        if (this.deck.length === 0) {
            console.warn('No cards available to draw!');
            return;
        }
        
        const card = this.deck.pop();
        this.players[playerIndex].push(card);
        
        this.updateUI();
        this.updateUnoButton();
        
        // Reset UNO call status when drawing cards
        this.calledUno[playerIndex] = false;
        
        // After drawing, human player auto-ends turn, computer continues
        if (playerIndex === 0 && this.currentPlayerIndex === 0) {
            // Auto-end human turn after drawing
            setTimeout(() => {
                if (this.currentPlayerIndex === 0) { // Double-check we're still on human turn
                    this.switchTurns();
                }
            }, 1000);
        }
    }
    
    drawCards(playerIndex, count) {
        for (let i = 0; i < count; i++) {
            this.drawCard(playerIndex);
        }
    }
    
    reshuffleDeck() {
        // Keep top card of discard pile, shuffle the rest back into deck
        const topCard = this.discardPile.pop();
        this.deck = [...this.discardPile];
        this.discardPile = [topCard];
        this.shuffleDeck();
    }
    
    getNextPlayerIndex() {
        let nextIndex = this.currentPlayerIndex + this.gameDirection;
        if (nextIndex >= this.playerCount) {
            nextIndex = 0;
        } else if (nextIndex < 0) {
            nextIndex = this.playerCount - 1;
        }
        return nextIndex;
    }
    
    switchTurns() {
        if (!this.gameInProgress) {
            return; // Game ended, don't continue
        }
        
        this.currentPlayerIndex = this.getNextPlayerIndex();
        this.updateTurnDisplay();
        this.updateUI();
        
        if (this.currentPlayerIndex > 0) {
            // Computer's turn
            setTimeout(() => {
                if (this.gameInProgress && this.currentPlayerIndex > 0) {
                    this.computerPlay();
                }
            }, 1500); // Delay for realism
        }
    }
    
    computerPlay() {
        // Safety check - make sure it's actually a computer's turn
        if (this.currentPlayerIndex === 0) {
            console.warn('computerPlay called but it\'s human player\'s turn!');
            return;
        }
        
        const playerIndex = this.currentPlayerIndex;
        const playableCards = this.players[playerIndex]
            .map((card, index) => ({ card, index }))
            .filter(({ card }) => this.canPlayCard(card));
        
        if (playableCards.length > 0) {
            const chosenCard = this.chooseCardForComputer(playableCards, playerIndex);
            this.playCard(playerIndex, chosenCard.index);
        } else {
            // Must draw a card
            this.drawCard(playerIndex);
            // Only switch turns if we're still at the same player (draw didn't trigger other effects)
            if (this.currentPlayerIndex === playerIndex) {
                this.switchTurns();
            }
        }
    }
    
    chooseCardForComputer(playableCards, playerIndex) {
        switch (this.difficulty) {
            case 'easy':
                return this.chooseCardEasy(playableCards, playerIndex);
            case 'medium':
                return this.chooseCardMedium(playableCards, playerIndex);
            case 'hard':
                return this.chooseCardHard(playableCards, playerIndex);
            default:
                return playableCards[0];
        }
    }
    
    chooseCardEasy(playableCards, playerIndex) {
        // Easy: Random selection, prefers regular cards over action cards
        const regularCards = playableCards.filter(({ card }) => card.type === 'number');
        const actionCards = playableCards.filter(({ card }) => card.type === 'action');
        const wildCards = playableCards.filter(({ card }) => card.type === 'wild');
        
        if (regularCards.length > 0 && Math.random() < 0.7) {
            return regularCards[Math.floor(Math.random() * regularCards.length)];
        } else if (actionCards.length > 0 && Math.random() < 0.6) {
            return actionCards[Math.floor(Math.random() * regularCards.length)];
        } else if (wildCards.length > 0) {
            return wildCards[Math.floor(Math.random() * wildCards.length)];
        }
        
        return playableCards[Math.floor(Math.random() * playableCards.length)];
    }
    
    chooseCardMedium(playableCards, playerIndex) {
        // Medium: Balanced strategy, considers card effects
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Check if human player has few cards
        const humanPlayerLowCards = this.players[0].length <= 3;
        
        // Prefer action cards when advantageous
        if (actionCards.length > 0 && humanPlayerLowCards) {
            const preferredActions = actionCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'skip'
            );
            if (preferredActions.length > 0) {
                return preferredActions[0];
            }
        }
        
        // Use wild cards strategically
        if (wildCards.length > 0 && this.players[playerIndex].length <= 2) {
            return wildCards[0];
        }
        
        // Otherwise prefer regular cards
        if (regularCards.length > 0) {
            return regularCards[0];
        }
        
        return playableCards[0];
    }
    
    chooseCardHard(playableCards, playerIndex) {
        // Hard: Advanced strategy, considers multiple factors
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Aggressive play when human player has few cards
        if (this.players[0].length <= 2) {
            const drawCards = playableCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'wild-draw-four'
            );
            if (drawCards.length > 0) {
                // Prefer wild-draw-four over draw-two
                const wildDrawFour = drawCards.find(({ card }) => card.value === 'wild-draw-four');
                return wildDrawFour || drawCards[0];
            }
            
            // Skip player's turn
            const skipCards = actionCards.filter(({ card }) => card.value === 'skip');
            if (skipCards.length > 0) {
                return skipCards[0];
            }
        }
        
        // Color management strategy
        const colorCounts = this.countColorsByFrequency(playerIndex);
        const bestColorCards = regularCards.filter(({ card }) => 
            card.color === colorCounts[0]?.color
        );
        
        if (bestColorCards.length > 0) {
            return bestColorCards[0];
        }
        
        // Save wild cards for last resort unless hand is small
        if (this.players[playerIndex].length <= 3 && wildCards.length > 0) {
            return wildCards[0];
        }
        
        // Default to first available card
        return regularCards[0] || actionCards[0] || wildCards[0] || playableCards[0];
    }
    
    categorizeCards(playableCards) {
        return {
            regularCards: playableCards.filter(({ card }) => card.type === 'number'),
            actionCards: playableCards.filter(({ card }) => card.type === 'action'),
            wildCards: playableCards.filter(({ card }) => card.type === 'wild')
        };
    }
    
    countColorsByFrequency(playerIndex) {
        const colorCounts = {};
        this.players[playerIndex].forEach(card => {
            if (card.color !== 'wild') {
                colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
        });
        
        return Object.entries(colorCounts)
            .map(([color, count]) => ({ color, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    chooseColorForComputer() {
        const colorCounts = this.countColorsByFrequency();
        return colorCounts.length > 0 ? colorCounts[0].color : this.colors[Math.floor(Math.random() * this.colors.length)];
    }
    
    showColorSelector() {
        this.colorModal.classList.remove('hidden');
    }
    
    selectColor(color) {
        this.currentColor = color;
        this.colorModal.classList.add('hidden');
        this.updateUI();
        this.switchTurns();
    }
    
    showComputerColorChoice() {
        // Show feedback about computer's color choice
        const colorNames = {
            'red': 'Rot',
            'blue': 'Blau', 
            'green': 'Gr√ºn',
            'yellow': 'Gelb'
        };
        
        const colorName = colorNames[this.currentColor];
        const originalText = this.currentTurnElement.textContent;
        
        this.currentTurnElement.textContent = `Computer w√§hlt: ${colorName}`;
        this.currentTurnElement.style.background = 'rgba(255, 193, 7, 0.9)';
        
        setTimeout(() => {
            this.updateTurnDisplay();
        }, 2000);
    }
    
    callUno(playerIndex) {
        this.calledUno[playerIndex] = true;
        
        if (playerIndex === 0) {
            this.callUnoBtn.disabled = true;
            
            // Show feedback
            this.currentTurnElement.textContent = t('game.unoCalled');
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        } else {
            // Show computer UNO call
            const computerName = this.computerPlayerNames && this.computerPlayerNames[playerIndex] 
                ? this.computerPlayerNames[playerIndex] 
                : `Computer ${playerIndex}`;
            this.currentTurnElement.textContent = t('game.computerCallsUno', computerName);
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        }
    }
    
    penalizePlayer(playerIndex) {
        // Draw 2 penalty cards for not calling UNO
        this.drawCards(playerIndex, 2);
        
        if (playerIndex === 0) {
            this.currentTurnElement.textContent = t('game.penalized') + ' +2 Karten';
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 2000);
        }
    }
    
    endGame(winnerIndex) {
        this.gameInProgress = false; // Stop all game actions
        
        const gameResult = document.getElementById('gameResult');
        const gameResultText = document.getElementById('gameResultText');
        
        if (winnerIndex === 0) {
            gameResult.textContent = t('game.won');
            gameResult.style.color = '#4caf50';
            gameResultText.textContent = t('game.wonText');
        } else {
            gameResult.textContent = t('game.lost');
            gameResult.style.color = '#f44336';
            const computerName = this.computerPlayerNames && this.computerPlayerNames[winnerIndex] 
                ? this.computerPlayerNames[winnerIndex] 
                : `Computer ${winnerIndex}`;
            gameResultText.textContent = t('game.lostText', computerName);
        }
        
        this.gameOverModal.classList.remove('hidden');
    }
    
    showRules() {
        this.rulesModal.classList.remove('hidden');
    }
    
    hideRules() {
        this.rulesModal.classList.add('hidden');
    }
    
    // Language System
    initializeLanguage() {
        // Automatische Spracherkennung basierend auf Browsersprache
        if (!localStorage.getItem('unoLanguage')) {
            const detectedLanguage = this.detectBrowserLanguage();
            this.currentLanguage = detectedLanguage;
            localStorage.setItem('unoLanguage', detectedLanguage);
        }
        
        this.updateLanguageDisplay();
        this.updateAllTexts();
    }
    
    detectBrowserLanguage() {
        // Browsersprache abrufen
        const browserLang = navigator.language || navigator.userLanguage || 'de';
        const primaryLang = browserLang.split('-')[0].toLowerCase();
        
        // Verf√ºgbare Sprachen im Spiel
        const availableLanguages = ['de', 'en', 'es', 'fr', 'pt', 'ja', 'zh', 'hu', 'ru'];
        
        // Direkte √úbereinstimmung finden
        if (availableLanguages.includes(primaryLang)) {
            return primaryLang;
        }
        
        // Sprachzuordnung f√ºr √§hnliche Sprachen
        const languageMapping = {
            'en-us': 'en', 'en-gb': 'en', 'en-ca': 'en', 'en-au': 'en',
            'es-mx': 'es', 'es-ar': 'es', 'es-cl': 'es', 'es-co': 'es',
            'fr-ca': 'fr', 'fr-be': 'fr', 'fr-ch': 'fr', 'fr-lu': 'fr',
            'pt-pt': 'pt', 'pt-ao': 'pt', 'pt-mo': 'pt',
            'ja-jp': 'ja',
            'zh-cn': 'zh', 'zh-tw': 'zh', 'zh-hk': 'zh', 'zh-sg': 'zh',
            'hu-hu': 'hu',
            'ru-ru': 'ru', 'ru-ua': 'ru', 'ru-kz': 'ru', 'ru-by': 'ru'
        };
        
        // Vollst√§ndige Sprachcode-√úbereinstimmung
        if (languageMapping[browserLang.toLowerCase()]) {
            return languageMapping[browserLang.toLowerCase()];
        }
        
        // Fallback auf Deutsch
        return 'de';
    }
    
    showLanguageDetectionNotification() {
        // Zeige nur beim ersten Laden eine Benachrichtigung √ºber die erkannte Sprache
        if (!localStorage.getItem('unoLanguageNotificationShown')) {
            const languageNames = {
                'de': 'Deutsch',
                'en': 'English',
                'es': 'Espa√±ol',
                'fr': 'Fran√ßais',
                'pt': 'Portugu√™s',
                'ja': 'Êó•Êú¨Ë™û',
                'zh': '‰∏≠Êñá',
                'hu': 'Magyar',
                'ru': '–†—É—Å—Å–∫–∏–π'
            };
            
            const detectedLangName = languageNames[this.currentLanguage] || 'Deutsch';
            
            // Erstelle eine tempor√§re Benachrichtigung
            const notification = document.createElement('div');
            notification.className = 'language-notification';
            notification.innerHTML = `
                <span>üåç Sprache automatisch erkannt: ${detectedLangName}</span>
                <button class="notification-close">‚úï</button>
            `;
            
            // Styling f√ºr die Benachrichtigung
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideIn 0.3s ease-out;
            `;
            
            // Schlie√üen-Button Styling
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
                padding: 0;
                margin: 0;
            `;
            
            // Event Listener f√ºr den Schlie√üen-Button
            closeBtn.addEventListener('click', () => {
                notification.remove();
            });
            
            // F√ºge CSS-Animation hinzu
            if (!document.querySelector('#language-notification-styles')) {
                const style = document.createElement('style');
                style.id = 'language-notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // F√ºge die Benachrichtigung zum DOM hinzu
            document.body.appendChild(notification);
            
            // Automatisch nach 5 Sekunden ausblenden
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
            
            // Markiere als angezeigt
            localStorage.setItem('unoLanguageNotificationShown', 'true');
        }
    }
    
    switchLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('unoLanguage', lang);
        this.updateLanguageDisplay();
        this.updateAllTexts();
        
        // Wenn ein Spiel l√§uft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
    }
    
    regenerateComputerNames() {
        // Reset verwendet Namen und generiere neue Namen f√ºr alle Computer
        this.usedNames = [];
        for (let i = 1; i < this.playerCount; i++) {
            const newName = this.getRandomComputerName();
            this.computerPlayerNames[i] = newName;
            
            // Update UI
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                const nameElement = playerElement.querySelector('.player-info h3');
                if (nameElement) {
                    nameElement.textContent = newName;
                }
            }
        }
        
        // Update turn display with new names
        this.updateTurnDisplay();
    }
    
    toggleLanguageMenu() {
        this.languageMenu.classList.toggle('hidden');
        this.languageToggle.classList.toggle('open');
    }
    
    hideLanguageMenu() {
        this.languageMenu.classList.add('hidden');
        this.languageToggle.classList.remove('open');
    }
    
    updateLanguageDisplay() {
        // Update current flag in toggle button
        const languageFlags = {
            'de': 'üá©üá™',
            'en': 'üá¨üáß', 
            'es': 'üá™üá∏',
            'fr': 'üá´üá∑',
            'pt': 'üáßüá∑',
            'ja': 'üáØüáµ',
            'zh': 'üá®üá≥',
            'hu': 'üá≠üá∫',
            'ru': 'üá∑üá∫'
        };
        
        this.currentFlag.textContent = languageFlags[this.currentLanguage] || 'üá©üá™';
        
        // Update active state in dropdown
        this.languageOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.lang === this.currentLanguage);
        });
    }
    
    updateAllTexts() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = t(key);
        });
        
        // Update dynamic texts if game is running
        if (this.gameInProgress) {
            this.updateTurnDisplay();
        }
    }
    
    // Settings System
    showSettings() {
        this.settingsModal.classList.remove('hidden');
    }
    
    hideSettings() {
        this.settingsModal.classList.add('hidden');
    }
    
    initializeBackground() {
        this.applyBackground(this.currentBackground);
        this.updateBackgroundOptions();
    }
    
    changeBackground(bgName) {
        this.currentBackground = bgName;
        localStorage.setItem('unoBackground', bgName);
        this.applyBackground(bgName);
        this.updateBackgroundOptions();
    }
    
    applyBackground(bgName) {
        // Remove all background classes
        document.body.className = document.body.className.replace(/bg-\w+/g, '');
        // Add new background class
        document.body.classList.add(`bg-${bgName}`);
    }
    
    updateBackgroundOptions() {
        this.backgroundOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.bg === this.currentBackground);
        });
    }
    
    initializeCardTheme() {
        this.applyCardTheme(this.currentCardTheme);
        this.updateCardThemeOptions();
    }
    
    changeCardTheme(themeName) {
        this.currentCardTheme = themeName;
        localStorage.setItem('unoCardTheme', themeName);
        this.applyCardTheme(themeName);
        this.updateCardThemeOptions();
    }
    
    applyCardTheme(themeName) {
        // Remove all existing theme classes from cards
        const allCards = document.querySelectorAll('.card, .computer-card, .card-back');
        allCards.forEach(card => {
            card.classList.remove('classic-theme', 'minecraft-theme', 'mario-theme', 'pokemon-theme', 'cyberpunk-theme', 'retro-theme');
            card.classList.add(themeName + '-theme');
            
            // Update card back content if it's a back side
            if (card.classList.contains('computer-card') || card.classList.contains('card-back')) {
                card.innerHTML = this.createCardBackContent();
            }
        });
        
        // Store current theme for new cards
        document.body.setAttribute('data-card-theme', themeName);
    }
    
    updateCardThemeOptions() {
        this.cardThemeOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.theme === this.currentCardTheme);
        });
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new UnoGame();
});