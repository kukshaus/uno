// Version
const APP_VERSION = "1.0.0";

// Translations
const translations = {
    de: {
        "game.title": "UNO",
        "start.playerCount": "Anzahl Computer-Gegner:",
        "start.players2": "Du + 1 Computer",
        "start.players3": "Du + 2 Computer", 
        "start.players4": "Du + 3 Computer",
        "start.difficulty": "Schwierigkeitsgrad w√§hlen:",
        "difficulty.easy": "Einfach",
        "difficulty.easyDesc": "Defensiver Computer",
        "difficulty.medium": "Mittel",
        "difficulty.mediumDesc": "Ausgewogener Computer",
        "difficulty.hard": "Schwer",
        "difficulty.hardDesc": "Strategischer Computer",
        "start.rules": "Spielregeln",
        "start.startGame": "Spiel starten",
        "game.yourTurn": "Dein Zug",
        "game.computerTurn": "Computer {0} ist dran",
        "game.drawCard": "Karte ziehen",
        "game.uno": "UNO!",
        "game.currentColor": "Aktuelle Farbe:",
        "game.cards": "Karten",
        "game.chooseColor": "Farbe w√§hlen:",
        "game.computerChooses": "Computer w√§hlt: {0}",
        "game.unoCalled": "UNO gerufen!",
        "game.computerCallsUno": "Computer {0} ruft UNO!",
        "game.unoForgotten": "UNO vergessen! +2 Karten",
        "game.won": "Gewonnen! üéâ",
        "game.lost": "Verloren üòî", 
        "game.wonText": "Herzlichen Gl√ºckwunsch! Du hast das Spiel gewonnen!",
        "game.lostText": "Computer {0} hat gewonnen. Versuch es nochmal!",
        "game.playAgain": "Nochmal spielen",
        "game.restart": "M√∂chtest du das Spiel wirklich neu starten?",
        "game.empty": "Leer",
        "colors.red": "Rot",
        "colors.blue": "Blau", 
        "colors.green": "Gr√ºn",
        "colors.yellow": "Gelb",
        "settings.title": "Einstellungen",
        "settings.background": "üé® Hintergrund",
        "settings.bg.default": "Standard",
        "settings.bg.ocean": "Ozean",
        "settings.bg.sunset": "Sonnenuntergang",
        "settings.bg.forest": "Wald",
        "settings.bg.space": "Weltraum",
        "settings.bg.gradient": "Farbverlauf",
        "settings.close": "Fertig",
        "settings.version": "Version {0}",
        "language.auto": "Auto (Browser)",
        "settings.computerSpeed": "ü§ñ Computer-Geschwindigkeit",
        "settings.speed.instant": "Sofort",
        "settings.speed.fast": "Schnell",
        "settings.speed.normal": "Normal", 
        "settings.speed.slow": "Langsam",
        "skill.title": "üèÜ Fertigkeits-Level",
        "skill.level": "Level {0}",
        "skill.xp": "EP: {0}/{1}",
        "skill.stats": "Statistiken",
        "skill.wins": "Siege:",
        "skill.losses": "Niederlagen:",
        "skill.winRate": "Siegquote:",
        "skill.avgCardsLeft": "√ò Karten √ºbrig:",
        "skill.avgTurns": "√ò Z√ºge pro Spiel:",
        "skill.totalGames": "Spiele gesamt:",
        "skill.levelUp": "Level aufgestiegen! üéâ",
        "skill.newLevel": "Neues Level: {0}",
        "skill.reward": "Belohnung freigeschaltet: {0}",
        "skill.noob": "Anf√§nger",
        "skill.beginner": "Einsteiger", 
        "skill.amateur": "Amateur",
        "skill.skilled": "Ge√ºbt",
        "skill.expert": "Experte",
        "skill.master": "Meister",
        "skill.legend": "Legende",
        "skill.god": "Gott",
        "reward.theme": "Neues Theme",
        "reward.title": "Neuer Titel",
        "reward.badge": "Neues Abzeichen"
    },
    en: {
        "game.title": "UNO",
        "start.playerCount": "Number of Computer Opponents:",
        "start.players2": "You + 1 Computer",
        "start.players3": "You + 2 Computers",
        "start.players4": "You + 3 Computers", 
        "start.difficulty": "Choose Difficulty:",
        "difficulty.easy": "Easy",
        "difficulty.easyDesc": "Defensive Computer",
        "difficulty.medium": "Medium",
        "difficulty.mediumDesc": "Balanced Computer",
        "difficulty.hard": "Hard",
        "difficulty.hardDesc": "Strategic Computer",
        "start.rules": "Game Rules",
        "start.startGame": "Start Game",
        "game.yourTurn": "Your Turn",
        "game.computerTurn": "Computer {0}'s Turn",
        "game.drawCard": "Draw Card",
        "game.uno": "UNO!",
        "game.currentColor": "Current Color:",
        "game.cards": "Cards",
        "game.chooseColor": "Choose Color:",
        "game.computerChooses": "Computer chooses: {0}",
        "game.unoCalled": "UNO called!",
        "game.computerCallsUno": "Computer {0} calls UNO!",
        "game.unoForgotten": "UNO forgotten! +2 Cards",
        "game.won": "You Won! üéâ",
        "game.lost": "You Lost üòî",
        "game.wonText": "Congratulations! You won the game!",
        "game.lostText": "Computer {0} won. Try again!",
        "game.playAgain": "Play Again",
        "game.restart": "Do you really want to restart the game?",
        "game.empty": "Empty",
        "colors.red": "Red",
        "colors.blue": "Blue",
        "colors.green": "Green", 
        "colors.yellow": "Yellow",
        "settings.title": "Settings",
        "settings.background": "üé® Background",
        "settings.bg.default": "Default",
        "settings.bg.ocean": "Ocean",
        "settings.bg.sunset": "Sunset",
        "settings.bg.forest": "Forest",
        "settings.bg.space": "Space",
        "settings.bg.gradient": "Gradient",
        "settings.close": "Done",
        "settings.version": "Version {0}",
        "language.auto": "Auto (Browser)",
        "settings.computerSpeed": "ü§ñ Computer Speed",
        "settings.speed.instant": "Instant",
        "settings.speed.fast": "Fast",
        "settings.speed.normal": "Normal",
        "settings.speed.slow": "Slow",
        "skill.title": "üèÜ Skill Level",
        "skill.level": "Level {0}",
        "skill.xp": "XP: {0}/{1}",
        "skill.stats": "Statistics",
        "skill.wins": "Wins:",
        "skill.losses": "Losses:",
        "skill.winRate": "Win Rate:",
        "skill.avgCardsLeft": "Avg Cards Left:",
        "skill.avgTurns": "Avg Turns per Game:",
        "skill.totalGames": "Total Games:",
        "skill.levelUp": "Level Up! üéâ",
        "skill.newLevel": "New Level: {0}",
        "skill.reward": "Reward Unlocked: {0}",
        "skill.noob": "Noob",
        "skill.beginner": "Beginner",
        "skill.amateur": "Amateur", 
        "skill.skilled": "Skilled",
        "skill.expert": "Expert",
        "skill.master": "Master",
        "skill.legend": "Legend",
        "skill.god": "God",
        "reward.theme": "New Theme",
        "reward.title": "New Title",
        "reward.badge": "New Badge"
    },
    hu: {
        "game.title": "UNO",
        "start.playerCount": "Sz√°m√≠t√≥g√©pes ellenfelek sz√°ma:",
        "start.players2": "Te + 1 Sz√°m√≠t√≥g√©p",
        "start.players3": "Te + 2 Sz√°m√≠t√≥g√©p",
        "start.players4": "Te + 3 Sz√°m√≠t√≥g√©p",
        "start.difficulty": "Neh√©zs√©gi szint:",
        "difficulty.easy": "K√∂nny≈±",
        "difficulty.easyDesc": "Defenz√≠v sz√°m√≠t√≥g√©p",
        "difficulty.medium": "K√∂zepes",
        "difficulty.mediumDesc": "Kiegyens√∫lyozott sz√°m√≠t√≥g√©p",
        "difficulty.hard": "Neh√©z",
        "difficulty.hardDesc": "Strat√©giai sz√°m√≠t√≥g√©p",
        "start.rules": "J√°t√©kszab√°lyok",
        "start.startGame": "J√°t√©k ind√≠t√°sa",
        "game.yourTurn": "Te k√∂vetkezel",
        "game.computerTurn": "{0}. sz√°m√≠t√≥g√©p k√∂vetkezik",
        "game.drawCard": "K√°rtya h√∫z√°sa",
        "game.uno": "UNO!",
        "game.currentColor": "Jelenlegi sz√≠n:",
        "game.cards": "K√°rty√°k",
        "game.chooseColor": "Sz√≠n v√°laszt√°sa:",
        "game.computerChooses": "A sz√°m√≠t√≥g√©p v√°laszt: {0}",
        "game.unoCalled": "UNO mondva!",
        "game.computerCallsUno": "{0}. sz√°m√≠t√≥g√©p UNO-t mond!",
        "game.unoForgotten": "UNO elfelejtve! +2 K√°rtya",
        "game.won": "Nyert√©l! üéâ",
        "game.lost": "Vesztett√©l üòî",
        "game.wonText": "Gratul√°lok! Megnyerted a j√°t√©kot!",
        "game.lostText": "{0}. sz√°m√≠t√≥g√©p nyert. Pr√≥b√°ld √∫jra!",
        "game.playAgain": "√öjra j√°t√©k",
        "game.restart": "Biztosan √∫jra szeretn√©d ind√≠tani a j√°t√©kot?",
        "game.empty": "√úres",
        "colors.red": "Piros",
        "colors.blue": "K√©k",
        "colors.green": "Z√∂ld",
        "colors.yellow": "S√°rga",
        "settings.title": "Be√°ll√≠t√°sok",
        "settings.background": "üé® H√°tt√©r",
        "settings.bg.default": "Alap√©rtelmezett",
        "settings.bg.ocean": "√ìce√°n",
        "settings.bg.sunset": "Naplemente",
        "settings.bg.forest": "Erd≈ë",
        "settings.bg.space": "Vil√°g≈±r",
        "settings.bg.gradient": "Sz√≠n√°tmenet",
        "settings.close": "K√©sz",
        "settings.version": "Verzi√≥ {0}",
        "language.auto": "Auto (B√∂ng√©sz≈ë)",
        "settings.computerSpeed": "ü§ñ Sz√°m√≠t√≥g√©p Sebess√©g",
        "settings.speed.instant": "Azonnali",
        "settings.speed.fast": "Gyors",
        "settings.speed.normal": "Norm√°l",
        "settings.speed.slow": "Lass√∫",
        "skill.title": "üèÜ √úgyess√©gi Szint",
        "skill.level": "Szint {0}",
        "skill.xp": "TP: {0}/{1}",
        "skill.stats": "Statisztik√°k",
        "skill.wins": "Gy≈ëzelmek:",
        "skill.losses": "Veres√©gek:",
        "skill.winRate": "Gy≈ëzelmi Ar√°ny:",
        "skill.avgCardsLeft": "√Åtl. Maradt K√°rty√°k:",
        "skill.avgTurns": "√Åtl. K√∂r√∂k/J√°t√©k:",
        "skill.totalGames": "√ñsszes J√°t√©k:",
        "skill.levelUp": "Szintl√©p√©s! üéâ",
        "skill.newLevel": "√öj Szint: {0}",
        "skill.reward": "Jutalom Feloldva: {0}",
        "skill.noob": "Kezd≈ë",
        "skill.beginner": "√öjoncz",
        "skill.amateur": "Amat≈ër",
        "skill.skilled": "Tapasztalt",
        "skill.expert": "Szak√©rt≈ë",
        "skill.master": "Mester",
        "skill.legend": "Legenda",
        "skill.god": "Isten",
        "reward.theme": "√öj T√©ma",
        "reward.title": "√öj C√≠m",
        "reward.badge": "√öj Jelv√©ny"
    },
    ru: {
        "game.title": "–£–ù–û",
        "start.playerCount": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤:",
        "start.players2": "–¢—ã + 1 –ö–æ–º–ø—å—é—Ç–µ—Ä",
        "start.players3": "–¢—ã + 2 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.players4": "–¢—ã + 3 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.difficulty": "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å:",
        "difficulty.easy": "–õ–µ–≥–∫–æ",
        "difficulty.easyDesc": "–û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.medium": "–°—Ä–µ–¥–Ω–µ",
        "difficulty.mediumDesc": "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.hard": "–°–ª–æ–∂–Ω–æ",
        "difficulty.hardDesc": "–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "start.rules": "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã",
        "start.startGame": "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
        "game.yourTurn": "–í–∞—à —Ö–æ–¥",
        "game.computerTurn": "–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {0}",
        "game.drawCard": "–í–∑—è—Ç—å –∫–∞—Ä—Ç—É",
        "game.uno": "–£–ù–û!",
        "game.currentColor": "–¢–µ–∫—É—â–∏–π —Ü–≤–µ—Ç:",
        "game.cards": "–ö–∞—Ä—Ç—ã",
        "game.chooseColor": "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:",
        "game.computerChooses": "–ö–æ–º–ø—å—é—Ç–µ—Ä –≤—ã–±–∏—Ä–∞–µ—Ç: {0}",
        "game.unoCalled": "–£–ù–û –æ–±—ä—è–≤–ª–µ–Ω–æ!",
        "game.computerCallsUno": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –æ–±—ä—è–≤–ª—è–µ—Ç –£–ù–û!",
        "game.unoForgotten": "–£–ù–û –∑–∞–±—ã—Ç–æ! +2 –ö–∞—Ä—Ç—ã",
        "game.won": "–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏! üéâ",
        "game.lost": "–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ üòî",
        "game.wonText": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –∏–≥—Ä—É!",
        "game.lostText": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –≤—ã–∏–≥—Ä–∞–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!",
        "game.playAgain": "–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞",
        "game.restart": "–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É?",
        "game.empty": "–ü—É—Å—Ç–æ",
        "colors.red": "–ö—Ä–∞—Å–Ω—ã–π",
        "colors.blue": "–°–∏–Ω–∏–π",
        "colors.green": "–ó–µ–ª—ë–Ω—ã–π",
        "colors.yellow": "–ñ—ë–ª—Ç—ã–π",
        "settings.title": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings.background": "üé® –§–æ–Ω",
        "settings.bg.default": "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings.bg.ocean": "–û–∫–µ–∞–Ω",
        "settings.bg.sunset": "–ó–∞–∫–∞—Ç",
        "settings.bg.forest": "–õ–µ—Å",
        "settings.bg.space": "–ö–æ—Å–º–æ—Å",
        "settings.bg.gradient": "–ì—Ä–∞–¥–∏–µ–Ω—Ç",
        "settings.close": "–ì–æ—Ç–æ–≤–æ",
        "settings.version": "–í–µ—Ä—Å–∏—è {0}",
        "language.auto": "–ê–≤—Ç–æ (–ë—Ä–∞—É–∑–µ—Ä)",
        "settings.computerSpeed": "ü§ñ –°–∫–æ—Ä–æ—Å—Ç—å –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "settings.speed.instant": "–ú–≥–Ω–æ–≤–µ–Ω–Ω–æ",
        "settings.speed.fast": "–ë—ã—Å—Ç—Ä–æ",
        "settings.speed.normal": "–ù–æ—Ä–º–∞–ª—å–Ω–æ",
        "settings.speed.slow": "–ú–µ–¥–ª–µ–Ω–Ω–æ",
        "skill.title": "üèÜ –£—Ä–æ–≤–µ–Ω—å –ù–∞–≤—ã–∫–∞",
        "skill.level": "–£—Ä–æ–≤–µ–Ω—å {0}",
        "skill.xp": "–û–ø—ã—Ç: {0}/{1}",
        "skill.stats": "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "skill.wins": "–ü–æ–±–µ–¥—ã:",
        "skill.losses": "–ü–æ—Ä–∞–∂–µ–Ω–∏—è:",
        "skill.winRate": "–ü—Ä–æ—Ü–µ–Ω—Ç –ü–æ–±–µ–¥:",
        "skill.avgCardsLeft": "–°—Ä–µ–¥. –ö–∞—Ä—Ç –û—Å—Ç–∞–ª–æ—Å—å:",
        "skill.avgTurns": "–°—Ä–µ–¥. –•–æ–¥–æ–≤ –∑–∞ –ò–≥—Ä—É:",
        "skill.totalGames": "–í—Å–µ–≥–æ –ò–≥—Ä:",
        "skill.levelUp": "–ü–æ–≤—ã—à–µ–Ω–∏–µ –£—Ä–æ–≤–Ω—è! üéâ",
        "skill.newLevel": "–ù–æ–≤—ã–π –£—Ä–æ–≤–µ–Ω—å: {0}",
        "skill.reward": "–ù–∞–≥—Ä–∞–¥–∞ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞: {0}",
        "skill.noob": "–ù–æ–≤–∏—á–æ–∫",
        "skill.beginner": "–ù–∞—á–∏–Ω–∞—é—â–∏–π",
        "skill.amateur": "–õ—é–±–∏—Ç–µ–ª—å",
        "skill.skilled": "–£–º–µ–ª—ã–π",
        "skill.expert": "–≠–∫—Å–ø–µ—Ä—Ç",
        "skill.master": "–ú–∞—Å—Ç–µ—Ä",
        "skill.legend": "–õ–µ–≥–µ–Ω–¥–∞",
        "skill.god": "–ë–æ–≥",
        "reward.theme": "–ù–æ–≤–∞—è –¢–µ–º–∞",
        "reward.title": "–ù–æ–≤—ã–π –¢–∏—Ç—É–ª",
        "reward.badge": "–ù–æ–≤—ã–π –ó–Ω–∞—á–æ–∫"
    },
    es: {
        "game.title": "UNO",
        "start.playerCount": "N√∫mero de oponentes computadora:",
        "start.players2": "T√∫ + 1 Computadora",
        "start.players3": "T√∫ + 2 Computadoras",
        "start.players4": "T√∫ + 3 Computadoras",
        "start.difficulty": "Elegir dificultad:",
        "difficulty.easy": "F√°cil",
        "difficulty.easyDesc": "Computadora defensiva",
        "difficulty.medium": "Medio",
        "difficulty.mediumDesc": "Computadora equilibrada",
        "difficulty.hard": "Dif√≠cil",
        "difficulty.hardDesc": "Computadora estrat√©gica",
        "start.rules": "Reglas del juego",
        "start.startGame": "Empezar juego",
        "game.yourTurn": "Tu turno",
        "game.computerTurn": "Turno de {0}",
        "game.drawCard": "Robar carta",
        "game.uno": "¬°UNO!",
        "game.currentColor": "Color actual:",
        "game.cards": "Cartas",
        "game.chooseColor": "Elegir color:",
        "game.computerChooses": "La computadora elige: {0}",
        "game.unoCalled": "¬°UNO gritado!",
        "game.computerCallsUno": "¬°{0} grita UNO!",
        "game.unoForgotten": "¬°UNO olvidado! +2 Cartas",
        "game.won": "¬°Ganaste! üéâ",
        "game.lost": "Perdiste üòî",
        "game.wonText": "¬°Felicidades! ¬°Ganaste el juego!",
        "game.lostText": "{0} gan√≥. ¬°Int√©ntalo de nuevo!",
        "game.playAgain": "Jugar de nuevo",
        "game.restart": "¬øRealmente quieres reiniciar el juego?",
        "game.empty": "Vac√≠o",
        "colors.red": "Rojo",
        "colors.blue": "Azul",
        "colors.green": "Verde",
        "colors.yellow": "Amarillo",
        "settings.title": "Configuraci√≥n",
        "settings.background": "üé® Fondo",
        "settings.bg.default": "Por defecto",
        "settings.bg.ocean": "Oc√©ano",
        "settings.bg.sunset": "Atardecer",
        "settings.bg.forest": "Bosque",
        "settings.bg.space": "Espacio",
        "settings.bg.gradient": "Gradiente",
        "settings.close": "Listo",
        "settings.version": "Versi√≥n {0}",
        "language.auto": "Auto (Navegador)",
        "settings.computerSpeed": "ü§ñ Velocidad del Ordenador",
        "settings.speed.instant": "Instant√°neo",
        "settings.speed.fast": "R√°pido",
        "settings.speed.normal": "Normal",
        "settings.speed.slow": "Lento",
        "skill.title": "üèÜ Nivel de Habilidad",
        "skill.level": "Nivel {0}",
        "skill.xp": "EXP: {0}/{1}",
        "skill.stats": "Estad√≠sticas",
        "skill.wins": "Victorias:",
        "skill.losses": "Derrotas:",
        "skill.winRate": "Tasa de Victoria:",
        "skill.avgCardsLeft": "Prom. Cartas Restantes:",
        "skill.avgTurns": "Prom. Turnos por Juego:",
        "skill.totalGames": "Juegos Totales:",
        "skill.levelUp": "¬°Subiste de Nivel! üéâ",
        "skill.newLevel": "Nuevo Nivel: {0}",
        "skill.reward": "Recompensa Desbloqueada: {0}",
        "skill.noob": "Novato",
        "skill.beginner": "Principiante",
        "skill.amateur": "Amateur",
        "skill.skilled": "H√°bil",
        "skill.expert": "Experto",
        "skill.master": "Maestro",
        "skill.legend": "Leyenda",
        "skill.god": "Dios",
        "reward.theme": "Nuevo Tema",
        "reward.title": "Nuevo T√≠tulo",
        "reward.badge": "Nueva Insignia"
    },
    fr: {
        "game.title": "UNO",
        "start.playerCount": "Nombre d'adversaires ordinateur:",
        "start.players2": "Toi + 1 Ordinateur",
        "start.players3": "Toi + 2 Ordinateurs",
        "start.players4": "Toi + 3 Ordinateurs",
        "start.difficulty": "Choisir la difficult√©:",
        "difficulty.easy": "Facile",
        "difficulty.easyDesc": "Ordinateur d√©fensif",
        "difficulty.medium": "Moyen",
        "difficulty.mediumDesc": "Ordinateur √©quilibr√©",
        "difficulty.hard": "Difficile",
        "difficulty.hardDesc": "Ordinateur strat√©gique",
        "start.rules": "R√®gles du jeu",
        "start.startGame": "Commencer le jeu",
        "game.yourTurn": "Votre tour",
        "game.computerTurn": "Tour de {0}",
        "game.drawCard": "Piocher une carte",
        "game.uno": "UNO!",
        "game.currentColor": "Couleur actuelle:",
        "game.cards": "Cartes",
        "game.chooseColor": "Choisir la couleur:",
        "game.computerChooses": "L'ordinateur choisit: {0}",
        "game.unoCalled": "UNO annonc√©!",
        "game.computerCallsUno": "{0} annonce UNO!",
        "game.unoForgotten": "UNO oubli√©! +2 Cartes",
        "game.won": "Vous avez gagn√©! üéâ",
        "game.lost": "Vous avez perdu üòî",
        "game.wonText": "F√©licitations! Vous avez gagn√© le jeu!",
        "game.lostText": "{0} a gagn√©. Essayez encore!",
        "game.playAgain": "Rejouer",
        "game.restart": "Voulez-vous vraiment red√©marrer le jeu?",
        "game.empty": "Vide",
        "colors.red": "Rouge",
        "colors.blue": "Bleu",
        "colors.green": "Vert",
        "colors.yellow": "Jaune",
        "settings.title": "Param√®tres",
        "settings.background": "üé® Arri√®re-plan",
        "settings.bg.default": "Par d√©faut",
        "settings.bg.ocean": "Oc√©an",
        "settings.bg.sunset": "Coucher de soleil",
        "settings.bg.forest": "For√™t",
        "settings.bg.space": "Espace",
        "settings.bg.gradient": "D√©grad√©",
        "settings.close": "Termin√©",
        "settings.version": "Version {0}",
        "language.auto": "Auto (Navigateur)",
        "settings.computerSpeed": "ü§ñ Vitesse de l'Ordinateur",
        "settings.speed.instant": "Instantan√©",
        "settings.speed.fast": "Rapide",
        "settings.speed.normal": "Normal",
        "settings.speed.slow": "Lent",
        "skill.title": "üèÜ Niveau de Comp√©tence",
        "skill.level": "Niveau {0}",
        "skill.xp": "EXP: {0}/{1}",
        "skill.stats": "Statistiques",
        "skill.wins": "Victoires:",
        "skill.losses": "D√©faites:",
        "skill.winRate": "Taux de Victoire:",
        "skill.avgCardsLeft": "Moy. Cartes Restantes:",
        "skill.avgTurns": "Moy. Tours par Partie:",
        "skill.totalGames": "Parties Totales:",
        "skill.levelUp": "Mont√©e de Niveau! üéâ",
        "skill.newLevel": "Nouveau Niveau: {0}",
        "skill.reward": "R√©compense D√©bloqu√©e: {0}",
        "skill.noob": "D√©butant",
        "skill.beginner": "Novice",
        "skill.amateur": "Amateur",
        "skill.skilled": "Comp√©tent",
        "skill.expert": "Expert",
        "skill.master": "Ma√Ætre",
        "skill.legend": "L√©gende",
        "skill.god": "Dieu",
        "reward.theme": "Nouveau Th√®me",
        "reward.title": "Nouveau Titre",
        "reward.badge": "Nouveau Badge"
    },
    pt: {
        "game.title": "UNO",
        "start.playerCount": "N√∫mero de oponentes computador:",
        "start.players2": "Voc√™ + 1 Computador",
        "start.players3": "Voc√™ + 2 Computadores",
        "start.players4": "Voc√™ + 3 Computadores",
        "start.difficulty": "Escolher dificuldade:",
        "difficulty.easy": "F√°cil",
        "difficulty.easyDesc": "Computador defensivo",
        "difficulty.medium": "M√©dio",
        "difficulty.mediumDesc": "Computador equilibrado",
        "difficulty.hard": "Dif√≠cil",
        "difficulty.hardDesc": "Computador estrat√©gico",
        "start.rules": "Regras do jogo",
        "start.startGame": "Come√ßar jogo",
        "game.yourTurn": "Sua vez",
        "game.computerTurn": "Vez de {0}",
        "game.drawCard": "Comprar carta",
        "game.uno": "UNO!",
        "game.currentColor": "Cor atual:",
        "game.cards": "Cartas",
        "game.chooseColor": "Escolher cor:",
        "game.computerChooses": "O computador escolhe: {0}",
        "game.unoCalled": "UNO gritado!",
        "game.computerCallsUno": "{0} grita UNO!",
        "game.unoForgotten": "UNO esquecido! +2 Cartas",
        "game.won": "Voc√™ ganhou! üéâ",
        "game.lost": "Voc√™ perdeu üòî",
        "game.wonText": "Parab√©ns! Voc√™ ganhou o jogo!",
        "game.lostText": "{0} ganhou. Tente novamente!",
        "game.playAgain": "Jogar novamente",
        "game.restart": "Voc√™ realmente quer reiniciar o jogo?",
        "game.empty": "Vazio",
        "colors.red": "Vermelho",
        "colors.blue": "Azul",
        "colors.green": "Verde",
        "colors.yellow": "Amarelo",
        "settings.title": "Configura√ß√µes",
        "settings.background": "üé® Fundo",
        "settings.bg.default": "Padr√£o",
        "settings.bg.ocean": "Oceano",
        "settings.bg.sunset": "P√¥r do sol",
        "settings.bg.forest": "Floresta",
        "settings.bg.space": "Espa√ßo",
        "settings.bg.gradient": "Gradiente",
        "settings.close": "Pronto",
        "settings.version": "Vers√£o {0}",
        "language.auto": "Auto (Navegador)",
        "settings.computerSpeed": "ü§ñ Velocidade do Computador",
        "settings.speed.instant": "Instant√¢neo",
        "settings.speed.fast": "R√°pido",
        "settings.speed.normal": "Normal",
        "settings.speed.slow": "Lento",
        "skill.title": "üèÜ N√≠vel de Habilidade",
        "skill.level": "N√≠vel {0}",
        "skill.xp": "EXP: {0}/{1}",
        "skill.stats": "Estat√≠sticas",
        "skill.wins": "Vit√≥rias:",
        "skill.losses": "Derrotas:",
        "skill.winRate": "Taxa de Vit√≥ria:",
        "skill.avgCardsLeft": "M√©d. Cartas Restantes:",
        "skill.avgTurns": "M√©d. Turnos por Jogo:",
        "skill.totalGames": "Jogos Totais:",
        "skill.levelUp": "Subiu de N√≠vel! üéâ",
        "skill.newLevel": "Novo N√≠vel: {0}",
        "skill.reward": "Recompensa Desbloqueada: {0}",
        "skill.noob": "Novato",
        "skill.beginner": "Iniciante",
        "skill.amateur": "Amador",
        "skill.skilled": "Habilidoso",
        "skill.expert": "Especialista",
        "skill.master": "Mestre",
        "skill.legend": "Lenda",
        "skill.god": "Deus",
        "reward.theme": "Novo Tema",
        "reward.title": "Novo T√≠tulo",
        "reward.badge": "Novo Distintivo"
    },
    ja: {
        "game.title": "UNO",
        "start.playerCount": "„Ç≥„É≥„Éî„É•„Éº„Çø„ÉºÂØæÊà¶Áõ∏Êâã„ÅÆÊï∞:",
        "start.players2": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº1Âè∞",
        "start.players3": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº2Âè∞",
        "start.players4": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº3Âè∞",
        "start.difficulty": "Èõ£ÊòìÂ∫¶„ÇíÈÅ∏Êäû:",
        "difficulty.easy": "Á∞°Âçò",
        "difficulty.easyDesc": "ÂÆàÂÇôÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "difficulty.medium": "ÊôÆÈÄö",
        "difficulty.mediumDesc": "„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„Åü„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "difficulty.hard": "Èõ£„Åó„ÅÑ",
        "difficulty.hardDesc": "Êà¶Áï•ÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "start.rules": "„Ç≤„Éº„É†„É´„Éº„É´",
        "start.startGame": "„Ç≤„Éº„É†ÈñãÂßã",
        "game.yourTurn": "„ÅÇ„Å™„Åü„ÅÆÁï™",
        "game.computerTurn": "{0}„ÅÆÁï™",
        "game.drawCard": "„Ç´„Éº„Éâ„ÇíÂºï„Åè",
        "game.uno": "„Ç¶„Éé!",
        "game.currentColor": "ÁèæÂú®„ÅÆËâ≤:",
        "game.cards": "Êûö",
        "game.chooseColor": "Ëâ≤„ÇíÈÅ∏Êäû:",
        "game.computerChooses": "„Ç≥„É≥„Éî„É•„Éº„Çø„Éº„ÅåÈÅ∏Êäû: {0}",
        "game.unoCalled": "„Ç¶„ÉéÂÆ£Ë®Ä!",
        "game.computerCallsUno": "{0}„Åå„Ç¶„ÉéÂÆ£Ë®Ä!",
        "game.unoForgotten": "„Ç¶„ÉéÂøò„Çå! +2Êûö",
        "game.won": "ÂãùÂà©! üéâ",
        "game.lost": "ÊïóÂåó üòî",
        "game.wonText": "„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅÂãùÂà©„Åó„Åæ„Åó„ÅüÔºÅ",
        "game.lostText": "{0}„ÅåÂãùÂà©„Åó„Åæ„Åó„Åü„ÄÇÂÜçÊåëÊà¶„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ",
        "game.playAgain": "„ÇÇ„ÅÜ‰∏ÄÂ∫¶",
        "game.restart": "Êú¨ÂΩì„Å´„Ç≤„Éº„É†„ÇíÂÜçÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü",
        "game.empty": "Á©∫",
        "colors.red": "Ëµ§",
        "colors.blue": "Èùí",
        "colors.green": "Á∑ë",
        "colors.yellow": "ÈªÑ",
        "settings.title": "Ë®≠ÂÆö",
        "settings.background": "üé® ËÉåÊôØ",
        "settings.bg.default": "„Éá„Éï„Ç©„É´„Éà",
        "settings.bg.ocean": "Êµ∑",
        "settings.bg.sunset": "Â§ïÊó•",
        "settings.bg.forest": "Ê£Æ",
        "settings.bg.space": "ÂÆáÂÆô",
        "settings.bg.gradient": "„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥",
        "settings.close": "ÂÆå‰∫Ü",
        "settings.version": "„Éê„Éº„Ç∏„Éß„É≥ {0}",
        "language.auto": "Ëá™ÂãïÔºà„Éñ„É©„Ç¶„Ç∂Ôºâ",
        "settings.computerSpeed": "ü§ñ „Ç≥„É≥„Éî„É•„Éº„Çø„ÉºÈÄüÂ∫¶",
        "settings.speed.instant": "Âç≥Â∫ß",
        "settings.speed.fast": "ÈÄü„ÅÑ",
        "settings.speed.normal": "ÊôÆÈÄö",
        "settings.speed.slow": "ÈÅÖ„ÅÑ",
        "skill.title": "üèÜ „Çπ„Ç≠„É´„É¨„Éô„É´",
        "skill.level": "„É¨„Éô„É´ {0}",
        "skill.xp": "ÁµåÈ®ìÂÄ§: {0}/{1}",
        "skill.stats": "Áµ±Ë®à",
        "skill.wins": "ÂãùÂà©:",
        "skill.losses": "ÊïóÂåó:",
        "skill.winRate": "ÂãùÁéá:",
        "skill.avgCardsLeft": "Âπ≥ÂùáÊÆã„Çä„Ç´„Éº„Éâ:",
        "skill.avgTurns": "Âπ≥Âùá„Çø„Éº„É≥/„Ç≤„Éº„É†:",
        "skill.totalGames": "Á∑è„Ç≤„Éº„É†Êï∞:",
        "skill.levelUp": "„É¨„Éô„É´„Ç¢„ÉÉ„Éó! üéâ",
        "skill.newLevel": "Êñ∞„É¨„Éô„É´: {0}",
        "skill.reward": "Â†±ÈÖ¨Ëß£Èô§: {0}",
        "skill.noob": "ÂàùÂøÉËÄÖ",
        "skill.beginner": "„Éì„ÇÆ„Éä„Éº",
        "skill.amateur": "„Ç¢„Éû„ÉÅ„É•„Ç¢",
        "skill.skilled": "ÁÜüÁ∑¥ËÄÖ",
        "skill.expert": "„Ç®„Ç≠„Çπ„Éë„Éº„Éà",
        "skill.master": "„Éû„Çπ„Çø„Éº",
        "skill.legend": "„É¨„Ç∏„Çß„É≥„Éâ",
        "skill.god": "Á•û",
        "reward.theme": "Êñ∞„ÉÜ„Éº„Éû",
        "reward.title": "Êñ∞„Çø„Ç§„Éà„É´",
        "reward.badge": "Êñ∞„Éê„ÉÉ„Ç∏"
    },
    zh: {
        "game.title": "UNO",
        "start.playerCount": "ÁîµËÑëÂØπÊâãÊï∞Èáè:",
        "start.players2": "‰Ω† + 1Âè∞ÁîµËÑë",
        "start.players3": "‰Ω† + 2Âè∞ÁîµËÑë",
        "start.players4": "‰Ω† + 3Âè∞ÁîµËÑë",
        "start.difficulty": "ÈÄâÊã©ÈöæÂ∫¶:",
        "difficulty.easy": "ÁÆÄÂçï",
        "difficulty.easyDesc": "Èò≤ÂÆàÂûãÁîµËÑë",
        "difficulty.medium": "‰∏≠Á≠â",
        "difficulty.mediumDesc": "Âπ≥Ë°°ÂûãÁîµËÑë",
        "difficulty.hard": "Âõ∞Èöæ",
        "difficulty.hardDesc": "Á≠ñÁï•ÂûãÁîµËÑë",
        "start.rules": "Ê∏∏ÊàèËßÑÂàô",
        "start.startGame": "ÂºÄÂßãÊ∏∏Êàè",
        "game.yourTurn": "‰Ω†ÁöÑÂõûÂêà",
        "game.computerTurn": "{0}ÁöÑÂõûÂêà",
        "game.drawCard": "ÊäΩÁâå",
        "game.uno": "UNO!",
        "game.currentColor": "ÂΩìÂâçÈ¢úËâ≤:",
        "game.cards": "Âº†Áâå",
        "game.chooseColor": "ÈÄâÊã©È¢úËâ≤:",
        "game.computerChooses": "ÁîµËÑëÈÄâÊã©: {0}",
        "game.unoCalled": "UNOÂÆ£Âëä!",
        "game.computerCallsUno": "{0}ÂÆ£ÂëäUNO!",
        "game.unoForgotten": "ÂøòËÆ∞UNO! +2Âº†Áâå",
        "game.won": "ËÉúÂà©! üéâ",
        "game.lost": "Â§±Ë¥• üòî",
        "game.wonText": "ÊÅ≠ÂñúÔºÅ‰Ω†Ëµ¢Âæó‰∫ÜÊ∏∏ÊàèÔºÅ",
        "game.lostText": "{0}Ëé∑ËÉú‰∫Ü„ÄÇÂÜçËØï‰∏ÄÊ¨°ÔºÅ",
        "game.playAgain": "ÂÜçÁé©‰∏ÄÊ¨°",
        "game.restart": "ÁúüÁöÑË¶ÅÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÂêóÔºü",
        "game.empty": "Á©∫",
        "colors.red": "Á∫¢Ëâ≤",
        "colors.blue": "ËìùËâ≤",
        "colors.green": "ÁªøËâ≤",
        "colors.yellow": "ÈªÑËâ≤",
        "settings.title": "ËÆæÁΩÆ",
        "settings.background": "üé® ËÉåÊôØ",
        "settings.bg.default": "ÈªòËÆ§",
        "settings.bg.ocean": "Êµ∑Ê¥ã",
        "settings.bg.sunset": "Êó•ËêΩ",
        "settings.bg.forest": "Ê£ÆÊûó",
        "settings.bg.space": "Â§™Á©∫",
        "settings.bg.gradient": "Ê∏êÂèò",
        "settings.close": "ÂÆåÊàê",
        "settings.version": "ÁâàÊú¨ {0}",
        "language.auto": "Ëá™Âä®ÔºàÊµèËßàÂô®Ôºâ",
        "settings.computerSpeed": "ü§ñ ÁîµËÑëÈÄüÂ∫¶",
        "settings.speed.instant": "Áû¨Èó¥",
        "settings.speed.fast": "Âø´ÈÄü",
        "settings.speed.normal": "Ê≠£Â∏∏",
        "settings.speed.slow": "ÊÖ¢ÈÄü",
        "skill.title": "üèÜ ÊäÄËÉΩÁ≠âÁ∫ß",
        "skill.level": "Á≠âÁ∫ß {0}",
        "skill.xp": "ÁªèÈ™åÂÄº: {0}/{1}",
        "skill.stats": "ÁªüËÆ°",
        "skill.wins": "ËÉúÂà©:",
        "skill.losses": "Â§±Ë¥•:",
        "skill.winRate": "ËÉúÁéá:",
        "skill.avgCardsLeft": "Âπ≥ÂùáÂâ©‰ΩôÁâåÊï∞:",
        "skill.avgTurns": "Âπ≥ÂùáÂõûÂêàÊï∞/Ê∏∏Êàè:",
        "skill.totalGames": "ÊÄªÊ∏∏ÊàèÊï∞:",
        "skill.levelUp": "ÂçáÁ∫ß! üéâ",
        "skill.newLevel": "Êñ∞Á≠âÁ∫ß: {0}",
        "skill.reward": "Â•ñÂä±Ëß£ÈîÅ: {0}",
        "skill.noob": "ËèúÈ∏ü",
        "skill.beginner": "ÂàùÂ≠¶ËÄÖ",
        "skill.amateur": "‰∏ö‰Ωô",
        "skill.skilled": "ÁÜüÁªÉ",
        "skill.expert": "‰∏ìÂÆ∂",
        "skill.master": "Â§ßÂ∏à",
        "skill.legend": "‰º†Â•á",
        "skill.god": "Á•û",
        "reward.theme": "Êñ∞‰∏ªÈ¢ò",
        "reward.title": "Êñ∞Áß∞Âè∑",
        "reward.badge": "Êñ∞ÂæΩÁ´†"
    }
};

// UNO Game Implementation
class UnoGame {
    constructor() {
        this.colors = ['red', 'blue', 'green', 'yellow'];
        this.numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.actions = ['skip', 'reverse', 'draw-two'];
        this.wilds = ['wild', 'wild-draw-four'];
        
        // Lustige Computer-Namen nach Sprachen
        this.computerNamesByLanguage = {
            de: [
                'KartenKaiser', 'UnoUlrich', 'BlitzBerta', 'TurboTina', 'MegaMax',
                'FlitzerFritz', 'ZaubererZoe', 'RaketenRudi', 'SuperSusi', 'BlitzerBob',
                'GigaGerta', 'TurbineTom', 'FlashFiona', 'BoosterBruno', 'ZoomZara',
                'SpeediSepp', 'RaserRita', 'TurboTeddy', 'FlitzerFee', 'RocketRalf',
                'UnoUlla', 'KartenKurt', 'BlitzBrigitte', 'PowerPaul', 'MegaMaria',
                'TurboThomas', 'SpeedySandra', 'FlashFelix', 'ZoomZoe', 'RaketaRose',
                'SuperSchnecke', 'BlitzBirne', 'TurboTomate', 'FlitzerFisch', 'UnoUhu',
                'KartenKaktus', 'BlitzBanane', 'PowerPinguin', 'MegaMaulwurf', 'TurboTiger'
            ],
            en: [
                'CardKing', 'UnoUnicorn', 'FlashFred', 'TurboTom', 'MegaMax',
                'SpeedySpike', 'WizardWanda', 'RocketRob', 'SuperSam', 'BlitzBella',
                'GigaGrace', 'TurboTed', 'FlashFiona', 'BoosterBen', 'ZoomZoe',
                'QuickQuinn', 'RushRuby', 'TurboTerry', 'FlashFay', 'RocketRyan',
                'UnoUrsula', 'CardCarl', 'BlitzBrian', 'PowerPat', 'MegaMia',
                'TurboTracy', 'SpeedySarah', 'FlashFinn', 'ZoomZack', 'RocketRose',
                'SuperSnail', 'BlitzBerry', 'TurboTomato', 'FlashFish', 'UnoOwl',
                'CardCactus', 'BlitzBanana', 'PowerPenguin', 'MegaMole', 'TurboTiger'
            ],
            hu: [
                'K√°rtyaKir√°ly', 'UnoUnikorn', 'Vill√°mVilma', 'Turb√≥Tam√°s', 'MegaMarci',
                'Sebess√©giSzabi', 'Var√°zsl√≥Vera', 'Rak√©taR√≥bert', 'SzuperSzilvi', 'Vill√°mViktor',
                'GigaGabi', 'Turb√≥Tibor', 'Vill√°mVanda', 'Er≈ës√≠t≈ëErn≈ë', 'ZoomZolt√°n',
                'GyorsGerg≈ë', 'Rohamn√©Rita', 'Turb√≥T√ºnde', 'Vill√°mVivien', 'Rak√©taR√©ka',
                'Uno√örsula', 'K√°rtyaK√°lm√°n', 'Vill√°mViktor', 'Er≈ësErika', 'MegaM√≥nika',
                'Turb√≥Ter√©z', 'GyorsSzandra', 'Vill√°mFerenc', 'ZoomZsuzsa', 'Rak√©taR√≥zsa',
                'SzuperCsiga', 'Vill√°mBogy√≥', 'Turb√≥Paradicsom', 'Vill√°mHal', 'UnoBagoly',
                'K√°rtyaKaktusz', 'Vill√°mBan√°n', 'Er≈ësPingvin', 'MegaVakond', 'Turb√≥Tigris'
            ],
            ru: [
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Ä–æ–ª—å', '–£–Ω–æ–Æ–Ω–∏–∫–æ—Ä–Ω', '–ú–æ–ª–Ω–∏—è–ú–∞—à–∞', '–¢—É—Ä–±–æ–¢–æ–Ω—è', '–ú–µ–≥–∞–ú–∞–∫—Å',
                '–°–∫–æ—Ä–æ—Å—Ç–Ω–æ–π–°–µ—Ä–≥–µ–π', '–í–æ–ª—à–µ–±–Ω–∏–∫–í–µ—Ä–∞', '–†–∞–∫–µ—Ç–∞–†–æ–º–∞–Ω', '–°—É–ø–µ—Ä–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–ú–∏—à–∞',
                '–ì–∏–≥–∞–ì–∞–ª–∏–Ω–∞', '–¢—É—Ä–±–æ–¢–∏–º—É—Ä', '–ú–æ–ª–Ω–∏—è–í–∞–Ω–¥–∞', '–ë—É—Å—Ç–µ—Ä–ë–æ—Ä–∏—Å', '–ó—É–º–ó–æ—è',
                '–ë—ã—Å—Ç—Ä—ã–π–ë–æ—Ä–∏—Å', '–°–ø–µ—à–∫–∞–°–≤–µ—Ç–∞', '–¢—É—Ä–±–æ–¢–∞—Ç—å—è–Ω–∞', '–ú–æ–ª–Ω–∏—è–í–∏–∫—Ç–æ—Ä', '–†–∞–∫–µ—Ç–∞–†–∏—Ç–∞',
                '–£–Ω–æ–£–ª—å—è–Ω–∞', '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Å—Ç—è', '–ú–æ–ª–Ω–∏—è–ú–∞—Ä–∏–Ω–∞', '–°–∏–ª–∞–°–µ—Ä–≥–µ–π', '–ú–µ–≥–∞–ú–∞—Ä–∏—è',
                '–¢—É—Ä–±–æ–¢–∞–Ω—è', '–°–∫–æ—Ä—ã–π–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–§—ë–¥–æ—Ä', '–ó—É–º–ó–∏–Ω–∞–∏–¥–∞', '–†–∞–∫–µ—Ç–∞–†–æ–∑–∞',
                '–°—É–ø–µ—Ä–£–ª–∏—Ç–∫–∞', '–ú–æ–ª–Ω–∏—è–Ø–≥–æ–¥–∞', '–¢—É—Ä–±–æ–ü–æ–º–∏–¥–æ—Ä', '–ú–æ–ª–Ω–∏—è–†—ã–±–∞', '–£–Ω–æ–°–æ–≤–∞',
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–∞–∫—Ç—É—Å', '–ú–æ–ª–Ω–∏—è–ë–∞–Ω–∞–Ω', '–°–∏–ª—å–Ω—ã–π–ü–∏–Ω–≥–≤–∏–Ω', '–ú–µ–≥–∞–ö—Ä–æ—Ç', '–¢—É—Ä–±–æ–¢–∏–≥—Ä'
            ],
            es: [
                'ReyCartas', 'UnoUnicornio', 'Rel√°mpagoRosa', 'TurboTeo', 'MegaMax',
                'VelocidadVera', 'MagoMario', 'CoheteCarlos', 'SuperSofia', 'Rel√°mpagoRafa',
                'GigaGloria', 'TurboTom√°s', 'FlashFrancisca', 'BoosterBenji', 'ZoomZara',
                'R√°pidoRicardo', 'PrisaPatricia', 'TurboTere', 'FlashFelipe', 'CoheteClara',
                'UnoUrsula', 'CartasCarmen', 'Rel√°mpagoRoberto', 'PoderPablo', 'MegaMar√≠a',
                'TurboTania', 'VeloceSandra', 'FlashFernando', 'ZoomZoe', 'CoheteRosa',
                'SuperCaracol', 'Rel√°mpagoUva', 'TurboTomate', 'FlashPez', 'UnoB√∫ho',
                'CartasCactus', 'Rel√°mpagoPlatano', 'PoderPing√ºino', 'MegaTopo', 'TurboTigre'
            ],
            fr: [
                'RoiCartes', 'UnoLicorne', '√âclair√âmilie', 'TurboTh√©o', 'M√©gaMax',
                'VitesseVictor', 'MagicienMarcel', 'Fus√©eFran√ßoise', 'SuperSylvie', '√âclair√âric',
                'GigaGabrielle', 'TurboThomas', 'FlashFanny', 'BoosterBenjamin', 'ZoomZo√©',
                'RapideRaymond', 'PressePauline', 'TurboTh√©r√®se', 'FlashFabien', 'Fus√©eClaire',
                'UnoUrsule', 'CartesCl√©ment', '√âclairRen√©e', 'PouvoirPierre', 'M√©gaMarie',
                'TurboTanya', 'V√©loceSandra', 'FlashF√©lix', 'ZoomZacharie', 'Fus√©eRose',
                'SuperEscargot', '√âclairRaisin', 'TurboTomate', 'FlashPoisson', 'UnoHibou',
                'CartesCactus', '√âclairBanane', 'PouvoirPingouin', 'M√©gaTaupe', 'TurboTigre'
            ],
            pt: [
                'ReiCartas', 'UnoUnic√≥rnio', 'Rel√¢mpagoRita', 'TurboTiago', 'MegaMax',
                'VelocidadeVera', 'M√°gicoM√°rio', 'FogueteFelix', 'SuperS√¥nia', 'Rel√¢mpagoRafa',
                'GigaGisele', 'TurboTom√°s', 'FlashFernanda', 'BoosterBruno', 'ZoomZara',
                'R√°pidoRicardo', 'PressaPatr√≠cia', 'TurboTina', 'FlashF√°bio', 'FogueteClara',
                'Uno√örsula', 'CartasCarlos', 'Rel√¢mpagoRenata', 'PoderPaulo', 'MegaMaria',
                'TurboT√¢nia', 'VelozSandra', 'FlashFernando', 'ZoomZ√©', 'FogueteRosa',
                'SuperCaracol', 'Rel√¢mpagoUva', 'TurboTomate', 'FlashPeixe', 'UnoCoruja',
                'CartasCacto', 'Rel√¢mpagoBanana', 'PoderPinguim', 'MegaToupeira', 'TurboTigre'
            ],
            ja: [
                '„Ç´„Éº„Éâ„Ç≠„É≥„Ç∞', '„Ç¶„Éé„É¶„Éã„Ç≥„Éº„É≥', '„Ç§„Éä„Ç∫„Éû„Ç¢„Ç§', '„Çø„Éº„Éú„Çø„É≠„Ç¶', '„É°„Ç¨„Éû„ÉÉ„ÇØ„Çπ',
                '„Çπ„Éî„Éº„Éâ„Çµ„Éà„Ç∑', '„Éû„Ç∏„Ç∑„É£„É≥„Éü„Ç´', '„É≠„Ç±„ÉÉ„Éà„É™„Éß„Ç¶', '„Çπ„Éº„Éë„Éº„Çµ„Ç≠', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„É≠„Ç¶',
                '„ÇÆ„Ç¨„Ç¥„É≠„Ç¶', '„Çø„Éº„Éú„Çø„Ç´„Ç∑', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü', '„Éñ„Éº„Çπ„Çø„Éº„Éô„É≥', '„Ç∫„Éº„É†„Çæ„Ç®',
                '„ÇØ„Ç§„ÉÉ„ÇØ„Ç±„É≥„Ç∏', '„É©„ÉÉ„Ç∑„É•„É™„Ç´', '„Çø„Éº„Éú„ÉÜ„É´', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü„Ç™', '„É≠„Ç±„ÉÉ„Éà„É™„Éä',
                '„Ç¶„Éé„Ç¶„É©„É©', '„Ç´„Éº„Éâ„Ç±„É≥', '„Ç§„Éä„Ç∫„Éû„Ç§„Ç∫„Éü', '„Éë„ÉØ„Éº„Éù„É≥', '„É°„Ç¨„Éû„Éü',
                '„Çø„Éº„Éú„Çø„Éü', '„Çπ„Éî„Éº„Éá„Ç£„Çµ„ÉÅ', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç∏', '„Ç∫„Éº„É†„Çº„É≥', '„É≠„Ç±„ÉÉ„Éà„É≠„Éº„Ç∫',
                '„Çπ„Éº„Éë„Éº„Ç´„Çø„ÉÑ„É†„É™', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„Ç¥', '„Çø„Éº„Éú„Éà„Éû„Éà', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç£„ÉÉ„Ç∑„É•', '„Ç¶„Éé„Éï„ÇØ„É≠„Ç¶',
                '„Ç´„Éº„Éâ„Ç´„ÇØ„Çø„Çπ', '„Ç§„Éä„Ç∫„Éû„Éê„Éä„Éä', '„Éë„ÉØ„Éº„Éö„É≥„ÇÆ„É≥', '„É°„Ç¨„É¢„Ç∞„É©', '„Çø„Éº„Éú„Éà„É©'
            ],
            zh: [
                'Âç°Áâå‰πãÁéã', '‰πåËØ∫Áã¨ËßíÂÖΩ', 'Èó™Áîµ‰∏Ω‰∏Ω', 'Ê∂°ËΩÆÂ∞èÊòé', 'Ë∂ÖÁ∫ßÈ∫¶ÂÖãÊñØ',
                'ÈÄüÂ∫¶Â∞èËñá', 'È≠îÊ≥ïÂ∏àÈ©¨ÈáåÂ••', 'ÁÅ´ÁÆ≠Â∞èÈ£û', 'Ë∂ÖÁ∫ßÂ∞èËãè', 'Èó™ÁîµÂ∞èÂº∫',
                'ÂçÉÂÖÜÂ∞èÂàö', 'Ê∂°ËΩÆÂ∞èÊ∂õ', 'Èó™ÂÖâÂ∞èËä≥', 'Âä©Êé®Âô®Â∞èÊú¨', 'Áº©ÊîæÂ∞èÊüî',
                'Âø´ÈÄüÂ∞èÁëû', 'ÂåÜÂøôÂ∞è‰Ω©', 'Ê∂°ËΩÆÂ∞èÂ©∑', 'Èó™ÂÖâÂ∞èÈ£û', 'ÁÅ´ÁÆ≠Â∞èÂÖã',
                '‰πåËØ∫Â∞èÈõ®', 'Âç°ÁâåÂ∞èÈôà', 'Èó™ÁîµÂ∞èËïæ', 'ÂäõÈáèÂ∞è‰øù', 'Ë∂ÖÁ∫ßÂ∞èÁéõ',
                'Ê∂°ËΩÆÂ∞èË∞≠', 'Âø´ÈÄüÂ∞èÊ°ë', 'Èó™ÂÖâÂ∞èÂ≥∞', 'Áº©ÊîæÂ∞èÊ≥Ω', 'ÁÅ´ÁÆ≠Â∞èËî∑',
                'Ë∂ÖÁ∫ßËúóÁâõ', 'Èó™ÁîµËë°ËêÑ', 'Ê∂°ËΩÆÁï™ËåÑ', 'Èó™ÂÖâÂ∞èÈ±º', '‰πåËØ∫Áå´Â§¥Èπ∞',
                'Âç°Áâå‰ªô‰∫∫Êéå', 'Èó™ÁîµÈ¶ôËïâ', 'ÂäõÈáè‰ºÅÈπÖ', 'Ë∂ÖÁ∫ßÈºπÈº†', 'Ê∂°ËΩÆËÄÅËôé'
            ]
        };
        this.usedNames = [];  // Bereits verwendete Namen in diesem Spiel
        
        this.deck = [];
        this.players = []; // Array of all players (index 0 = human player)
        this.discardPile = [];
        this.currentColor = null;
        this.currentValue = null;
        this.currentPlayerIndex = 0; // Index of current player
        this.gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        this.difficulty = 'medium';
        this.playerCount = 2; // Total players (human + computers)
        
        this.calledUno = []; // Track UNO calls for each player
        this.gameInProgress = false; // Prevent multiple simultaneous actions
        this.currentLanguage = localStorage.getItem('unoLanguage') || this.detectBrowserLanguage();
        this.currentBackground = localStorage.getItem('unoBackground') || 'default';
        this.computerSpeed = localStorage.getItem('unoComputerSpeed') || 'normal';
        
        // Skill Analysis System
        this.playerStats = this.loadPlayerStats();
        this.currentGameStats = this.initializeGameStats();
        
        this.initializeElements();
        this.setupEventListeners();
        this.initializeLanguage();
        this.initializeBackground();
        this.initializeComputerSpeed();
        
        // Initialize skill display
        this.updateSkillDisplay();
    }
    
    initializeElements() {
        // Screen elements
        this.startScreen = document.getElementById('startScreen');
        this.gameScreen = document.getElementById('gameScreen');
        
        // Game elements
        this.playerCardsContainer = document.getElementById('playerCards');
        this.playersContainer = document.getElementById('playersContainer');
        this.discardPileElement = document.getElementById('discardPile');
        this.drawPileElement = document.getElementById('drawPile');
        
        // UI elements
        this.currentTurnElement = document.getElementById('currentTurn');
        this.colorDisplay = document.getElementById('colorDisplay');
        this.drawCardBtn = document.getElementById('drawCard');
        this.callUnoBtn = document.getElementById('callUno');
        
        // Modals
        this.colorModal = document.getElementById('colorModal');
        this.gameOverModal = document.getElementById('gameOverModal');
        this.rulesModal = document.getElementById('rulesModal');
        this.settingsModal = document.getElementById('settingsModal');
        
        // Start screen elements
        this.playerCountButtons = document.querySelectorAll('.player-count-btn');
        this.difficultyButtons = document.querySelectorAll('.difficulty-btn');
        this.startGameBtn = document.getElementById('startGame');
        
        // Game control elements
        this.restartBtn = document.getElementById('restartButton');
        this.rulesBtn = document.getElementById('rulesButton');
        this.rulesBtnGame = document.getElementById('rulesButtonGame');
        
        // Language elements
        this.languageToggle = document.getElementById('languageToggle');
        this.languageMenu = document.getElementById('languageMenu');
        this.languageOptions = document.querySelectorAll('.language-option');
        this.currentFlag = document.querySelector('.current-flag');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settingsButton');
        this.settingsBtnGame = document.getElementById('settingsButtonGame');
        this.backgroundOptions = document.querySelectorAll('.background-option');
        this.speedOptions = document.querySelectorAll('.speed-option');
        
        // Skill display elements
        this.skillDisplay = document.getElementById('skillDisplay');
        this.skillToggle = document.getElementById('skillToggle');
        this.skillContent = document.getElementById('skillContent');
        this.skillLevelText = document.getElementById('skillLevelText');
        this.skillLevelName = document.getElementById('skillLevelName');
        this.skillXP = document.getElementById('skillXP');
        this.xpProgress = document.getElementById('xpProgress');
        this.skillWins = document.getElementById('skillWins');
        this.skillLosses = document.getElementById('skillLosses');
        this.skillWinRate = document.getElementById('skillWinRate');
    }
    
    setupEventListeners() {
        // Player count selection
        this.playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.playerCountButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.playerCount = parseInt(btn.dataset.players);
                this.checkStartButtonEnabled();
            });
        });
        
        // Difficulty selection
        this.difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.difficultyButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = btn.dataset.difficulty;
                this.checkStartButtonEnabled();
            });
        });
        
        // Start game
        this.startGameBtn.addEventListener('click', () => {
            this.startGame();
        });
        
        // Game actions
        this.drawCardBtn.addEventListener('click', () => {
            this.drawCard(0);
        });
        
        this.callUnoBtn.addEventListener('click', () => {
            this.callUno(0);
        });
        
        // Color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectColor(btn.dataset.color);
            });
        });
        
        // Play again
        document.getElementById('playAgain').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Restart button
        this.restartBtn.addEventListener('click', () => {
            if (confirm('M√∂chtest du das Spiel wirklich neu starten?')) {
                this.resetGame();
            }
        });
        
        // Rules button (start screen)
        this.rulesBtn.addEventListener('click', () => {
            this.showRules();
        });
        
        // Rules button (in game)
        this.rulesBtnGame.addEventListener('click', () => {
            this.showRules();
        });
        
        // Close rules modal
        document.getElementById('closeRules').addEventListener('click', () => {
            this.hideRules();
        });
        
        document.getElementById('closeRulesBtn').addEventListener('click', () => {
            this.hideRules();
        });
        
        // Language dropdown
        this.languageToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleLanguageMenu();
        });
        
        this.languageOptions.forEach(option => {
            option.addEventListener('click', () => {
                const lang = option.dataset.lang;
                if (lang === 'auto') {
                    this.resetToAutoLanguage();
                } else {
                    this.switchLanguage(lang);
                }
                this.hideLanguageMenu();
            });
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            this.hideLanguageMenu();
        });
        
        // Settings
        this.settingsBtn.addEventListener('click', () => {
            this.showSettings();
        });
        
        this.settingsBtnGame.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            this.hideSettings();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.hideSettings();
        });
        
        // Background selection
        this.backgroundOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeBackground(option.dataset.bg);
            });
        });
        
        // Computer speed selection
        this.speedOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeComputerSpeed(option.dataset.speed);
            });
        });
        
        // Draw pile click
        this.drawPileElement.addEventListener('click', () => {
            if (this.currentPlayerIndex === 0 && this.deck.length > 0) {
                this.drawCard(0);
            }
        });
        
        // Skill display toggle
        this.skillToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleSkillDisplay();
        });
        
        // Skill header click to toggle
        document.querySelector('.skill-header').addEventListener('click', () => {
            this.toggleSkillDisplay();
        });
    }
    
    checkStartButtonEnabled() {
        const playerCountSelected = Array.from(this.playerCountButtons).some(btn => btn.classList.contains('selected'));
        const difficultySelected = Array.from(this.difficultyButtons).some(btn => btn.classList.contains('selected'));
        this.startGameBtn.disabled = !(playerCountSelected && difficultySelected);
    }
    
    getRandomComputerName() {
        // Hole die Namen f√ºr die aktuelle Sprache
        const computerNames = this.computerNamesByLanguage[this.currentLanguage] || this.computerNamesByLanguage['de'];
        
        // Wenn alle Namen verwendet wurden, leere die Liste
        if (this.usedNames.length >= computerNames.length) {
            this.usedNames = [];
        }
        
        // W√§hle einen Namen, der noch nicht verwendet wurde
        let availableNames = computerNames.filter(name => !this.usedNames.includes(name));
        const randomIndex = Math.floor(Math.random() * availableNames.length);
        const selectedName = availableNames[randomIndex];
        
        // Markiere den Namen als verwendet
        this.usedNames.push(selectedName);
        
        return selectedName;
    }
    
    createDeck() {
        this.deck = [];
        
        // Number cards (0-9) - 0 has 1 of each color, 1-9 have 2 of each color
        this.colors.forEach(color => {
            this.deck.push({ color, value: '0', type: 'number' });
            for (let i = 1; i <= 9; i++) {
                this.deck.push({ color, value: i.toString(), type: 'number' });
                this.deck.push({ color, value: i.toString(), type: 'number' });
            }
        });
        
        // Action cards (2 of each per color)
        this.colors.forEach(color => {
            this.actions.forEach(action => {
                this.deck.push({ color, value: action, type: 'action' });
                this.deck.push({ color, value: action, type: 'action' });
            });
        });
        
        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
            this.deck.push({ color: 'wild', value: 'wild', type: 'wild' });
            this.deck.push({ color: 'wild', value: 'wild-draw-four', type: 'wild' });
        }
        
        this.shuffleDeck();
    }
    
    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }
    
    dealInitialCards() {
        // Initialize players array
        this.players = [];
        this.calledUno = [];
        
        for (let i = 0; i < this.playerCount; i++) {
            this.players[i] = [];
            this.calledUno[i] = false;
        }
        
        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < this.playerCount; j++) {
                this.players[j].push(this.deck.pop());
            }
        }
        
        // Place first card on discard pile (cannot be wild or action card)
        let firstCard;
        do {
            firstCard = this.deck.pop();
        } while (firstCard.type === 'wild' || firstCard.type === 'action');
        
        this.discardPile = [firstCard];
        this.currentColor = firstCard.color;
        this.currentValue = firstCard.value;
    }
    
    startGame() {
        this.startScreen.classList.add('hidden');
        this.gameScreen.classList.remove('hidden');
        
        // Reset game stats for new game
        this.currentGameStats = this.initializeGameStats();
        
        this.createDeck();
        this.dealInitialCards();
        this.setupPlayersUI();
        this.currentPlayerIndex = 0;
        this.gameInProgress = true;
        this.updateUI();
        this.updateTurnDisplay();
        
        // Enable UNO button when human player has 2 cards
        this.updateUnoButton();
        
        // Update skill display
        this.updateSkillDisplay();
    }
    
    setupPlayersUI() {
        // Clear existing computer players
        this.playersContainer.innerHTML = '';
        
        // Reset used names for a new game
        this.usedNames = [];
        
        // Create computer player UI elements (skip index 0 = human player)
        for (let i = 1; i < this.playerCount; i++) {
            const computerName = this.getRandomComputerName();
            const playerDiv = document.createElement('div');
            playerDiv.className = 'computer-player';
            playerDiv.id = `player-${i}`;
            
            playerDiv.innerHTML = `
                <div class="player-info">
                    <h3>${computerName}</h3>
                    <div class="card-count">
                        <span id="cardCount-${i}">${this.players[i].length}</span>
                        <span class="cards-text">Karten</span>
                    </div>
                </div>
                <div class="computer-cards" id="computerCards-${i}">
                    <!-- Computer cards will be added here -->
                </div>
            `;
            
            this.playersContainer.appendChild(playerDiv);
            
            // Store the computer name for later use
            if (!this.computerPlayerNames) {
                this.computerPlayerNames = {};
            }
            this.computerPlayerNames[i] = computerName;
        }
    }
    
    resetGame() {
        this.gameInProgress = false; // Stop any ongoing actions
        this.gameOverModal.classList.add('hidden');
        this.gameScreen.classList.add('hidden');
        this.startScreen.classList.remove('hidden');
        
        // Reset game state
        this.calledUno = [];
        this.gameDirection = 1;
        this.currentPlayerIndex = 0;
        this.computerPlayerNames = {}; // Reset computer names
        this.usedNames = []; // Reset used names
        
        // Reset button states
        this.startGameBtn.disabled = true;
        this.playerCountButtons.forEach(btn => btn.classList.remove('selected'));
        this.difficultyButtons.forEach(btn => btn.classList.remove('selected'));
    }
    
    updateUI() {
        this.updatePlayerCards();
        this.updateComputerCards();
        this.updateDiscardPile();
        this.updateDrawPile();
        this.updateCardCounts();
        this.updateColorDisplay();
        this.updateActivePlayer();
    }
    
    updatePlayerCards() {
        this.playerCardsContainer.innerHTML = '';
        this.players[0].forEach((card, index) => {
            const cardElement = this.createCardElement(card, true);
            cardElement.addEventListener('click', () => {
                if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                    this.playCard(0, index);
                }
            });
            
            // Add playable highlight
            if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                cardElement.classList.add('playable');
            }
            
            this.playerCardsContainer.appendChild(cardElement);
        });
    }
    
    updateComputerCards() {
        for (let i = 1; i < this.playerCount; i++) {
            const computerCardsContainer = document.getElementById(`computerCards-${i}`);
            if (computerCardsContainer) {
                computerCardsContainer.innerHTML = '';
                this.players[i].forEach(() => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'computer-card';
                    computerCardsContainer.appendChild(cardElement);
                });
            }
        }
    }
    
    updateDiscardPile() {
        const topCard = this.discardPile[this.discardPile.length - 1];
        this.discardPileElement.innerHTML = '';
        const cardElement = this.createCardElement(topCard, true);
        this.discardPileElement.appendChild(cardElement);
    }
    
    updateDrawPile() {
        this.drawPileElement.innerHTML = '';
        
        if (this.deck.length > 0) {
            // Show card back when cards are available
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            this.drawPileElement.appendChild(cardBack);
            
            // Enable draw button
            this.drawCardBtn.disabled = false;
            this.drawPileElement.style.cursor = 'pointer';
        } else {
            // Show empty state when no cards left
            const emptyPile = document.createElement('div');
            emptyPile.className = 'empty-pile';
            emptyPile.innerHTML = '<span>Leer</span>';
            this.drawPileElement.appendChild(emptyPile);
            
            // Disable draw button and pile
            this.drawCardBtn.disabled = true;
            this.drawPileElement.style.cursor = 'not-allowed';
        }
    }
    
    updateCardCounts() {
        // Update card counts for all computer players
        for (let i = 1; i < this.playerCount; i++) {
            const cardCountElement = document.getElementById(`cardCount-${i}`);
            if (cardCountElement) {
                cardCountElement.textContent = this.players[i].length;
            }
        }
    }
    
    updateActivePlayer() {
        // Remove active class from all players
        for (let i = 1; i < this.playerCount; i++) {
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                playerElement.classList.remove('active');
            }
        }
        
        // Add active class to current player (if computer)
        if (this.currentPlayerIndex > 0) {
            const activePlayerElement = document.getElementById(`player-${this.currentPlayerIndex}`);
            if (activePlayerElement) {
                activePlayerElement.classList.add('active');
            }
        }
    }
    
    updateColorDisplay() {
        // Remove all color classes
        this.colorDisplay.className = 'color-display';
        
        // Add current color class
        if (this.currentColor && this.currentColor !== 'wild') {
            this.colorDisplay.classList.add(this.currentColor);
        }
    }
    
    updateTurnDisplay() {
        if (this.currentPlayerIndex === 0) {
            this.currentTurnElement.textContent = this.t('game.yourTurn');
            this.currentTurnElement.style.background = 'rgba(76, 175, 80, 0.9)';
        } else {
            const computerName = this.computerPlayerNames && this.computerPlayerNames[this.currentPlayerIndex] 
                ? this.computerPlayerNames[this.currentPlayerIndex] 
                : `Computer ${this.currentPlayerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerTurn', computerName);
            this.currentTurnElement.style.background = 'rgba(244, 67, 54, 0.9)';
        }
    }
    
    updateUnoButton() {
        // Enable UNO button when human player has exactly 2 cards and hasn't called UNO yet
        this.callUnoBtn.disabled = !(this.players[0].length === 2 && !this.calledUno[0]);
    }
    
    createCardElement(card, showFace = true) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.color}`;
        
        if (showFace) {
            if (card.type === 'number') {
                cardElement.innerHTML = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                const actionText = {
                    'skip': 'STOP',
                    'reverse': '‚ü≤',
                    'draw-two': '+2'
                };
                cardElement.innerHTML = `<span class="card-value">${actionText[card.value]}</span>`;
            } else if (card.type === 'wild') {
                const wildText = card.value === 'wild' ? 'WILD' : '+4';
                cardElement.innerHTML = `<span class="card-value">${wildText}</span>`;
            }
        }
        
        return cardElement;
    }
    
    canPlayCard(card) {
        // Wild cards can always be played
        if (card.type === 'wild') {
            return true;
        }
        
        // Regular cards must match color or value
        return card.color === this.currentColor || card.value === this.currentValue;
    }
    
    playCard(playerIndex, cardIndex) {
        const hand = this.players[playerIndex];
        const card = hand[cardIndex];
        
        // Track player stats
        if (playerIndex === 0) {
            this.currentGameStats.playerTurns++;
            if (card.type === 'action' || card.type === 'wild') {
                this.currentGameStats.specialCardsPlayed++;
            }
        }
        
        if (!this.canPlayCard(card)) {
            return false;
        }
        
        // Remove card from hand and add to discard pile
        hand.splice(cardIndex, 1);
        this.discardPile.push(card);
        
        // Add playing animation
        if (playerIndex === 0) {
            const cardElements = this.playerCardsContainer.children;
            if (cardElements[cardIndex]) {
                cardElements[cardIndex].classList.add('playing');
            }
        }
        
        // Handle card effects
        this.handleCardEffect(card);
        
        // Update current color and value
        if (card.type === 'wild') {
            if (playerIndex === 0) {
                this.showColorSelector();
                return true; // Color selector will handle turn switching
            } else {
                // Computer chooses color
                this.currentColor = this.chooseColorForComputer();
                this.showComputerColorChoice();
                // Continue to handle card effects below
            }
        } else {
            this.currentColor = card.color;
        }
        this.currentValue = card.value;
        
        // Check for win condition
        if (hand.length === 0) {
            this.endGame(playerIndex);
            return true;
        }
        
        // Check UNO call requirement
        if (hand.length === 1) {
            if (playerIndex === 0 && !this.calledUno[0]) {
                // Player forgot to call UNO - penalty
                this.penalizePlayer(0);
            } else if (playerIndex > 0 && !this.calledUno[playerIndex]) {
                // Computer calls UNO automatically
                this.callUno(playerIndex);
            }
        }
        
        // Update UI
        this.updateUI();
        this.updateUnoButton();
        
        // Switch turns (card effects handle their own turn logic)
        if (card.value === 'skip' || card.value === 'reverse' || 
            card.value === 'draw-two' || card.value === 'wild-draw-four' || 
            card.value === 'wild') {
            // Action cards and wild cards handle their own turn switching
            return true;
        } else {
            // Regular number cards
            this.switchTurns();
        }
        
        return true;
    }
    
    handleCardEffect(card) {
        switch (card.value) {
            case 'skip':
                // Skip next player's turn - switch twice to skip them
                this.switchTurns(); // Go to next player
                this.switchTurns(); // Skip that player
                break;
                
            case 'reverse':
                this.gameDirection *= -1;
                // In 2-player game, reverse acts like skip
                if (this.playerCount === 2) {
                    this.switchTurns(); // Go to next player
                    this.switchTurns(); // Skip that player (reverse effect)
                } else {
                    this.switchTurns(); // Just change direction
                }
                break;
                
            case 'draw-two':
                const drawTwoTarget = this.getNextPlayerIndex();
                this.drawCards(drawTwoTarget, 2);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild-draw-four':
                const drawFourTarget = this.getNextPlayerIndex();
                this.drawCards(drawFourTarget, 4);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild':
                // Regular wild card - just switch turns normally
                this.switchTurns();
                break;
        }
    }
    
    drawCard(playerIndex) {
        if (this.deck.length === 0) {
            this.reshuffleDeck();
        }
        
        // Track player stats
        if (playerIndex === 0) {
            this.currentGameStats.cardsDrawn++;
        }
        
        // Check if we still have no cards after reshuffling (shouldn't happen normally)
        if (this.deck.length === 0) {
            console.warn('No cards available to draw!');
            return;
        }
        
        const card = this.deck.pop();
        this.players[playerIndex].push(card);
        
        this.updateUI();
        this.updateUnoButton();
        
        // Reset UNO call status when drawing cards
        this.calledUno[playerIndex] = false;
        
        // After drawing, human player auto-ends turn, computer continues
        if (playerIndex === 0 && this.currentPlayerIndex === 0) {
            // Auto-end human turn after drawing
            setTimeout(() => {
                if (this.currentPlayerIndex === 0) { // Double-check we're still on human turn
                    this.switchTurns();
                }
            }, 1000);
        }
    }
    
    drawCards(playerIndex, count) {
        for (let i = 0; i < count; i++) {
            this.drawCard(playerIndex);
        }
    }
    
    reshuffleDeck() {
        // Keep top card of discard pile, shuffle the rest back into deck
        const topCard = this.discardPile.pop();
        this.deck = [...this.discardPile];
        this.discardPile = [topCard];
        this.shuffleDeck();
    }
    
    getNextPlayerIndex() {
        let nextIndex = this.currentPlayerIndex + this.gameDirection;
        if (nextIndex >= this.playerCount) {
            nextIndex = 0;
        } else if (nextIndex < 0) {
            nextIndex = this.playerCount - 1;
        }
        return nextIndex;
    }
    
    switchTurns() {
        if (!this.gameInProgress) {
            return; // Game ended, don't continue
        }
        
        this.currentPlayerIndex = this.getNextPlayerIndex();
        this.updateTurnDisplay();
        this.updateUI();
        
        if (this.currentPlayerIndex > 0) {
            // Computer's turn
            const delay = this.getComputerTurnDelay();
            setTimeout(() => {
                if (this.gameInProgress && this.currentPlayerIndex > 0) {
                    this.computerPlay();
                }
            }, delay);
        }
    }
    
    computerPlay() {
        // Safety check - make sure it's actually a computer's turn
        if (this.currentPlayerIndex === 0) {
            console.warn('computerPlay called but it\'s human player\'s turn!');
            return;
        }
        
        const playerIndex = this.currentPlayerIndex;
        const playableCards = this.players[playerIndex]
            .map((card, index) => ({ card, index }))
            .filter(({ card }) => this.canPlayCard(card));
        
        if (playableCards.length > 0) {
            const chosenCard = this.chooseCardForComputer(playableCards, playerIndex);
            this.playCard(playerIndex, chosenCard.index);
        } else {
            // Must draw a card
            this.drawCard(playerIndex);
            // Only switch turns if we're still at the same player (draw didn't trigger other effects)
            if (this.currentPlayerIndex === playerIndex) {
                this.switchTurns();
            }
        }
    }
    
    chooseCardForComputer(playableCards, playerIndex) {
        switch (this.difficulty) {
            case 'easy':
                return this.chooseCardEasy(playableCards, playerIndex);
            case 'medium':
                return this.chooseCardMedium(playableCards, playerIndex);
            case 'hard':
                return this.chooseCardHard(playableCards, playerIndex);
            default:
                return playableCards[0];
        }
    }
    
    chooseCardEasy(playableCards, playerIndex) {
        // Easy: Random selection, prefers regular cards over action cards
        const regularCards = playableCards.filter(({ card }) => card.type === 'number');
        const actionCards = playableCards.filter(({ card }) => card.type === 'action');
        const wildCards = playableCards.filter(({ card }) => card.type === 'wild');
        
        if (regularCards.length > 0 && Math.random() < 0.7) {
            return regularCards[Math.floor(Math.random() * regularCards.length)];
        } else if (actionCards.length > 0 && Math.random() < 0.6) {
            return actionCards[Math.floor(Math.random() * actionCards.length)];
        } else if (wildCards.length > 0) {
            return wildCards[Math.floor(Math.random() * wildCards.length)];
        }
        
        return playableCards[Math.floor(Math.random() * playableCards.length)];
    }
    
    chooseCardMedium(playableCards, playerIndex) {
        // Medium: Balanced strategy, considers card effects
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Check if human player has few cards
        const humanPlayerLowCards = this.players[0].length <= 3;
        
        // Prefer action cards when advantageous
        if (actionCards.length > 0 && humanPlayerLowCards) {
            const preferredActions = actionCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'skip'
            );
            if (preferredActions.length > 0) {
                return preferredActions[0];
            }
        }
        
        // Use wild cards strategically
        if (wildCards.length > 0 && this.players[playerIndex].length <= 2) {
            return wildCards[0];
        }
        
        // Otherwise prefer regular cards
        if (regularCards.length > 0) {
            return regularCards[0];
        }
        
        return playableCards[0];
    }
    
    chooseCardHard(playableCards, playerIndex) {
        // Hard: Advanced strategy, considers multiple factors
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Aggressive play when human player has few cards
        if (this.players[0].length <= 2) {
            const drawCards = playableCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'wild-draw-four'
            );
            if (drawCards.length > 0) {
                // Prefer wild-draw-four over draw-two
                const wildDrawFour = drawCards.find(({ card }) => card.value === 'wild-draw-four');
                return wildDrawFour || drawCards[0];
            }
            
            // Skip player's turn
            const skipCards = actionCards.filter(({ card }) => card.value === 'skip');
            if (skipCards.length > 0) {
                return skipCards[0];
            }
        }
        
        // Color management strategy
        const colorCounts = this.countColorsByFrequency(playerIndex);
        const bestColorCards = regularCards.filter(({ card }) => 
            card.color === colorCounts[0]?.color
        );
        
        if (bestColorCards.length > 0) {
            return bestColorCards[0];
        }
        
        // Save wild cards for last resort unless hand is small
        if (this.players[playerIndex].length <= 3 && wildCards.length > 0) {
            return wildCards[0];
        }
        
        // Default to first available card
        return regularCards[0] || actionCards[0] || wildCards[0] || playableCards[0];
    }
    
    categorizeCards(playableCards) {
        return {
            regularCards: playableCards.filter(({ card }) => card.type === 'number'),
            actionCards: playableCards.filter(({ card }) => card.type === 'action'),
            wildCards: playableCards.filter(({ card }) => card.type === 'wild')
        };
    }
    
    countColorsByFrequency(playerIndex) {
        const colorCounts = {};
        this.players[playerIndex].forEach(card => {
            if (card.color !== 'wild') {
                colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
        });
        
        return Object.entries(colorCounts)
            .map(([color, count]) => ({ color, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    chooseColorForComputer() {
        const colorCounts = this.countColorsByFrequency();
        return colorCounts.length > 0 ? colorCounts[0].color : this.colors[Math.floor(Math.random() * this.colors.length)];
    }
    
    showColorSelector() {
        this.colorModal.classList.remove('hidden');
    }
    
    selectColor(color) {
        this.currentColor = color;
        this.colorModal.classList.add('hidden');
        this.updateUI();
        this.switchTurns();
    }
    
    showComputerColorChoice() {
        // Show feedback about computer's color choice
        const colorNames = {
            'red': 'Rot',
            'blue': 'Blau', 
            'green': 'Gr√ºn',
            'yellow': 'Gelb'
        };
        
        const colorName = colorNames[this.currentColor];
        const originalText = this.currentTurnElement.textContent;
        
        this.currentTurnElement.textContent = `Computer w√§hlt: ${colorName}`;
        this.currentTurnElement.style.background = 'rgba(255, 193, 7, 0.9)';
        
        setTimeout(() => {
            this.updateTurnDisplay();
        }, 2000);
    }
    
    callUno(playerIndex) {
        this.calledUno[playerIndex] = true;
        
        // Track UNO call for player
        if (playerIndex === 0) {
            this.currentGameStats.unoCalledCorrectly = true;
        }
        
        if (playerIndex === 0) {
            this.callUnoBtn.disabled = true;
            
            // Show feedback
            this.currentTurnElement.textContent = this.t('game.unoCalled');
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        } else {
            // Show computer UNO call
            const computerName = this.computerPlayerNames && this.computerPlayerNames[playerIndex] 
                ? this.computerPlayerNames[playerIndex] 
                : `Computer ${playerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerCallsUno', computerName);
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        }
    }
    
    penalizePlayer(playerIndex) {
        // Draw 2 penalty cards for not calling UNO
        this.drawCards(playerIndex, 2);
        
        // Track UNO forgotten for player
        if (playerIndex === 0) {
            this.currentGameStats.unoForgotten = true;
        }
        
        if (playerIndex === 0) {
            this.currentTurnElement.textContent = 'UNO vergessen! +2 Karten';
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 2000);
        }
    }
    
    endGame(winnerIndex) {
        this.gameInProgress = false; // Stop all game actions
        
        const gameResult = document.getElementById('gameResult');
        const gameResultText = document.getElementById('gameResultText');
        
        if (winnerIndex === 0) {
            gameResult.textContent = this.t('game.won');
            gameResult.style.color = '#4caf50';
            gameResultText.textContent = this.t('game.wonText');
        } else {
            gameResult.textContent = this.t('game.lost');
            gameResult.style.color = '#f44336';
            const computerName = this.computerPlayerNames && this.computerPlayerNames[winnerIndex] 
                ? this.computerPlayerNames[winnerIndex] 
                : `Computer ${winnerIndex}`;
            gameResultText.textContent = this.t('game.lostText', computerName);
        }
        
        // Analyze game for skill system
        this.analyzeGamePerformance(winnerIndex);
        
        this.gameOverModal.classList.remove('hidden');
    }

    // ===== SKILL ANALYSIS SYSTEM =====
    
    loadPlayerStats() {
        const defaultStats = {
            level: 1,
            xp: 0,
            totalGames: 0,
            wins: 0,
            losses: 0,
            totalCardsLeft: 0,
            totalTurns: 0,
            bestWinStreak: 0,
            currentWinStreak: 0,
            unoCallsSuccessful: 0,
            unoCallsMissed: 0,
            gamesWonByDifficulty: { easy: 0, medium: 0, hard: 0 },
            achievements: [],
            unlockedRewards: []
        };
        
        const savedStats = localStorage.getItem('unoPlayerStats');
        if (savedStats) {
            try {
                return { ...defaultStats, ...JSON.parse(savedStats) };
            } catch (e) {
                console.warn('Failed to load player stats, using defaults');
                return defaultStats;
            }
        }
        return defaultStats;
    }

    savePlayerStats() {
        localStorage.setItem('unoPlayerStats', JSON.stringify(this.playerStats));
    }

    initializeGameStats() {
        return {
            startTime: Date.now(),
            playerTurns: 0,
            cardsDrawn: 0,
            unoCalledCorrectly: false,
            unoForgotten: false,
            specialCardsPlayed: 0,
            difficulty: this.difficulty,
            opponents: this.playerCount - 1
        };
    }

    analyzeGamePerformance(winnerIndex) {
        // Finalize current game stats
        this.currentGameStats.endTime = Date.now();
        this.currentGameStats.duration = this.currentGameStats.endTime - this.currentGameStats.startTime;
        this.currentGameStats.cardsLeftInHand = this.players[0].length; // Human player's cards
        
        const isWin = winnerIndex === 0;
        
        // Update basic stats
        this.playerStats.totalGames++;
        if (isWin) {
            this.playerStats.wins++;
            this.playerStats.currentWinStreak++;
            this.playerStats.gamesWonByDifficulty[this.difficulty]++;
            if (this.playerStats.currentWinStreak > this.playerStats.bestWinStreak) {
                this.playerStats.bestWinStreak = this.playerStats.currentWinStreak;
            }
        } else {
            this.playerStats.losses++;
            this.playerStats.currentWinStreak = 0;
        }
        
        // Update cumulative stats
        this.playerStats.totalCardsLeft += this.currentGameStats.cardsLeftInHand;
        this.playerStats.totalTurns += this.currentGameStats.playerTurns;
        
        // UNO call tracking
        if (this.currentGameStats.unoCalledCorrectly) {
            this.playerStats.unoCallsSuccessful++;
        }
        if (this.currentGameStats.unoForgotten) {
            this.playerStats.unoCallsMissed++;
        }
        
        // Calculate XP gained
        const xpGained = this.calculateXPGain(isWin);
        const oldLevel = this.playerStats.level;
        this.playerStats.xp += xpGained;
        
        // Check for level up
        const newLevel = this.calculateLevel(this.playerStats.xp);
        if (newLevel > oldLevel) {
            this.playerStats.level = newLevel;
            this.handleLevelUp(oldLevel, newLevel);
        }
        
        // Check for achievements
        this.checkAchievements();
        
        // Save updated stats
        this.savePlayerStats();
        
        // Update UI
        this.updateSkillDisplay();
    }

    calculateXPGain(isWin) {
        let baseXP = isWin ? 100 : 25;
        
        // Bonus for difficulty
        const difficultyMultiplier = { easy: 1.0, medium: 1.5, hard: 2.0 };
        baseXP *= difficultyMultiplier[this.difficulty];
        
        // Bonus for fewer cards left
        if (isWin) {
            const cardsLeftBonus = Math.max(0, 10 - this.currentGameStats.cardsLeftInHand) * 5;
            baseXP += cardsLeftBonus;
        }
        
        // Bonus for UNO call
        if (this.currentGameStats.unoCalledCorrectly) {
            baseXP += 20;
        }
        
        // Penalty for UNO forgotten
        if (this.currentGameStats.unoForgotten) {
            baseXP -= 10;
        }
        
        // Bonus for winning streak
        if (isWin && this.playerStats.currentWinStreak >= 3) {
            baseXP += Math.min(50, this.playerStats.currentWinStreak * 5);
        }
        
        return Math.max(10, Math.floor(baseXP)); // Minimum 10 XP
    }

    calculateLevel(xp) {
        // Progressive XP requirements: Level n requires (n-1) * 500 + 1000 XP
        let level = 1;
        let totalXPRequired = 0;
        
        while (true) {
            const xpForNextLevel = level * 500 + 500; // Level 1->2: 1000, 2->3: 1500, etc.
            if (xp < totalXPRequired + xpForNextLevel) {
                break;
            }
            totalXPRequired += xpForNextLevel;
            level++;
        }
        
        return level;
    }

    getXPForCurrentLevel() {
        const currentLevel = this.playerStats.level;
        let totalXPForPreviousLevels = 0;
        
        for (let i = 1; i < currentLevel; i++) {
            totalXPForPreviousLevels += i * 500 + 500;
        }
        
        return this.playerStats.xp - totalXPForPreviousLevels;
    }

    getXPRequiredForNextLevel() {
        return this.playerStats.level * 500 + 500;
    }

    getSkillLevelName(level) {
        if (level >= 25) return this.t('skill.god');
        if (level >= 20) return this.t('skill.legend');
        if (level >= 15) return this.t('skill.master');
        if (level >= 12) return this.t('skill.expert');
        if (level >= 8) return this.t('skill.skilled');
        if (level >= 5) return this.t('skill.amateur');
        if (level >= 3) return this.t('skill.beginner');
        return this.t('skill.noob');
    }

    handleLevelUp(oldLevel, newLevel) {
        // Show level up notification
        setTimeout(() => {
            this.showLevelUpNotification(oldLevel, newLevel);
        }, 2000); // Show after game over modal
        
        // Check for rewards at new level
        const reward = this.getRewardForLevel(newLevel);
        if (reward && !this.playerStats.unlockedRewards.includes(reward.id)) {
            this.playerStats.unlockedRewards.push(reward.id);
            setTimeout(() => {
                this.showRewardNotification(reward);
            }, 4000);
        }
    }

    getRewardForLevel(level) {
        const rewards = {
            3: { id: 'theme_sunset_unlock', type: 'theme', name: 'Sunset Theme' },
            5: { id: 'title_amateur', type: 'title', name: 'Amateur' },
            8: { id: 'theme_forest_unlock', type: 'theme', name: 'Forest Theme' },
            10: { id: 'title_skilled', type: 'title', name: 'Skilled Player' },
            12: { id: 'theme_space_unlock', type: 'theme', name: 'Space Theme' },
            15: { id: 'title_master', type: 'title', name: 'UNO Master' },
            20: { id: 'theme_legendary', type: 'theme', name: 'Legendary Theme' },
            25: { id: 'title_god', type: 'title', name: 'UNO God' }
        };
        
        return rewards[level] || null;
    }

    checkAchievements() {
        const achievements = [];
        
        // Win streak achievements
        if (this.playerStats.currentWinStreak >= 5 && !this.playerStats.achievements.includes('win_streak_5')) {
            achievements.push({ id: 'win_streak_5', name: 'Win Streak Master', description: 'Win 5 games in a row' });
        }
        
        // Game count achievements
        if (this.playerStats.totalGames >= 10 && !this.playerStats.achievements.includes('games_10')) {
            achievements.push({ id: 'games_10', name: 'Dedicated Player', description: 'Play 10 games' });
        }
        
        if (this.playerStats.totalGames >= 50 && !this.playerStats.achievements.includes('games_50')) {
            achievements.push({ id: 'games_50', name: 'UNO Enthusiast', description: 'Play 50 games' });
        }
        
        // Difficulty achievements
        if (this.playerStats.gamesWonByDifficulty.hard >= 5 && !this.playerStats.achievements.includes('hard_winner')) {
            achievements.push({ id: 'hard_winner', name: 'Hard Mode Conqueror', description: 'Win 5 games on hard difficulty' });
        }
        
        // UNO call achievements
        if (this.playerStats.unoCallsSuccessful >= 10 && !this.playerStats.achievements.includes('uno_master')) {
            achievements.push({ id: 'uno_master', name: 'UNO Call Master', description: 'Successfully call UNO 10 times' });
        }
        
        // Add new achievements
        achievements.forEach(achievement => {
            if (!this.playerStats.achievements.includes(achievement.id)) {
                this.playerStats.achievements.push(achievement.id);
                setTimeout(() => {
                    this.showAchievementNotification(achievement);
                }, Math.random() * 3000 + 5000);
            }
        });
    }

    showLevelUpNotification(oldLevel, newLevel) {
        const notification = document.createElement('div');
        notification.className = 'skill-notification level-up';
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            z-index: 10001;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            min-width: 300px;
            animation: levelUpAnimation 0.5s ease-out;
        `;
        
        const levelName = this.getSkillLevelName(newLevel);
        notification.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 10px;">üéâ</div>
            <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">${this.t('skill.levelUp')}</div>
            <div style="font-size: 16px; margin-bottom: 10px;">${this.t('skill.newLevel', newLevel)}</div>
            <div style="font-size: 14px; opacity: 0.9;">${levelName}</div>
        `;
        
        // Add animation keyframes if not already added
        if (!document.querySelector('#levelUpKeyframes')) {
            const style = document.createElement('style');
            style.id = 'levelUpKeyframes';
            style.textContent = `
                @keyframes levelUpAnimation {
                    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    showRewardNotification(reward) {
        const notification = document.createElement('div');
        notification.className = 'skill-notification reward';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 10000;
            font-family: 'Poppins', sans-serif;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            max-width: 300px;
        `;
        
        notification.innerHTML = `
            <div style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">üèÜ ${this.t('skill.reward', reward.name)}</div>
            <div style="font-size: 14px; opacity: 0.9;">${this.t(`reward.${reward.type}`)}</div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 4000);
    }

    showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'skill-notification achievement';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 10000;
            font-family: 'Poppins', sans-serif;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            max-width: 300px;
        `;
        
        notification.innerHTML = `
            <div style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">üèÖ ${achievement.name}</div>
            <div style="font-size: 14px; opacity: 0.9;">${achievement.description}</div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        setTimeout(() => {
            notification.style.transform = 'translateX(-100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 5000);
    }

    toggleSkillDisplay() {
        const isCollapsed = this.skillContent.classList.toggle('collapsed');
        this.skillToggle.classList.toggle('collapsed', isCollapsed);
        this.skillToggle.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
    }

    updateSkillDisplay() {
        if (!this.skillDisplay) return;
        
        const stats = this.playerStats;
        const level = stats.level;
        const levelName = this.getSkillLevelName(level);
        const winRate = stats.totalGames > 0 ? Math.round((stats.wins / stats.totalGames) * 100) : 0;
        
        // Update level display
        this.skillLevelText.textContent = this.t('skill.level', level);
        this.skillLevelName.textContent = levelName;
        
        // Update XP display
        const currentXP = this.getXPForCurrentLevel();
        const requiredXP = this.getXPRequiredForNextLevel();
        const xpProgress = (currentXP / requiredXP) * 100;
        
        this.skillXP.textContent = this.t('skill.xp', currentXP, requiredXP);
        this.xpProgress.style.width = `${Math.min(xpProgress, 100)}%`;
        
        // Update stats
        this.skillWins.textContent = stats.wins;
        this.skillLosses.textContent = stats.losses;
        this.skillWinRate.textContent = `${winRate}%`;
        
        // Update skill level name color based on level
        this.updateSkillLevelColor(level);
    }

    updateSkillLevelColor(level) {
        const colors = {
            1: '#9e9e9e',    // Noob - gray
            3: '#8bc34a',    // Beginner - light green
            5: '#4caf50',    // Amateur - green
            8: '#2196f3',    // Skilled - blue
            12: '#9c27b0',   // Expert - purple
            15: '#ff9800',   // Master - orange
            20: '#ff5722',   // Legend - red
            25: '#ffd700'    // God - gold
        };
        
        let color = '#9e9e9e'; // default
        for (let levelThreshold of Object.keys(colors).reverse()) {
            if (level >= parseInt(levelThreshold)) {
                color = colors[levelThreshold];
                break;
            }
        }
        
        this.skillLevelName.style.background = color;
        this.skillLevelName.style.color = level >= 20 ? '#000' : '#fff';
    }

    // ===== COMPUTER SPEED SETTINGS =====
    
    getComputerTurnDelay() {
        const speedDelays = {
            'instant': 100,    // Almost instant (just enough for visual feedback)
            'fast': 800,       // Fast
            'normal': 1500,    // Normal (original speed)
            'slow': 3000       // Slow for beginners
        };
        return speedDelays[this.computerSpeed] || speedDelays['normal'];
    }

    changeComputerSpeed(speed) {
        // Update active speed option in UI
        this.speedOptions.forEach(option => {
            option.classList.remove('active');
            if (option.dataset.speed === speed) {
                option.classList.add('active');
            }
        });

        // Save the setting
        this.computerSpeed = speed;
        localStorage.setItem('unoComputerSpeed', speed);
    }

    initializeComputerSpeed() {
        // Set the active speed option based on saved setting
        this.speedOptions.forEach(option => {
            option.classList.remove('active');
            if (option.dataset.speed === this.computerSpeed) {
                option.classList.add('active');
            }
        });
    }
    
    showRules() {
        this.rulesModal.classList.remove('hidden');
    }
    
    hideRules() {
        this.rulesModal.classList.add('hidden');
    }
    
    // Language System
    initializeLanguage() {
        // Automatische Spracherkennung basierend auf der Browsersprache
        if (!localStorage.getItem('unoLanguage')) {
            const browserLanguage = this.detectBrowserLanguage();
            this.currentLanguage = browserLanguage;
            localStorage.setItem('unoLanguage', browserLanguage);
            
            // Zeige Benachrichtigung √ºber automatisch erkannte Sprache
            this.showAutoLanguageNotification(browserLanguage);
        }
        
        this.updateLanguageDisplay();
        this.updateAllTexts();
    }
    
    detectBrowserLanguage() {
        // Browsersprache abrufen
        const browserLang = navigator.language || navigator.userLanguage || 'de';
        const primaryLang = browserLang.split('-')[0].toLowerCase();
        
        // Verf√ºgbare Sprachen im Spiel
        const availableLanguages = ['de', 'en', 'es', 'fr', 'pt', 'ja', 'zh', 'hu', 'ru'];
        
        // Wenn die Prim√§rsprache verf√ºgbar ist, verwende sie
        if (availableLanguages.includes(primaryLang)) {
            return primaryLang;
        }
        
        // Versuche, eine √§hnliche Sprache zu finden (z.B. 'en-US' -> 'en', 'pt-BR' -> 'pt')
        const similarLang = availableLanguages.find(lang => 
            browserLang.toLowerCase().startsWith(lang)
        );
        
        if (similarLang) {
            return similarLang;
        }
        
        // Fallback auf Deutsch
        return 'de';
    }
    
    resetToAutoLanguage() {
        const autoLanguage = this.detectBrowserLanguage();
        this.currentLanguage = autoLanguage;
        localStorage.removeItem('unoLanguage'); // Entferne den gespeicherten Wert, damit Auto-Modus aktiv bleibt
        this.updateLanguageDisplay();
        this.updateAllTexts();
        
        // Wenn ein Spiel l√§uft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
        
        // Zeige Benachrichtigung
        this.showLanguageChangeNotification('auto');
    }
    
    switchLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('unoLanguage', lang);
        this.updateLanguageDisplay();
        this.updateAllTexts();
        
        // Wenn ein Spiel l√§uft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
        
        // Update skill display with new language
        this.updateSkillDisplay();
        
        // Zeige eine Benachrichtigung, dass die Sprache ge√§ndert wurde
        this.showLanguageChangeNotification(lang);
    }
    
    showLanguageChangeNotification(lang) {
        // Erstelle eine tempor√§re Benachrichtigung
        const notification = document.createElement('div');
        notification.className = 'language-notification';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        `;
        
        const languageNames = {
            'de': 'Deutsch',
            'en': 'English',
            'es': 'Espa√±ol',
            'fr': 'Fran√ßais',
            'pt': 'Portugu√™s',
            'ja': 'Êó•Êú¨Ë™û',
            'zh': '‰∏≠Êñá',
            'hu': 'Magyar',
            'ru': '–†—É—Å—Å–∫–∏–π'
        };
        
        if (lang === 'auto') {
            const autoLanguage = this.detectBrowserLanguage();
            notification.textContent = `Sprache auf Auto gesetzt: ${languageNames[autoLanguage] || autoLanguage}`;
        } else {
            notification.textContent = `Sprache ge√§ndert zu: ${languageNames[lang] || lang}`;
        }
        document.body.appendChild(notification);
        
        // Animation einblenden
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // Nach 3 Sekunden ausblenden
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    showAutoLanguageNotification(detectedLanguage) {
        // Erstelle eine tempor√§re Benachrichtigung f√ºr automatisch erkannte Sprache
        const notification = document.createElement('div');
        notification.className = 'language-notification auto-detected';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2196F3;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        `;
        
        const languageNames = {
            'de': 'Deutsch',
            'en': 'English',
            'es': 'Espa√±ol',
            'fr': 'Fran√ßais',
            'pt': 'Portugu√™s',
            'ja': 'Êó•Êú¨Ë™û',
            'zh': '‰∏≠Êñá',
            'hu': 'Magyar',
            'ru': '–†—É—Å—Å–∫–∏–π'
        };
        
        notification.textContent = `üåê Sprache automatisch erkannt: ${languageNames[detectedLanguage] || detectedLanguage}`;
        document.body.appendChild(notification);
        
        // Animation einblenden
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // Nach 4 Sekunden ausblenden
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 4000);
    }
    
    regenerateComputerNames() {
        // Reset verwendet Namen und generiere neue Namen f√ºr alle Computer
        this.usedNames = [];
        for (let i = 1; i < this.playerCount; i++) {
            const newName = this.getRandomComputerName();
            this.computerPlayerNames[i] = newName;
            
            // Update UI
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                const nameElement = playerElement.querySelector('.player-info h3');
                if (nameElement) {
                    nameElement.textContent = newName;
                }
            }
        }
        
        // Update turn display with new names
        this.updateTurnDisplay();
    }
    
    toggleLanguageMenu() {
        this.languageMenu.classList.toggle('hidden');
        this.languageToggle.classList.toggle('open');
    }
    
    hideLanguageMenu() {
        this.languageMenu.classList.add('hidden');
        this.languageToggle.classList.remove('open');
    }
    
    updateLanguageDisplay() {
        // Update current flag in toggle button
        const languageFlags = {
            'de': 'üá©üá™',
            'en': 'üá¨üáß', 
            'es': 'üá™üá∏',
            'fr': 'üá´üá∑',
            'pt': 'üáßüá∑',
            'ja': 'üáØüáµ',
            'zh': 'üá®üá≥',
            'hu': 'üá≠üá∫',
            'ru': 'üá∑üá∫'
        };
        
        this.currentFlag.textContent = languageFlags[this.currentLanguage] || 'üá©üá™';
        
        // Update active state in dropdown
        this.languageOptions.forEach(option => {
            if (option.dataset.lang === 'auto') {
                // Auto-Option ist aktiv, wenn keine Sprache im localStorage gespeichert ist
                const isAutoActive = !localStorage.getItem('unoLanguage');
                option.classList.toggle('active', isAutoActive);
            } else {
                option.classList.toggle('active', option.dataset.lang === this.currentLanguage);
            }
        });
    }
    
    t(key, ...args) {
        const translation = translations[this.currentLanguage]?.[key] || translations['de'][key] || key;
        return args.length > 0 ? this.formatString(translation, ...args) : translation;
    }
    
    formatString(str, ...args) {
        return str.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
    }
    
    updateAllTexts() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            if (key === 'settings.version') {
                // Special handling for version text
                const version = element.getAttribute('data-version') || APP_VERSION;
                element.textContent = this.t(key, version);
            } else {
                element.textContent = this.t(key);
            }
        });
        
        // Update dynamic texts if game is running
        if (this.gameInProgress) {
            this.updateTurnDisplay();
        }
    }
    
    // Settings System
    showSettings() {
        this.settingsModal.classList.remove('hidden');
    }
    
    hideSettings() {
        this.settingsModal.classList.add('hidden');
    }
    
    initializeBackground() {
        this.applyBackground(this.currentBackground);
        this.updateBackgroundOptions();
    }
    
    changeBackground(bgName) {
        this.currentBackground = bgName;
        localStorage.setItem('unoBackground', bgName);
        this.applyBackground(bgName);
        this.updateBackgroundOptions();
    }
    
    applyBackground(bgName) {
        // Remove all background classes
        document.body.className = document.body.className.replace(/bg-\w+/g, '');
        // Add new background class
        document.body.classList.add(`bg-${bgName}`);
    }
    
    updateBackgroundOptions() {
        this.backgroundOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.bg === this.currentBackground);
        });
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new UnoGame();
});
