// Translations
const translations = {
    de: {
        "game.title": "UNO",
        "start.playerCount": "Anzahl Computer-Gegner:",
        "start.players2": "Du + 1 Computer",
        "start.players3": "Du + 2 Computer", 
        "start.players4": "Du + 3 Computer",
        "start.difficulty": "Schwierigkeitsgrad w√§hlen:",
        "difficulty.easy": "Einfach",
        "difficulty.easyDesc": "Defensiver Computer",
        "difficulty.medium": "Mittel",
        "difficulty.mediumDesc": "Ausgewogener Computer",
        "difficulty.hard": "Schwer",
        "difficulty.hardDesc": "Strategischer Computer",
        "start.rules": "Spielregeln",
        "start.startGame": "Spiel starten",
        "game.yourTurn": "Dein Zug",
        "game.computerTurn": "Computer {0} ist dran",
        "game.drawCard": "Karte ziehen",
        "game.uno": "UNO!",
        "game.currentColor": "Aktuelle Farbe:",
        "game.cards": "Karten",
        "game.chooseColor": "Farbe w√§hlen:",
        "game.computerChooses": "Computer w√§hlt: {0}",
        "game.unoCalled": "UNO gerufen!",
        "game.computerCallsUno": "Computer {0} ruft UNO!",
        "game.unoForgotten": "UNO vergessen! +2 Karten",
        "game.won": "Gewonnen! üéâ",
        "game.lost": "Verloren üòî", 
        "game.wonText": "Herzlichen Gl√ºckwunsch! Du hast das Spiel gewonnen!",
        "game.lostText": "Computer {0} hat gewonnen. Versuch es nochmal!",
        "game.playAgain": "Nochmal spielen",
        "game.restart": "M√∂chtest du das Spiel wirklich neu starten?",
        "game.empty": "Leer",
        "colors.red": "Rot",
        "colors.blue": "Blau", 
        "colors.green": "Gr√ºn",
        "colors.yellow": "Gelb",
        "settings.title": "Einstellungen",
        "settings.background": "üé® Hintergrund",
        "settings.bg.default": "Standard",
        "settings.bg.ocean": "Ozean",
        "settings.bg.sunset": "Sonnenuntergang",
        "settings.bg.forest": "Wald",
        "settings.bg.space": "Weltraum",
        "settings.bg.gradient": "Farbverlauf",
        "settings.close": "Fertig"
    },
    en: {
        "game.title": "UNO",
        "start.playerCount": "Number of Computer Opponents:",
        "start.players2": "You + 1 Computer",
        "start.players3": "You + 2 Computers",
        "start.players4": "You + 3 Computers", 
        "start.difficulty": "Choose Difficulty:",
        "difficulty.easy": "Easy",
        "difficulty.easyDesc": "Defensive Computer",
        "difficulty.medium": "Medium",
        "difficulty.mediumDesc": "Balanced Computer",
        "difficulty.hard": "Hard",
        "difficulty.hardDesc": "Strategic Computer",
        "start.rules": "Game Rules",
        "start.startGame": "Start Game",
        "game.yourTurn": "Your Turn",
        "game.computerTurn": "Computer {0}'s Turn",
        "game.drawCard": "Draw Card",
        "game.uno": "UNO!",
        "game.currentColor": "Current Color:",
        "game.cards": "Cards",
        "game.chooseColor": "Choose Color:",
        "game.computerChooses": "Computer chooses: {0}",
        "game.unoCalled": "UNO called!",
        "game.computerCallsUno": "Computer {0} calls UNO!",
        "game.unoForgotten": "UNO forgotten! +2 Cards",
        "game.won": "You Won! üéâ",
        "game.lost": "You Lost üòî",
        "game.wonText": "Congratulations! You won the game!",
        "game.lostText": "Computer {0} won. Try again!",
        "game.playAgain": "Play Again",
        "game.restart": "Do you really want to restart the game?",
        "game.empty": "Empty",
        "colors.red": "Red",
        "colors.blue": "Blue",
        "colors.green": "Green", 
        "colors.yellow": "Yellow",
        "settings.title": "Settings",
        "settings.background": "üé® Background",
        "settings.bg.default": "Default",
        "settings.bg.ocean": "Ocean",
        "settings.bg.sunset": "Sunset",
        "settings.bg.forest": "Forest",
        "settings.bg.space": "Space",
        "settings.bg.gradient": "Gradient",
        "settings.close": "Done"
    },
    hu: {
        "game.title": "UNO",
        "start.playerCount": "Sz√°m√≠t√≥g√©pes ellenfelek sz√°ma:",
        "start.players2": "Te + 1 Sz√°m√≠t√≥g√©p",
        "start.players3": "Te + 2 Sz√°m√≠t√≥g√©p",
        "start.players4": "Te + 3 Sz√°m√≠t√≥g√©p",
        "start.difficulty": "Neh√©zs√©gi szint:",
        "difficulty.easy": "K√∂nny≈±",
        "difficulty.easyDesc": "Defenz√≠v sz√°m√≠t√≥g√©p",
        "difficulty.medium": "K√∂zepes",
        "difficulty.mediumDesc": "Kiegyens√∫lyozott sz√°m√≠t√≥g√©p",
        "difficulty.hard": "Neh√©z",
        "difficulty.hardDesc": "Strat√©giai sz√°m√≠t√≥g√©p",
        "start.rules": "J√°t√©kszab√°lyok",
        "start.startGame": "J√°t√©k ind√≠t√°sa",
        "game.yourTurn": "Te k√∂vetkezel",
        "game.computerTurn": "{0}. sz√°m√≠t√≥g√©p k√∂vetkezik",
        "game.drawCard": "K√°rtya h√∫z√°sa",
        "game.uno": "UNO!",
        "game.currentColor": "Jelenlegi sz√≠n:",
        "game.cards": "K√°rty√°k",
        "game.chooseColor": "Sz√≠n v√°laszt√°sa:",
        "game.computerChooses": "A sz√°m√≠t√≥g√©p v√°laszt: {0}",
        "game.unoCalled": "UNO mondva!",
        "game.computerCallsUno": "{0}. sz√°m√≠t√≥g√©p UNO-t mond!",
        "game.unoForgotten": "UNO elfelejtve! +2 K√°rtya",
        "game.won": "Nyert√©l! üéâ",
        "game.lost": "Vesztett√©l üòî",
        "game.wonText": "Gratul√°lok! Megnyerted a j√°t√©kot!",
        "game.lostText": "{0}. sz√°m√≠t√≥g√©p nyert. Pr√≥b√°ld √∫jra!",
        "game.playAgain": "√öjra j√°t√©k",
        "game.restart": "Biztosan √∫jra szeretn√©d ind√≠tani a j√°t√©kot?",
        "game.empty": "√úres",
        "colors.red": "Piros",
        "colors.blue": "K√©k",
        "colors.green": "Z√∂ld",
        "colors.yellow": "S√°rga",
        "settings.title": "Be√°ll√≠t√°sok",
        "settings.background": "üé® H√°tt√©r",
        "settings.bg.default": "Alap√©rtelmezett",
        "settings.bg.ocean": "√ìce√°n",
        "settings.bg.sunset": "Naplemente",
        "settings.bg.forest": "Erd≈ë",
        "settings.bg.space": "Vil√°g≈±r",
        "settings.bg.gradient": "Sz√≠n√°tmenet",
        "settings.close": "K√©sz"
    },
    ru: {
        "game.title": "–£–ù–û",
        "start.playerCount": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤:",
        "start.players2": "–¢—ã + 1 –ö–æ–º–ø—å—é—Ç–µ—Ä",
        "start.players3": "–¢—ã + 2 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.players4": "–¢—ã + 3 –ö–æ–º–ø—å—é—Ç–µ—Ä–∞",
        "start.difficulty": "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å:",
        "difficulty.easy": "–õ–µ–≥–∫–æ",
        "difficulty.easyDesc": "–û–±–æ—Ä–æ–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.medium": "–°—Ä–µ–¥–Ω–µ",
        "difficulty.mediumDesc": "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "difficulty.hard": "–°–ª–æ–∂–Ω–æ",
        "difficulty.hardDesc": "–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π –∫–æ–º–ø—å—é—Ç–µ—Ä",
        "start.rules": "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã",
        "start.startGame": "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
        "game.yourTurn": "–í–∞—à —Ö–æ–¥",
        "game.computerTurn": "–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ {0}",
        "game.drawCard": "–í–∑—è—Ç—å –∫–∞—Ä—Ç—É",
        "game.uno": "–£–ù–û!",
        "game.currentColor": "–¢–µ–∫—É—â–∏–π —Ü–≤–µ—Ç:",
        "game.cards": "–ö–∞—Ä—Ç—ã",
        "game.chooseColor": "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:",
        "game.computerChooses": "–ö–æ–º–ø—å—é—Ç–µ—Ä –≤—ã–±–∏—Ä–∞–µ—Ç: {0}",
        "game.unoCalled": "–£–ù–û –æ–±—ä—è–≤–ª–µ–Ω–æ!",
        "game.computerCallsUno": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –æ–±—ä—è–≤–ª—è–µ—Ç –£–ù–û!",
        "game.unoForgotten": "–£–ù–û –∑–∞–±—ã—Ç–æ! +2 –ö–∞—Ä—Ç—ã",
        "game.won": "–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏! üéâ",
        "game.lost": "–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ üòî",
        "game.wonText": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –∏–≥—Ä—É!",
        "game.lostText": "–ö–æ–º–ø—å—é—Ç–µ—Ä {0} –≤—ã–∏–≥—Ä–∞–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!",
        "game.playAgain": "–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞",
        "game.restart": "–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É?",
        "game.empty": "–ü—É—Å—Ç–æ",
        "colors.red": "–ö—Ä–∞—Å–Ω—ã–π",
        "colors.blue": "–°–∏–Ω–∏–π",
        "colors.green": "–ó–µ–ª—ë–Ω—ã–π",
        "colors.yellow": "–ñ—ë–ª—Ç—ã–π",
        "settings.title": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings.background": "üé® –§–æ–Ω",
        "settings.bg.default": "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings.bg.ocean": "–û–∫–µ–∞–Ω",
        "settings.bg.sunset": "–ó–∞–∫–∞—Ç",
        "settings.bg.forest": "–õ–µ—Å",
        "settings.bg.space": "–ö–æ—Å–º–æ—Å",
        "settings.bg.gradient": "–ì—Ä–∞–¥–∏–µ–Ω—Ç",
        "settings.close": "–ì–æ—Ç–æ–≤–æ"
    },
    es: {
        "game.title": "UNO",
        "start.playerCount": "N√∫mero de oponentes computadora:",
        "start.players2": "T√∫ + 1 Computadora",
        "start.players3": "T√∫ + 2 Computadoras",
        "start.players4": "T√∫ + 3 Computadoras",
        "start.difficulty": "Elegir dificultad:",
        "difficulty.easy": "F√°cil",
        "difficulty.easyDesc": "Computadora defensiva",
        "difficulty.medium": "Medio",
        "difficulty.mediumDesc": "Computadora equilibrada",
        "difficulty.hard": "Dif√≠cil",
        "difficulty.hardDesc": "Computadora estrat√©gica",
        "start.rules": "Reglas del juego",
        "start.startGame": "Empezar juego",
        "game.yourTurn": "Tu turno",
        "game.computerTurn": "Turno de {0}",
        "game.drawCard": "Robar carta",
        "game.uno": "¬°UNO!",
        "game.currentColor": "Color actual:",
        "game.cards": "Cartas",
        "game.chooseColor": "Elegir color:",
        "game.computerChooses": "La computadora elige: {0}",
        "game.unoCalled": "¬°UNO gritado!",
        "game.computerCallsUno": "¬°{0} grita UNO!",
        "game.unoForgotten": "¬°UNO olvidado! +2 Cartas",
        "game.won": "¬°Ganaste! üéâ",
        "game.lost": "Perdiste üòî",
        "game.wonText": "¬°Felicidades! ¬°Ganaste el juego!",
        "game.lostText": "{0} gan√≥. ¬°Int√©ntalo de nuevo!",
        "game.playAgain": "Jugar de nuevo",
        "game.restart": "¬øRealmente quieres reiniciar el juego?",
        "game.empty": "Vac√≠o",
        "colors.red": "Rojo",
        "colors.blue": "Azul",
        "colors.green": "Verde",
        "colors.yellow": "Amarillo",
        "settings.title": "Configuraci√≥n",
        "settings.background": "üé® Fondo",
        "settings.bg.default": "Por defecto",
        "settings.bg.ocean": "Oc√©ano",
        "settings.bg.sunset": "Atardecer",
        "settings.bg.forest": "Bosque",
        "settings.bg.space": "Espacio",
        "settings.bg.gradient": "Gradiente",
        "settings.close": "Listo"
    },
    fr: {
        "game.title": "UNO",
        "start.playerCount": "Nombre d'adversaires ordinateur:",
        "start.players2": "Toi + 1 Ordinateur",
        "start.players3": "Toi + 2 Ordinateurs",
        "start.players4": "Toi + 3 Ordinateurs",
        "start.difficulty": "Choisir la difficult√©:",
        "difficulty.easy": "Facile",
        "difficulty.easyDesc": "Ordinateur d√©fensif",
        "difficulty.medium": "Moyen",
        "difficulty.mediumDesc": "Ordinateur √©quilibr√©",
        "difficulty.hard": "Difficile",
        "difficulty.hardDesc": "Ordinateur strat√©gique",
        "start.rules": "R√®gles du jeu",
        "start.startGame": "Commencer le jeu",
        "game.yourTurn": "Votre tour",
        "game.computerTurn": "Tour de {0}",
        "game.drawCard": "Piocher une carte",
        "game.uno": "UNO!",
        "game.currentColor": "Couleur actuelle:",
        "game.cards": "Cartes",
        "game.chooseColor": "Choisir la couleur:",
        "game.computerChooses": "L'ordinateur choisit: {0}",
        "game.unoCalled": "UNO annonc√©!",
        "game.computerCallsUno": "{0} annonce UNO!",
        "game.unoForgotten": "UNO oubli√©! +2 Cartes",
        "game.won": "Vous avez gagn√©! üéâ",
        "game.lost": "Vous avez perdu üòî",
        "game.wonText": "F√©licitations! Vous avez gagn√© le jeu!",
        "game.lostText": "{0} a gagn√©. Essayez encore!",
        "game.playAgain": "Rejouer",
        "game.restart": "Voulez-vous vraiment red√©marrer le jeu?",
        "game.empty": "Vide",
        "colors.red": "Rouge",
        "colors.blue": "Bleu",
        "colors.green": "Vert",
        "colors.yellow": "Jaune",
        "settings.title": "Param√®tres",
        "settings.background": "üé® Arri√®re-plan",
        "settings.bg.default": "Par d√©faut",
        "settings.bg.ocean": "Oc√©an",
        "settings.bg.sunset": "Coucher de soleil",
        "settings.bg.forest": "For√™t",
        "settings.bg.space": "Espace",
        "settings.bg.gradient": "D√©grad√©",
        "settings.close": "Termin√©"
    },
    pt: {
        "game.title": "UNO",
        "start.playerCount": "N√∫mero de oponentes computador:",
        "start.players2": "Voc√™ + 1 Computador",
        "start.players3": "Voc√™ + 2 Computadores",
        "start.players4": "Voc√™ + 3 Computadores",
        "start.difficulty": "Escolher dificuldade:",
        "difficulty.easy": "F√°cil",
        "difficulty.easyDesc": "Computador defensivo",
        "difficulty.medium": "M√©dio",
        "difficulty.mediumDesc": "Computador equilibrado",
        "difficulty.hard": "Dif√≠cil",
        "difficulty.hardDesc": "Computador estrat√©gico",
        "start.rules": "Regras do jogo",
        "start.startGame": "Come√ßar jogo",
        "game.yourTurn": "Sua vez",
        "game.computerTurn": "Vez de {0}",
        "game.drawCard": "Comprar carta",
        "game.uno": "UNO!",
        "game.currentColor": "Cor atual:",
        "game.cards": "Cartas",
        "game.chooseColor": "Escolher cor:",
        "game.computerChooses": "O computador escolhe: {0}",
        "game.unoCalled": "UNO gritado!",
        "game.computerCallsUno": "{0} grita UNO!",
        "game.unoForgotten": "UNO esquecido! +2 Cartas",
        "game.won": "Voc√™ ganhou! üéâ",
        "game.lost": "Voc√™ perdeu üòî",
        "game.wonText": "Parab√©ns! Voc√™ ganhou o jogo!",
        "game.lostText": "{0} ganhou. Tente novamente!",
        "game.playAgain": "Jogar novamente",
        "game.restart": "Voc√™ realmente quer reiniciar o jogo?",
        "game.empty": "Vazio",
        "colors.red": "Vermelho",
        "colors.blue": "Azul",
        "colors.green": "Verde",
        "colors.yellow": "Amarelo",
        "settings.title": "Configura√ß√µes",
        "settings.background": "üé® Fundo",
        "settings.bg.default": "Padr√£o",
        "settings.bg.ocean": "Oceano",
        "settings.bg.sunset": "P√¥r do sol",
        "settings.bg.forest": "Floresta",
        "settings.bg.space": "Espa√ßo",
        "settings.bg.gradient": "Gradiente",
        "settings.close": "Pronto"
    },
    ja: {
        "game.title": "UNO",
        "start.playerCount": "„Ç≥„É≥„Éî„É•„Éº„Çø„ÉºÂØæÊà¶Áõ∏Êâã„ÅÆÊï∞:",
        "start.players2": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº1Âè∞",
        "start.players3": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº2Âè∞",
        "start.players4": "„ÅÇ„Å™„Åü + „Ç≥„É≥„Éî„É•„Éº„Çø„Éº3Âè∞",
        "start.difficulty": "Èõ£ÊòìÂ∫¶„ÇíÈÅ∏Êäû:",
        "difficulty.easy": "Á∞°Âçò",
        "difficulty.easyDesc": "ÂÆàÂÇôÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "difficulty.medium": "ÊôÆÈÄö",
        "difficulty.mediumDesc": "„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„Åü„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "difficulty.hard": "Èõ£„Åó„ÅÑ",
        "difficulty.hardDesc": "Êà¶Áï•ÁöÑ„Å™„Ç≥„É≥„Éî„É•„Éº„Çø„Éº",
        "start.rules": "„Ç≤„Éº„É†„É´„Éº„É´",
        "start.startGame": "„Ç≤„Éº„É†ÈñãÂßã",
        "game.yourTurn": "„ÅÇ„Å™„Åü„ÅÆÁï™",
        "game.computerTurn": "{0}„ÅÆÁï™",
        "game.drawCard": "„Ç´„Éº„Éâ„ÇíÂºï„Åè",
        "game.uno": "„Ç¶„Éé!",
        "game.currentColor": "ÁèæÂú®„ÅÆËâ≤:",
        "game.cards": "Êûö",
        "game.chooseColor": "Ëâ≤„ÇíÈÅ∏Êäû:",
        "game.computerChooses": "„Ç≥„É≥„Éî„É•„Éº„Çø„Éº„ÅåÈÅ∏Êäû: {0}",
        "game.unoCalled": "„Ç¶„ÉéÂÆ£Ë®Ä!",
        "game.computerCallsUno": "{0}„Åå„Ç¶„ÉéÂÆ£Ë®Ä!",
        "game.unoForgotten": "„Ç¶„ÉéÂøò„Çå! +2Êûö",
        "game.won": "ÂãùÂà©! üéâ",
        "game.lost": "ÊïóÂåó üòî",
        "game.wonText": "„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅÂãùÂà©„Åó„Åæ„Åó„ÅüÔºÅ",
        "game.lostText": "{0}„ÅåÂãùÂà©„Åó„Åæ„Åó„Åü„ÄÇÂÜçÊåëÊà¶„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ",
        "game.playAgain": "„ÇÇ„ÅÜ‰∏ÄÂ∫¶",
        "game.restart": "Êú¨ÂΩì„Å´„Ç≤„Éº„É†„ÇíÂÜçÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü",
        "game.empty": "Á©∫",
        "colors.red": "Ëµ§",
        "colors.blue": "Èùí",
        "colors.green": "Á∑ë",
        "colors.yellow": "ÈªÑ",
        "settings.title": "Ë®≠ÂÆö",
        "settings.background": "üé® ËÉåÊôØ",
        "settings.bg.default": "„Éá„Éï„Ç©„É´„Éà",
        "settings.bg.ocean": "Êµ∑",
        "settings.bg.sunset": "Â§ïÊó•",
        "settings.bg.forest": "Ê£Æ",
        "settings.bg.space": "ÂÆáÂÆô",
        "settings.bg.gradient": "„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥",
        "settings.close": "ÂÆå‰∫Ü"
    },
    zh: {
        "game.title": "UNO",
        "start.playerCount": "ÁîµËÑëÂØπÊâãÊï∞Èáè:",
        "start.players2": "‰Ω† + 1Âè∞ÁîµËÑë",
        "start.players3": "‰Ω† + 2Âè∞ÁîµËÑë",
        "start.players4": "‰Ω† + 3Âè∞ÁîµËÑë",
        "start.difficulty": "ÈÄâÊã©ÈöæÂ∫¶:",
        "difficulty.easy": "ÁÆÄÂçï",
        "difficulty.easyDesc": "Èò≤ÂÆàÂûãÁîµËÑë",
        "difficulty.medium": "‰∏≠Á≠â",
        "difficulty.mediumDesc": "Âπ≥Ë°°ÂûãÁîµËÑë",
        "difficulty.hard": "Âõ∞Èöæ",
        "difficulty.hardDesc": "Á≠ñÁï•ÂûãÁîµËÑë",
        "start.rules": "Ê∏∏ÊàèËßÑÂàô",
        "start.startGame": "ÂºÄÂßãÊ∏∏Êàè",
        "game.yourTurn": "‰Ω†ÁöÑÂõûÂêà",
        "game.computerTurn": "{0}ÁöÑÂõûÂêà",
        "game.drawCard": "ÊäΩÁâå",
        "game.uno": "UNO!",
        "game.currentColor": "ÂΩìÂâçÈ¢úËâ≤:",
        "game.cards": "Âº†Áâå",
        "game.chooseColor": "ÈÄâÊã©È¢úËâ≤:",
        "game.computerChooses": "ÁîµËÑëÈÄâÊã©: {0}",
        "game.unoCalled": "UNOÂÆ£Âëä!",
        "game.computerCallsUno": "{0}ÂÆ£ÂëäUNO!",
        "game.unoForgotten": "ÂøòËÆ∞UNO! +2Âº†Áâå",
        "game.won": "ËÉúÂà©! üéâ",
        "game.lost": "Â§±Ë¥• üòî",
        "game.wonText": "ÊÅ≠ÂñúÔºÅ‰Ω†Ëµ¢Âæó‰∫ÜÊ∏∏ÊàèÔºÅ",
        "game.lostText": "{0}Ëé∑ËÉú‰∫Ü„ÄÇÂÜçËØï‰∏ÄÊ¨°ÔºÅ",
        "game.playAgain": "ÂÜçÁé©‰∏ÄÊ¨°",
        "game.restart": "ÁúüÁöÑË¶ÅÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÂêóÔºü",
        "game.empty": "Á©∫",
        "colors.red": "Á∫¢Ëâ≤",
        "colors.blue": "ËìùËâ≤",
        "colors.green": "ÁªøËâ≤",
        "colors.yellow": "ÈªÑËâ≤",
        "settings.title": "ËÆæÁΩÆ",
        "settings.background": "üé® ËÉåÊôØ",
        "settings.bg.default": "ÈªòËÆ§",
        "settings.bg.ocean": "Êµ∑Ê¥ã",
        "settings.bg.sunset": "Êó•ËêΩ",
        "settings.bg.forest": "Ê£ÆÊûó",
        "settings.bg.space": "Â§™Á©∫",
        "settings.bg.gradient": "Ê∏êÂèò",
        "settings.close": "ÂÆåÊàê"
    }
};

// UNO Game Implementation
class UnoGame {
    constructor() {
        this.colors = ['red', 'blue', 'green', 'yellow'];
        this.numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.actions = ['skip', 'reverse', 'draw-two'];
        this.wilds = ['wild', 'wild-draw-four'];
        
        // Lustige Computer-Namen nach Sprachen
        this.computerNamesByLanguage = {
            de: [
                'KartenKaiser', 'UnoUlrich', 'BlitzBerta', 'TurboTina', 'MegaMax',
                'FlitzerFritz', 'ZaubererZoe', 'RaketenRudi', 'SuperSusi', 'BlitzerBob',
                'GigaGerta', 'TurbineTom', 'FlashFiona', 'BoosterBruno', 'ZoomZara',
                'SpeediSepp', 'RaserRita', 'TurboTeddy', 'FlitzerFee', 'RocketRalf',
                'UnoUlla', 'KartenKurt', 'BlitzBrigitte', 'PowerPaul', 'MegaMaria',
                'TurboThomas', 'SpeedySandra', 'FlashFelix', 'ZoomZoe', 'RaketaRose',
                'SuperSchnecke', 'BlitzBirne', 'TurboTomate', 'FlitzerFisch', 'UnoUhu',
                'KartenKaktus', 'BlitzBanane', 'PowerPinguin', 'MegaMaulwurf', 'TurboTiger'
            ],
            en: [
                'CardKing', 'UnoUnicorn', 'FlashFred', 'TurboTom', 'MegaMax',
                'SpeedySpike', 'WizardWanda', 'RocketRob', 'SuperSam', 'BlitzBella',
                'GigaGrace', 'TurboTed', 'FlashFiona', 'BoosterBen', 'ZoomZoe',
                'QuickQuinn', 'RushRuby', 'TurboTerry', 'FlashFay', 'RocketRyan',
                'UnoUrsula', 'CardCarl', 'BlitzBrian', 'PowerPat', 'MegaMia',
                'TurboTracy', 'SpeedySarah', 'FlashFinn', 'ZoomZack', 'RocketRose',
                'SuperSnail', 'BlitzBerry', 'TurboTomato', 'FlashFish', 'UnoOwl',
                'CardCactus', 'BlitzBanana', 'PowerPenguin', 'MegaMole', 'TurboTiger'
            ],
            hu: [
                'K√°rtyaKir√°ly', 'UnoUnikorn', 'Vill√°mVilma', 'Turb√≥Tam√°s', 'MegaMarci',
                'Sebess√©giSzabi', 'Var√°zsl√≥Vera', 'Rak√©taR√≥bert', 'SzuperSzilvi', 'Vill√°mViktor',
                'GigaGabi', 'Turb√≥Tibor', 'Vill√°mVanda', 'Er≈ës√≠t≈ëErn≈ë', 'ZoomZolt√°n',
                'GyorsGerg≈ë', 'Rohamn√©Rita', 'Turb√≥T√ºnde', 'Vill√°mVivien', 'Rak√©taR√©ka',
                'Uno√örsula', 'K√°rtyaK√°lm√°n', 'Vill√°mViktor', 'Er≈ësErika', 'MegaM√≥nika',
                'Turb√≥Ter√©z', 'GyorsSzandra', 'Vill√°mFerenc', 'ZoomZsuzsa', 'Rak√©taR√≥zsa',
                'SzuperCsiga', 'Vill√°mBogy√≥', 'Turb√≥Paradicsom', 'Vill√°mHal', 'UnoBagoly',
                'K√°rtyaKaktusz', 'Vill√°mBan√°n', 'Er≈ësPingvin', 'MegaVakond', 'Turb√≥Tigris'
            ],
            ru: [
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Ä–æ–ª—å', '–£–Ω–æ–Æ–Ω–∏–∫–æ—Ä–Ω', '–ú–æ–ª–Ω–∏—è–ú–∞—à–∞', '–¢—É—Ä–±–æ–¢–æ–Ω—è', '–ú–µ–≥–∞–ú–∞–∫—Å',
                '–°–∫–æ—Ä–æ—Å—Ç–Ω–æ–π–°–µ—Ä–≥–µ–π', '–í–æ–ª—à–µ–±–Ω–∏–∫–í–µ—Ä–∞', '–†–∞–∫–µ—Ç–∞–†–æ–º–∞–Ω', '–°—É–ø–µ—Ä–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–ú–∏—à–∞',
                '–ì–∏–≥–∞–ì–∞–ª–∏–Ω–∞', '–¢—É—Ä–±–æ–¢–∏–º—É—Ä', '–ú–æ–ª–Ω–∏—è–í–∞–Ω–¥–∞', '–ë—É—Å—Ç–µ—Ä–ë–æ—Ä–∏—Å', '–ó—É–º–ó–æ—è',
                '–ë—ã—Å—Ç—Ä—ã–π–ë–æ—Ä–∏—Å', '–°–ø–µ—à–∫–∞–°–≤–µ—Ç–∞', '–¢—É—Ä–±–æ–¢–∞—Ç—å—è–Ω–∞', '–ú–æ–ª–Ω–∏—è–í–∏–∫—Ç–æ—Ä', '–†–∞–∫–µ—Ç–∞–†–∏—Ç–∞',
                '–£–Ω–æ–£–ª—å—è–Ω–∞', '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–æ—Å—Ç—è', '–ú–æ–ª–Ω–∏—è–ú–∞—Ä–∏–Ω–∞', '–°–∏–ª–∞–°–µ—Ä–≥–µ–π', '–ú–µ–≥–∞–ú–∞—Ä–∏—è',
                '–¢—É—Ä–±–æ–¢–∞–Ω—è', '–°–∫–æ—Ä—ã–π–°–∞—à–∞', '–ú–æ–ª–Ω–∏—è–§—ë–¥–æ—Ä', '–ó—É–º–ó–∏–Ω–∞–∏–¥–∞', '–†–∞–∫–µ—Ç–∞–†–æ–∑–∞',
                '–°—É–ø–µ—Ä–£–ª–∏—Ç–∫–∞', '–ú–æ–ª–Ω–∏—è–Ø–≥–æ–¥–∞', '–¢—É—Ä–±–æ–ü–æ–º–∏–¥–æ—Ä', '–ú–æ–ª–Ω–∏—è–†—ã–±–∞', '–£–Ω–æ–°–æ–≤–∞',
                '–ö–∞—Ä—Ç–æ—á–Ω—ã–π–ö–∞–∫—Ç—É—Å', '–ú–æ–ª–Ω–∏—è–ë–∞–Ω–∞–Ω', '–°–∏–ª—å–Ω—ã–π–ü–∏–Ω–≥–≤–∏–Ω', '–ú–µ–≥–∞–ö—Ä–æ—Ç', '–¢—É—Ä–±–æ–¢–∏–≥—Ä'
            ],
            es: [
                'ReyCartas', 'UnoUnicornio', 'Rel√°mpagoRosa', 'TurboTeo', 'MegaMax',
                'VelocidadVera', 'MagoMario', 'CoheteCarlos', 'SuperSofia', 'Rel√°mpagoRafa',
                'GigaGloria', 'TurboTom√°s', 'FlashFrancisca', 'BoosterBenji', 'ZoomZara',
                'R√°pidoRicardo', 'PrisaPatricia', 'TurboTere', 'FlashFelipe', 'CoheteClara',
                'UnoUrsula', 'CartasCarmen', 'Rel√°mpagoRoberto', 'PoderPablo', 'MegaMar√≠a',
                'TurboTania', 'VeloceSandra', 'FlashFernando', 'ZoomZoe', 'CoheteRosa',
                'SuperCaracol', 'Rel√°mpagoUva', 'TurboTomate', 'FlashPez', 'UnoB√∫ho',
                'CartasCactus', 'Rel√°mpagoPlatano', 'PoderPing√ºino', 'MegaTopo', 'TurboTigre'
            ],
            fr: [
                'RoiCartes', 'UnoLicorne', '√âclair√âmilie', 'TurboTh√©o', 'M√©gaMax',
                'VitesseVictor', 'MagicienMarcel', 'Fus√©eFran√ßoise', 'SuperSylvie', '√âclair√âric',
                'GigaGabrielle', 'TurboThomas', 'FlashFanny', 'BoosterBenjamin', 'ZoomZo√©',
                'RapideRaymond', 'PressePauline', 'TurboTh√©r√®se', 'FlashFabien', 'Fus√©eClaire',
                'UnoUrsule', 'CartesCl√©ment', '√âclairRen√©e', 'PouvoirPierre', 'M√©gaMarie',
                'TurboTanya', 'V√©loceSandra', 'FlashF√©lix', 'ZoomZacharie', 'Fus√©eRose',
                'SuperEscargot', '√âclairRaisin', 'TurboTomate', 'FlashPoisson', 'UnoHibou',
                'CartesCactus', '√âclairBanane', 'PouvoirPingouin', 'M√©gaTaupe', 'TurboTigre'
            ],
            pt: [
                'ReiCartas', 'UnoUnic√≥rnio', 'Rel√¢mpagoRita', 'TurboTiago', 'MegaMax',
                'VelocidadeVera', 'M√°gicoM√°rio', 'FogueteFelix', 'SuperS√¥nia', 'Rel√¢mpagoRafa',
                'GigaGisele', 'TurboTom√°s', 'FlashFernanda', 'BoosterBruno', 'ZoomZara',
                'R√°pidoRicardo', 'PressaPatr√≠cia', 'TurboTina', 'FlashF√°bio', 'FogueteClara',
                'Uno√örsula', 'CartasCarlos', 'Rel√¢mpagoRenata', 'PoderPaulo', 'MegaMaria',
                'TurboT√¢nia', 'VelozSandra', 'FlashFernando', 'ZoomZ√©', 'FogueteRosa',
                'SuperCaracol', 'Rel√¢mpagoUva', 'TurboTomate', 'FlashPeixe', 'UnoCoruja',
                'CartasCacto', 'Rel√¢mpagoBanana', 'PoderPinguim', 'MegaToupeira', 'TurboTigre'
            ],
            ja: [
                '„Ç´„Éº„Éâ„Ç≠„É≥„Ç∞', '„Ç¶„Éé„É¶„Éã„Ç≥„Éº„É≥', '„Ç§„Éä„Ç∫„Éû„Ç¢„Ç§', '„Çø„Éº„Éú„Çø„É≠„Ç¶', '„É°„Ç¨„Éû„ÉÉ„ÇØ„Çπ',
                '„Çπ„Éî„Éº„Éâ„Çµ„Éà„Ç∑', '„Éû„Ç∏„Ç∑„É£„É≥„Éü„Ç´', '„É≠„Ç±„ÉÉ„Éà„É™„Éß„Ç¶', '„Çπ„Éº„Éë„Éº„Çµ„Ç≠', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„É≠„Ç¶',
                '„ÇÆ„Ç¨„Ç¥„É≠„Ç¶', '„Çø„Éº„Éú„Çø„Ç´„Ç∑', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü', '„Éñ„Éº„Çπ„Çø„Éº„Éô„É≥', '„Ç∫„Éº„É†„Çæ„Ç®',
                '„ÇØ„Ç§„ÉÉ„ÇØ„Ç±„É≥„Ç∏', '„É©„ÉÉ„Ç∑„É•„É™„Ç´', '„Çø„Éº„Éú„ÉÜ„É´', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Éü„Ç™', '„É≠„Ç±„ÉÉ„Éà„É™„Éä',
                '„Ç¶„Éé„Ç¶„É©„É©', '„Ç´„Éº„Éâ„Ç±„É≥', '„Ç§„Éä„Ç∫„Éû„Ç§„Ç∫„Éü', '„Éë„ÉØ„Éº„Éù„É≥', '„É°„Ç¨„Éû„Éü',
                '„Çø„Éº„Éú„Çø„Éü', '„Çπ„Éî„Éº„Éá„Ç£„Çµ„ÉÅ', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç∏', '„Ç∫„Éº„É†„Çº„É≥', '„É≠„Ç±„ÉÉ„Éà„É≠„Éº„Ç∫',
                '„Çπ„Éº„Éë„Éº„Ç´„Çø„ÉÑ„É†„É™', '„Ç§„Éä„Ç∫„Éû„Ç§„ÉÅ„Ç¥', '„Çø„Éº„Éú„Éà„Éû„Éà', '„Éï„É©„ÉÉ„Ç∑„É•„Éï„Ç£„ÉÉ„Ç∑„É•', '„Ç¶„Éé„Éï„ÇØ„É≠„Ç¶',
                '„Ç´„Éº„Éâ„Ç´„ÇØ„Çø„Çπ', '„Ç§„Éä„Ç∫„Éû„Éê„Éä„Éä', '„Éë„ÉØ„Éº„Éö„É≥„ÇÆ„É≥', '„É°„Ç¨„É¢„Ç∞„É©', '„Çø„Éº„Éú„Éà„É©'
            ],
            zh: [
                'Âç°Áâå‰πãÁéã', '‰πåËØ∫Áã¨ËßíÂÖΩ', 'Èó™Áîµ‰∏Ω‰∏Ω', 'Ê∂°ËΩÆÂ∞èÊòé', 'Ë∂ÖÁ∫ßÈ∫¶ÂÖãÊñØ',
                'ÈÄüÂ∫¶Â∞èËñá', 'È≠îÊ≥ïÂ∏àÈ©¨ÈáåÂ••', 'ÁÅ´ÁÆ≠Â∞èÈ£û', 'Ë∂ÖÁ∫ßÂ∞èËãè', 'Èó™ÁîµÂ∞èÂº∫',
                'ÂçÉÂÖÜÂ∞èÂàö', 'Ê∂°ËΩÆÂ∞èÊ∂õ', 'Èó™ÂÖâÂ∞èËä≥', 'Âä©Êé®Âô®Â∞èÊú¨', 'Áº©ÊîæÂ∞èÊüî',
                'Âø´ÈÄüÂ∞èÁëû', 'ÂåÜÂøôÂ∞è‰Ω©', 'Ê∂°ËΩÆÂ∞èÂ©∑', 'Èó™ÂÖâÂ∞èÈ£û', 'ÁÅ´ÁÆ≠Â∞èÂÖã',
                '‰πåËØ∫Â∞èÈõ®', 'Âç°ÁâåÂ∞èÈôà', 'Èó™ÁîµÂ∞èËïæ', 'ÂäõÈáèÂ∞è‰øù', 'Ë∂ÖÁ∫ßÂ∞èÁéõ',
                'Ê∂°ËΩÆÂ∞èË∞≠', 'Âø´ÈÄüÂ∞èÊ°ë', 'Èó™ÂÖâÂ∞èÂ≥∞', 'Áº©ÊîæÂ∞èÊ≥Ω', 'ÁÅ´ÁÆ≠Â∞èËî∑',
                'Ë∂ÖÁ∫ßËúóÁâõ', 'Èó™ÁîµËë°ËêÑ', 'Ê∂°ËΩÆÁï™ËåÑ', 'Èó™ÂÖâÂ∞èÈ±º', '‰πåËØ∫Áå´Â§¥Èπ∞',
                'Âç°Áâå‰ªô‰∫∫Êéå', 'Èó™ÁîµÈ¶ôËïâ', 'ÂäõÈáè‰ºÅÈπÖ', 'Ë∂ÖÁ∫ßÈºπÈº†', 'Ê∂°ËΩÆËÄÅËôé'
            ]
        };
        this.usedNames = [];  // Bereits verwendete Namen in diesem Spiel
        
        this.deck = [];
        this.players = []; // Array of all players (index 0 = human player)
        this.discardPile = [];
        this.currentColor = null;
        this.currentValue = null;
        this.currentPlayerIndex = 0; // Index of current player
        this.gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        this.difficulty = 'medium';
        this.playerCount = 2; // Total players (human + computers)
        
        this.calledUno = []; // Track UNO calls for each player
        this.gameInProgress = false; // Prevent multiple simultaneous actions
        this.currentLanguage = localStorage.getItem('unoLanguage') || 'de';
        this.currentBackground = localStorage.getItem('unoBackground') || 'default';
        
        this.initializeElements();
        this.setupEventListeners();
        this.initializeLanguage();
        this.initializeBackground();
    }
    
    initializeElements() {
        // Screen elements
        this.startScreen = document.getElementById('startScreen');
        this.gameScreen = document.getElementById('gameScreen');
        
        // Game elements
        this.playerCardsContainer = document.getElementById('playerCards');
        this.playersContainer = document.getElementById('playersContainer');
        this.discardPileElement = document.getElementById('discardPile');
        this.drawPileElement = document.getElementById('drawPile');
        
        // UI elements
        this.currentTurnElement = document.getElementById('currentTurn');
        this.colorDisplay = document.getElementById('colorDisplay');
        this.drawCardBtn = document.getElementById('drawCard');
        this.callUnoBtn = document.getElementById('callUno');
        
        // Modals
        this.colorModal = document.getElementById('colorModal');
        this.gameOverModal = document.getElementById('gameOverModal');
        this.rulesModal = document.getElementById('rulesModal');
        this.settingsModal = document.getElementById('settingsModal');
        
        // Start screen elements
        this.playerCountButtons = document.querySelectorAll('.player-count-btn');
        this.difficultyButtons = document.querySelectorAll('.difficulty-btn');
        this.startGameBtn = document.getElementById('startGame');
        
        // Game control elements
        this.restartBtn = document.getElementById('restartButton');
        this.rulesBtn = document.getElementById('rulesButton');
        this.rulesBtnGame = document.getElementById('rulesButtonGame');
        
        // Language elements
        this.languageToggle = document.getElementById('languageToggle');
        this.languageMenu = document.getElementById('languageMenu');
        this.languageOptions = document.querySelectorAll('.language-option');
        this.currentFlag = document.querySelector('.current-flag');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settingsButton');
        this.backgroundOptions = document.querySelectorAll('.background-option');
    }
    
    setupEventListeners() {
        // Player count selection
        this.playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.playerCountButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.playerCount = parseInt(btn.dataset.players);
                this.checkStartButtonEnabled();
            });
        });
        
        // Difficulty selection
        this.difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.difficultyButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = btn.dataset.difficulty;
                this.checkStartButtonEnabled();
            });
        });
        
        // Start game
        this.startGameBtn.addEventListener('click', () => {
            this.startGame();
        });
        
        // Game actions
        this.drawCardBtn.addEventListener('click', () => {
            this.drawCard(0);
        });
        
        this.callUnoBtn.addEventListener('click', () => {
            this.callUno(0);
        });
        
        // Color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectColor(btn.dataset.color);
            });
        });
        
        // Play again
        document.getElementById('playAgain').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Restart button
        this.restartBtn.addEventListener('click', () => {
            if (confirm('M√∂chtest du das Spiel wirklich neu starten?')) {
                this.resetGame();
            }
        });
        
        // Rules button (start screen)
        this.rulesBtn.addEventListener('click', () => {
            this.showRules();
        });
        
        // Rules button (in game)
        this.rulesBtnGame.addEventListener('click', () => {
            this.showRules();
        });
        
        // Close rules modal
        document.getElementById('closeRules').addEventListener('click', () => {
            this.hideRules();
        });
        
        document.getElementById('closeRulesBtn').addEventListener('click', () => {
            this.hideRules();
        });
        
        // Language dropdown
        this.languageToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleLanguageMenu();
        });
        
        this.languageOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.switchLanguage(option.dataset.lang);
                this.hideLanguageMenu();
            });
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            this.hideLanguageMenu();
        });
        
        // Settings
        this.settingsBtn.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            this.hideSettings();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.hideSettings();
        });
        
        // Background selection
        this.backgroundOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeBackground(option.dataset.bg);
            });
        });
        
        // Draw pile click
        this.drawPileElement.addEventListener('click', () => {
            if (this.currentPlayerIndex === 0 && this.deck.length > 0) {
                this.drawCard(0);
            }
        });
    }
    
    checkStartButtonEnabled() {
        const playerCountSelected = Array.from(this.playerCountButtons).some(btn => btn.classList.contains('selected'));
        const difficultySelected = Array.from(this.difficultyButtons).some(btn => btn.classList.contains('selected'));
        this.startGameBtn.disabled = !(playerCountSelected && difficultySelected);
    }
    
    getRandomComputerName() {
        // Hole die Namen f√ºr die aktuelle Sprache
        const computerNames = this.computerNamesByLanguage[this.currentLanguage] || this.computerNamesByLanguage['de'];
        
        // Wenn alle Namen verwendet wurden, leere die Liste
        if (this.usedNames.length >= computerNames.length) {
            this.usedNames = [];
        }
        
        // W√§hle einen Namen, der noch nicht verwendet wurde
        let availableNames = computerNames.filter(name => !this.usedNames.includes(name));
        const randomIndex = Math.floor(Math.random() * availableNames.length);
        const selectedName = availableNames[randomIndex];
        
        // Markiere den Namen als verwendet
        this.usedNames.push(selectedName);
        
        return selectedName;
    }
    
    createDeck() {
        this.deck = [];
        
        // Number cards (0-9) - 0 has 1 of each color, 1-9 have 2 of each color
        this.colors.forEach(color => {
            this.deck.push({ color, value: '0', type: 'number' });
            for (let i = 1; i <= 9; i++) {
                this.deck.push({ color, value: i.toString(), type: 'number' });
                this.deck.push({ color, value: i.toString(), type: 'number' });
            }
        });
        
        // Action cards (2 of each per color)
        this.colors.forEach(color => {
            this.actions.forEach(action => {
                this.deck.push({ color, value: action, type: 'action' });
                this.deck.push({ color, value: action, type: 'action' });
            });
        });
        
        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
            this.deck.push({ color: 'wild', value: 'wild', type: 'wild' });
            this.deck.push({ color: 'wild', value: 'wild-draw-four', type: 'wild' });
        }
        
        this.shuffleDeck();
    }
    
    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }
    
    dealInitialCards() {
        // Initialize players array
        this.players = [];
        this.calledUno = [];
        
        for (let i = 0; i < this.playerCount; i++) {
            this.players[i] = [];
            this.calledUno[i] = false;
        }
        
        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < this.playerCount; j++) {
                this.players[j].push(this.deck.pop());
            }
        }
        
        // Place first card on discard pile (cannot be wild or action card)
        let firstCard;
        do {
            firstCard = this.deck.pop();
        } while (firstCard.type === 'wild' || firstCard.type === 'action');
        
        this.discardPile = [firstCard];
        this.currentColor = firstCard.color;
        this.currentValue = firstCard.value;
    }
    
    startGame() {
        this.startScreen.classList.add('hidden');
        this.gameScreen.classList.remove('hidden');
        
        this.createDeck();
        this.dealInitialCards();
        this.setupPlayersUI();
        this.currentPlayerIndex = 0;
        this.gameInProgress = true;
        this.updateUI();
        this.updateTurnDisplay();
        
        // Enable UNO button when human player has 2 cards
        this.updateUnoButton();
    }
    
    setupPlayersUI() {
        // Clear existing computer players
        this.playersContainer.innerHTML = '';
        
        // Reset used names for a new game
        this.usedNames = [];
        
        // Create computer player UI elements (skip index 0 = human player)
        for (let i = 1; i < this.playerCount; i++) {
            const computerName = this.getRandomComputerName();
            const playerDiv = document.createElement('div');
            playerDiv.className = 'computer-player';
            playerDiv.id = `player-${i}`;
            
            playerDiv.innerHTML = `
                <div class="player-info">
                    <h3>${computerName}</h3>
                    <div class="card-count">
                        <span id="cardCount-${i}">${this.players[i].length}</span>
                        <span class="cards-text">Karten</span>
                    </div>
                </div>
                <div class="computer-cards" id="computerCards-${i}">
                    <!-- Computer cards will be added here -->
                </div>
            `;
            
            this.playersContainer.appendChild(playerDiv);
            
            // Store the computer name for later use
            if (!this.computerPlayerNames) {
                this.computerPlayerNames = {};
            }
            this.computerPlayerNames[i] = computerName;
        }
    }
    
    resetGame() {
        this.gameInProgress = false; // Stop any ongoing actions
        this.gameOverModal.classList.add('hidden');
        this.gameScreen.classList.add('hidden');
        this.startScreen.classList.remove('hidden');
        
        // Reset game state
        this.calledUno = [];
        this.gameDirection = 1;
        this.currentPlayerIndex = 0;
        this.computerPlayerNames = {}; // Reset computer names
        this.usedNames = []; // Reset used names
        
        // Reset button states
        this.startGameBtn.disabled = true;
        this.playerCountButtons.forEach(btn => btn.classList.remove('selected'));
        this.difficultyButtons.forEach(btn => btn.classList.remove('selected'));
    }
    
    updateUI() {
        this.updatePlayerCards();
        this.updateComputerCards();
        this.updateDiscardPile();
        this.updateDrawPile();
        this.updateCardCounts();
        this.updateColorDisplay();
        this.updateActivePlayer();
    }
    
    updatePlayerCards() {
        this.playerCardsContainer.innerHTML = '';
        this.players[0].forEach((card, index) => {
            const cardElement = this.createCardElement(card, true);
            cardElement.addEventListener('click', () => {
                if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                    this.playCard(0, index);
                }
            });
            
            // Add playable highlight
            if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                cardElement.classList.add('playable');
            }
            
            this.playerCardsContainer.appendChild(cardElement);
        });
    }
    
    updateComputerCards() {
        for (let i = 1; i < this.playerCount; i++) {
            const computerCardsContainer = document.getElementById(`computerCards-${i}`);
            if (computerCardsContainer) {
                computerCardsContainer.innerHTML = '';
                this.players[i].forEach(() => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'computer-card';
                    computerCardsContainer.appendChild(cardElement);
                });
            }
        }
    }
    
    updateDiscardPile() {
        const topCard = this.discardPile[this.discardPile.length - 1];
        this.discardPileElement.innerHTML = '';
        const cardElement = this.createCardElement(topCard, true);
        this.discardPileElement.appendChild(cardElement);
    }
    
    updateDrawPile() {
        this.drawPileElement.innerHTML = '';
        
        if (this.deck.length > 0) {
            // Show card back when cards are available
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            this.drawPileElement.appendChild(cardBack);
            
            // Enable draw button
            this.drawCardBtn.disabled = false;
            this.drawPileElement.style.cursor = 'pointer';
        } else {
            // Show empty state when no cards left
            const emptyPile = document.createElement('div');
            emptyPile.className = 'empty-pile';
            emptyPile.innerHTML = '<span>Leer</span>';
            this.drawPileElement.appendChild(emptyPile);
            
            // Disable draw button and pile
            this.drawCardBtn.disabled = true;
            this.drawPileElement.style.cursor = 'not-allowed';
        }
    }
    
    updateCardCounts() {
        // Update card counts for all computer players
        for (let i = 1; i < this.playerCount; i++) {
            const cardCountElement = document.getElementById(`cardCount-${i}`);
            if (cardCountElement) {
                cardCountElement.textContent = this.players[i].length;
            }
        }
    }
    
    updateActivePlayer() {
        // Remove active class from all players
        for (let i = 1; i < this.playerCount; i++) {
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                playerElement.classList.remove('active');
            }
        }
        
        // Add active class to current player (if computer)
        if (this.currentPlayerIndex > 0) {
            const activePlayerElement = document.getElementById(`player-${this.currentPlayerIndex}`);
            if (activePlayerElement) {
                activePlayerElement.classList.add('active');
            }
        }
    }
    
    updateColorDisplay() {
        // Remove all color classes
        this.colorDisplay.className = 'color-display';
        
        // Add current color class
        if (this.currentColor && this.currentColor !== 'wild') {
            this.colorDisplay.classList.add(this.currentColor);
        }
    }
    
    updateTurnDisplay() {
        if (this.currentPlayerIndex === 0) {
            this.currentTurnElement.textContent = this.t('game.yourTurn');
            this.currentTurnElement.style.background = 'rgba(76, 175, 80, 0.9)';
        } else {
            const computerName = this.computerPlayerNames && this.computerPlayerNames[this.currentPlayerIndex] 
                ? this.computerPlayerNames[this.currentPlayerIndex] 
                : `Computer ${this.currentPlayerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerTurn', computerName);
            this.currentTurnElement.style.background = 'rgba(244, 67, 54, 0.9)';
        }
    }
    
    updateUnoButton() {
        // Enable UNO button when human player has exactly 2 cards and hasn't called UNO yet
        this.callUnoBtn.disabled = !(this.players[0].length === 2 && !this.calledUno[0]);
    }
    
    createCardElement(card, showFace = true) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.color}`;
        
        if (showFace) {
            if (card.type === 'number') {
                cardElement.innerHTML = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                const actionText = {
                    'skip': 'STOP',
                    'reverse': '‚ü≤',
                    'draw-two': '+2'
                };
                cardElement.innerHTML = `<span class="card-value">${actionText[card.value]}</span>`;
            } else if (card.type === 'wild') {
                const wildText = card.value === 'wild' ? 'WILD' : '+4';
                cardElement.innerHTML = `<span class="card-value">${wildText}</span>`;
            }
        }
        
        return cardElement;
    }
    
    canPlayCard(card) {
        // Wild cards can always be played
        if (card.type === 'wild') {
            return true;
        }
        
        // Regular cards must match color or value
        return card.color === this.currentColor || card.value === this.currentValue;
    }
    
    playCard(playerIndex, cardIndex) {
        const hand = this.players[playerIndex];
        const card = hand[cardIndex];
        
        if (!this.canPlayCard(card)) {
            return false;
        }
        
        // Remove card from hand and add to discard pile
        hand.splice(cardIndex, 1);
        this.discardPile.push(card);
        
        // Add playing animation
        if (playerIndex === 0) {
            const cardElements = this.playerCardsContainer.children;
            if (cardElements[cardIndex]) {
                cardElements[cardIndex].classList.add('playing');
            }
        }
        
        // Handle card effects
        this.handleCardEffect(card);
        
        // Update current color and value
        if (card.type === 'wild') {
            if (playerIndex === 0) {
                this.showColorSelector();
                return true; // Color selector will handle turn switching
            } else {
                // Computer chooses color
                this.currentColor = this.chooseColorForComputer();
                this.showComputerColorChoice();
                // Continue to handle card effects below
            }
        } else {
            this.currentColor = card.color;
        }
        this.currentValue = card.value;
        
        // Check for win condition
        if (hand.length === 0) {
            this.endGame(playerIndex);
            return true;
        }
        
        // Check UNO call requirement
        if (hand.length === 1) {
            if (playerIndex === 0 && !this.calledUno[0]) {
                // Player forgot to call UNO - penalty
                this.penalizePlayer(0);
            } else if (playerIndex > 0 && !this.calledUno[playerIndex]) {
                // Computer calls UNO automatically
                this.callUno(playerIndex);
            }
        }
        
        // Update UI
        this.updateUI();
        this.updateUnoButton();
        
        // Switch turns (card effects handle their own turn logic)
        if (card.value === 'skip' || card.value === 'reverse' || 
            card.value === 'draw-two' || card.value === 'wild-draw-four' || 
            card.value === 'wild') {
            // Action cards and wild cards handle their own turn switching
            return true;
        } else {
            // Regular number cards
            this.switchTurns();
        }
        
        return true;
    }
    
    handleCardEffect(card) {
        switch (card.value) {
            case 'skip':
                // Skip next player's turn - switch twice to skip them
                this.switchTurns(); // Go to next player
                this.switchTurns(); // Skip that player
                break;
                
            case 'reverse':
                this.gameDirection *= -1;
                // In 2-player game, reverse acts like skip
                if (this.playerCount === 2) {
                    this.switchTurns(); // Go to next player
                    this.switchTurns(); // Skip that player (reverse effect)
                } else {
                    this.switchTurns(); // Just change direction
                }
                break;
                
            case 'draw-two':
                const drawTwoTarget = this.getNextPlayerIndex();
                this.drawCards(drawTwoTarget, 2);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild-draw-four':
                const drawFourTarget = this.getNextPlayerIndex();
                this.drawCards(drawFourTarget, 4);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild':
                // Regular wild card - just switch turns normally
                this.switchTurns();
                break;
        }
    }
    
    drawCard(playerIndex) {
        if (this.deck.length === 0) {
            this.reshuffleDeck();
        }
        
        // Check if we still have no cards after reshuffling (shouldn't happen normally)
        if (this.deck.length === 0) {
            console.warn('No cards available to draw!');
            return;
        }
        
        const card = this.deck.pop();
        this.players[playerIndex].push(card);
        
        this.updateUI();
        this.updateUnoButton();
        
        // Reset UNO call status when drawing cards
        this.calledUno[playerIndex] = false;
        
        // After drawing, human player auto-ends turn, computer continues
        if (playerIndex === 0 && this.currentPlayerIndex === 0) {
            // Auto-end human turn after drawing
            setTimeout(() => {
                if (this.currentPlayerIndex === 0) { // Double-check we're still on human turn
                    this.switchTurns();
                }
            }, 1000);
        }
    }
    
    drawCards(playerIndex, count) {
        for (let i = 0; i < count; i++) {
            this.drawCard(playerIndex);
        }
    }
    
    reshuffleDeck() {
        // Keep top card of discard pile, shuffle the rest back into deck
        const topCard = this.discardPile.pop();
        this.deck = [...this.discardPile];
        this.discardPile = [topCard];
        this.shuffleDeck();
    }
    
    getNextPlayerIndex() {
        let nextIndex = this.currentPlayerIndex + this.gameDirection;
        if (nextIndex >= this.playerCount) {
            nextIndex = 0;
        } else if (nextIndex < 0) {
            nextIndex = this.playerCount - 1;
        }
        return nextIndex;
    }
    
    switchTurns() {
        if (!this.gameInProgress) {
            return; // Game ended, don't continue
        }
        
        this.currentPlayerIndex = this.getNextPlayerIndex();
        this.updateTurnDisplay();
        this.updateUI();
        
        if (this.currentPlayerIndex > 0) {
            // Computer's turn
            setTimeout(() => {
                if (this.gameInProgress && this.currentPlayerIndex > 0) {
                    this.computerPlay();
                }
            }, 1500); // Delay for realism
        }
    }
    
    computerPlay() {
        // Safety check - make sure it's actually a computer's turn
        if (this.currentPlayerIndex === 0) {
            console.warn('computerPlay called but it\'s human player\'s turn!');
            return;
        }
        
        const playerIndex = this.currentPlayerIndex;
        const playableCards = this.players[playerIndex]
            .map((card, index) => ({ card, index }))
            .filter(({ card }) => this.canPlayCard(card));
        
        if (playableCards.length > 0) {
            const chosenCard = this.chooseCardForComputer(playableCards, playerIndex);
            this.playCard(playerIndex, chosenCard.index);
        } else {
            // Must draw a card
            this.drawCard(playerIndex);
            // Only switch turns if we're still at the same player (draw didn't trigger other effects)
            if (this.currentPlayerIndex === playerIndex) {
                this.switchTurns();
            }
        }
    }
    
    chooseCardForComputer(playableCards, playerIndex) {
        switch (this.difficulty) {
            case 'easy':
                return this.chooseCardEasy(playableCards, playerIndex);
            case 'medium':
                return this.chooseCardMedium(playableCards, playerIndex);
            case 'hard':
                return this.chooseCardHard(playableCards, playerIndex);
            default:
                return playableCards[0];
        }
    }
    
    chooseCardEasy(playableCards, playerIndex) {
        // Easy: Random selection, prefers regular cards over action cards
        const regularCards = playableCards.filter(({ card }) => card.type === 'number');
        const actionCards = playableCards.filter(({ card }) => card.type === 'action');
        const wildCards = playableCards.filter(({ card }) => card.type === 'wild');
        
        if (regularCards.length > 0 && Math.random() < 0.7) {
            return regularCards[Math.floor(Math.random() * regularCards.length)];
        } else if (actionCards.length > 0 && Math.random() < 0.6) {
            return actionCards[Math.floor(Math.random() * actionCards.length)];
        } else if (wildCards.length > 0) {
            return wildCards[Math.floor(Math.random() * wildCards.length)];
        }
        
        return playableCards[Math.floor(Math.random() * playableCards.length)];
    }
    
    chooseCardMedium(playableCards, playerIndex) {
        // Medium: Balanced strategy, considers card effects
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Check if human player has few cards
        const humanPlayerLowCards = this.players[0].length <= 3;
        
        // Prefer action cards when advantageous
        if (actionCards.length > 0 && humanPlayerLowCards) {
            const preferredActions = actionCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'skip'
            );
            if (preferredActions.length > 0) {
                return preferredActions[0];
            }
        }
        
        // Use wild cards strategically
        if (wildCards.length > 0 && this.players[playerIndex].length <= 2) {
            return wildCards[0];
        }
        
        // Otherwise prefer regular cards
        if (regularCards.length > 0) {
            return regularCards[0];
        }
        
        return playableCards[0];
    }
    
    chooseCardHard(playableCards, playerIndex) {
        // Hard: Advanced strategy, considers multiple factors
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Aggressive play when human player has few cards
        if (this.players[0].length <= 2) {
            const drawCards = playableCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'wild-draw-four'
            );
            if (drawCards.length > 0) {
                // Prefer wild-draw-four over draw-two
                const wildDrawFour = drawCards.find(({ card }) => card.value === 'wild-draw-four');
                return wildDrawFour || drawCards[0];
            }
            
            // Skip player's turn
            const skipCards = actionCards.filter(({ card }) => card.value === 'skip');
            if (skipCards.length > 0) {
                return skipCards[0];
            }
        }
        
        // Color management strategy
        const colorCounts = this.countColorsByFrequency(playerIndex);
        const bestColorCards = regularCards.filter(({ card }) => 
            card.color === colorCounts[0]?.color
        );
        
        if (bestColorCards.length > 0) {
            return bestColorCards[0];
        }
        
        // Save wild cards for last resort unless hand is small
        if (this.players[playerIndex].length <= 3 && wildCards.length > 0) {
            return wildCards[0];
        }
        
        // Default to first available card
        return regularCards[0] || actionCards[0] || wildCards[0] || playableCards[0];
    }
    
    categorizeCards(playableCards) {
        return {
            regularCards: playableCards.filter(({ card }) => card.type === 'number'),
            actionCards: playableCards.filter(({ card }) => card.type === 'action'),
            wildCards: playableCards.filter(({ card }) => card.type === 'wild')
        };
    }
    
    countColorsByFrequency(playerIndex) {
        const colorCounts = {};
        this.players[playerIndex].forEach(card => {
            if (card.color !== 'wild') {
                colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
        });
        
        return Object.entries(colorCounts)
            .map(([color, count]) => ({ color, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    chooseColorForComputer() {
        const colorCounts = this.countColorsByFrequency();
        return colorCounts.length > 0 ? colorCounts[0].color : this.colors[Math.floor(Math.random() * this.colors.length)];
    }
    
    showColorSelector() {
        this.colorModal.classList.remove('hidden');
    }
    
    selectColor(color) {
        this.currentColor = color;
        this.colorModal.classList.add('hidden');
        this.updateUI();
        this.switchTurns();
    }
    
    showComputerColorChoice() {
        // Show feedback about computer's color choice
        const colorNames = {
            'red': 'Rot',
            'blue': 'Blau', 
            'green': 'Gr√ºn',
            'yellow': 'Gelb'
        };
        
        const colorName = colorNames[this.currentColor];
        const originalText = this.currentTurnElement.textContent;
        
        this.currentTurnElement.textContent = `Computer w√§hlt: ${colorName}`;
        this.currentTurnElement.style.background = 'rgba(255, 193, 7, 0.9)';
        
        setTimeout(() => {
            this.updateTurnDisplay();
        }, 2000);
    }
    
    callUno(playerIndex) {
        this.calledUno[playerIndex] = true;
        
        if (playerIndex === 0) {
            this.callUnoBtn.disabled = true;
            
            // Show feedback
            this.currentTurnElement.textContent = this.t('game.unoCalled');
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        } else {
            // Show computer UNO call
            const computerName = this.computerPlayerNames && this.computerPlayerNames[playerIndex] 
                ? this.computerPlayerNames[playerIndex] 
                : `Computer ${playerIndex}`;
            this.currentTurnElement.textContent = this.t('game.computerCallsUno', computerName);
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        }
    }
    
    penalizePlayer(playerIndex) {
        // Draw 2 penalty cards for not calling UNO
        this.drawCards(playerIndex, 2);
        
        if (playerIndex === 0) {
            this.currentTurnElement.textContent = 'UNO vergessen! +2 Karten';
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 2000);
        }
    }
    
    endGame(winnerIndex) {
        this.gameInProgress = false; // Stop all game actions
        
        const gameResult = document.getElementById('gameResult');
        const gameResultText = document.getElementById('gameResultText');
        
        if (winnerIndex === 0) {
            gameResult.textContent = this.t('game.won');
            gameResult.style.color = '#4caf50';
            gameResultText.textContent = this.t('game.wonText');
        } else {
            gameResult.textContent = this.t('game.lost');
            gameResult.style.color = '#f44336';
            const computerName = this.computerPlayerNames && this.computerPlayerNames[winnerIndex] 
                ? this.computerPlayerNames[winnerIndex] 
                : `Computer ${winnerIndex}`;
            gameResultText.textContent = this.t('game.lostText', computerName);
        }
        
        this.gameOverModal.classList.remove('hidden');
    }
    
    showRules() {
        this.rulesModal.classList.remove('hidden');
    }
    
    hideRules() {
        this.rulesModal.classList.add('hidden');
    }
    
    // Language System
    initializeLanguage() {
        this.updateLanguageDisplay();
        this.updateAllTexts();
    }
    
    switchLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('unoLanguage', lang);
        this.updateLanguageDisplay();
        this.updateAllTexts();
        
        // Wenn ein Spiel l√§uft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
    }
    
    regenerateComputerNames() {
        // Reset verwendet Namen und generiere neue Namen f√ºr alle Computer
        this.usedNames = [];
        for (let i = 1; i < this.playerCount; i++) {
            const newName = this.getRandomComputerName();
            this.computerPlayerNames[i] = newName;
            
            // Update UI
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                const nameElement = playerElement.querySelector('.player-info h3');
                if (nameElement) {
                    nameElement.textContent = newName;
                }
            }
        }
        
        // Update turn display with new names
        this.updateTurnDisplay();
    }
    
    toggleLanguageMenu() {
        this.languageMenu.classList.toggle('hidden');
        this.languageToggle.classList.toggle('open');
    }
    
    hideLanguageMenu() {
        this.languageMenu.classList.add('hidden');
        this.languageToggle.classList.remove('open');
    }
    
    updateLanguageDisplay() {
        // Update current flag in toggle button
        const languageFlags = {
            'de': 'üá©üá™',
            'en': 'üá¨üáß', 
            'es': 'üá™üá∏',
            'fr': 'üá´üá∑',
            'pt': 'üáßüá∑',
            'ja': 'üáØüáµ',
            'zh': 'üá®üá≥',
            'hu': 'üá≠üá∫',
            'ru': 'üá∑üá∫'
        };
        
        this.currentFlag.textContent = languageFlags[this.currentLanguage] || 'üá©üá™';
        
        // Update active state in dropdown
        this.languageOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.lang === this.currentLanguage);
        });
    }
    
    t(key, ...args) {
        const translation = translations[this.currentLanguage]?.[key] || translations['de'][key] || key;
        return args.length > 0 ? this.formatString(translation, ...args) : translation;
    }
    
    formatString(str, ...args) {
        return str.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
    }
    
    updateAllTexts() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = this.t(key);
        });
        
        // Update dynamic texts if game is running
        if (this.gameInProgress) {
            this.updateTurnDisplay();
        }
    }
    
    // Settings System
    showSettings() {
        this.settingsModal.classList.remove('hidden');
    }
    
    hideSettings() {
        this.settingsModal.classList.add('hidden');
    }
    
    initializeBackground() {
        this.applyBackground(this.currentBackground);
        this.updateBackgroundOptions();
    }
    
    changeBackground(bgName) {
        this.currentBackground = bgName;
        localStorage.setItem('unoBackground', bgName);
        this.applyBackground(bgName);
        this.updateBackgroundOptions();
    }
    
    applyBackground(bgName) {
        // Remove all background classes
        document.body.className = document.body.className.replace(/bg-\w+/g, '');
        // Add new background class
        document.body.classList.add(`bg-${bgName}`);
    }
    
    updateBackgroundOptions() {
        this.backgroundOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.bg === this.currentBackground);
        });
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new UnoGame();
});
