// Translations
const translations = {
    de: {
        game: {
            title: "UNO",
            currentColor: "Aktuelle Farbe:",
            yourTurn: "Dein Zug",
            drawCard: "Karte ziehen",
            uno: "UNO!",
            chooseColor: "Farbe wählen:",
            playAgain: "Nochmal spielen"
        },
        start: {
            playerCount: "Anzahl Computer-Gegner:",
            players2: "Du + 1 Computer",
            players3: "Du + 2 Computer",
            players4: "Du + 3 Computer",
            difficulty: "Schwierigkeitsgrad wählen:",
            rules: "Spielregeln",
            startGame: "Spiel starten"
        },
        difficulty: {
            easy: "Einfach",
            easyDesc: "Defensiver Computer",
            medium: "Mittel",
            mediumDesc: "Ausgewogener Computer",
            hard: "Schwer",
            hardDesc: "Strategischer Computer"
        },
        settings: {
            title: "Einstellungen",
            background: "🎨 Hintergrund",
            cardTheme: "🎮 Karten-Theme",
            bg: {
                default: "Standard",
                ocean: "Ozean",
                sunset: "Sonnenuntergang",
                forest: "Wald",
                space: "Weltraum",
                gradient: "Farbverlauf"
            },
            theme: {
                classic: "Klassisch",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Fertig",
            version: "Version 1.0.0"
        }
    },
    en: {
        game: {
            title: "UNO",
            currentColor: "Current Color:",
            yourTurn: "Your Turn",
            drawCard: "Draw Card",
            uno: "UNO!",
            chooseColor: "Choose Color:",
            playAgain: "Play Again"
        },
        start: {
            playerCount: "Number of Computer Opponents:",
            players2: "You + 1 Computer",
            players3: "You + 2 Computers",
            players4: "You + 3 Computers",
            difficulty: "Choose Difficulty:",
            rules: "Rules",
            startGame: "Start Game"
        },
        difficulty: {
            easy: "Easy",
            easyDesc: "Defensive Computer",
            medium: "Medium",
            mediumDesc: "Balanced Computer",
            hard: "Hard",
            hardDesc: "Strategic Computer"
        },
        settings: {
            title: "Settings",
            background: "🎨 Background",
            cardTheme: "🎮 Card Theme",
            bg: {
                default: "Default",
                ocean: "Ocean",
                sunset: "Sunset",
                forest: "Forest",
                space: "Space",
                gradient: "Gradient"
            },
            theme: {
                classic: "Classic",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Done",
            version: "Version 1.0.0"
        }
    },
    es: {
        game: {
            title: "UNO",
            currentColor: "Color Actual:",
            yourTurn: "Tu Turno",
            drawCard: "Robar Carta",
            uno: "¡UNO!",
            chooseColor: "Elegir Color:",
            playAgain: "Jugar de Nuevo"
        },
        start: {
            playerCount: "Número de Oponentes Informáticos:",
            players2: "Tú + 1 Computadora",
            players3: "Tú + 2 Computadoras",
            players4: "Tú + 3 Computadoras",
            difficulty: "Elegir Dificultad:",
            rules: "Reglas",
            startGame: "Iniciar Juego"
        },
        difficulty: {
            easy: "Fácil",
            easyDesc: "Computadora Defensiva",
            medium: "Medio",
            mediumDesc: "Computadora Equilibrada",
            hard: "Difícil",
            hardDesc: "Computadora Estratégica"
        },
        settings: {
            title: "Configuración",
            background: "🎨 Fondo",
            cardTheme: "🎮 Tema de Cartas",
            bg: {
                default: "Predeterminado",
                ocean: "Océano",
                sunset: "Atardecer",
                forest: "Bosque",
                space: "Espacio",
                gradient: "Degradado"
            },
            theme: {
                classic: "Clásico",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Hecho",
            version: "Versión 1.0.0"
        }
    },
    fr: {
        game: {
            title: "UNO",
            currentColor: "Couleur Actuelle:",
            yourTurn: "Votre Tour",
            drawCard: "Piocher une Carte",
            uno: "UNO!",
            chooseColor: "Choisir la Couleur:",
            playAgain: "Rejouer"
        },
        start: {
            playerCount: "Nombre d'Adversaires Informatiques:",
            players2: "Vous + 1 Ordinateur",
            players3: "Vous + 2 Ordinateurs",
            players4: "Vous + 3 Ordinateurs",
            difficulty: "Choisir la Difficulté:",
            rules: "Règles",
            startGame: "Commencer le Jeu"
        },
        difficulty: {
            easy: "Facile",
            easyDesc: "Ordinateur Défensif",
            medium: "Moyen",
            mediumDesc: "Ordinateur Équilibré",
            hard: "Difficile",
            hardDesc: "Ordinateur Stratégique"
        },
        settings: {
            title: "Paramètres",
            background: "🎨 Arrière-plan",
            cardTheme: "🎮 Thème de Cartes",
            bg: {
                default: "Par Défaut",
                ocean: "Océan",
                sunset: "Coucher de Soleil",
                forest: "Forêt",
                space: "Espace",
                gradient: "Dégradé"
            },
            theme: {
                classic: "Classique",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Rétro"
            },
            close: "Terminé",
            version: "Version 1.0.0"
        }
    },
    pt: {
        game: {
            title: "UNO",
            currentColor: "Cor Atual:",
            yourTurn: "Sua Vez",
            drawCard: "Comprar Carta",
            uno: "UNO!",
            chooseColor: "Escolher Cor:",
            playAgain: "Jogar Novamente"
        },
        start: {
            playerCount: "Número de Oponentes Informáticos:",
            players2: "Você + 1 Computador",
            players3: "Você + 2 Computadores",
            players4: "Você + 3 Computadores",
            difficulty: "Escolher Dificuldade:",
            rules: "Regras",
            startGame: "Iniciar Jogo"
        },
        difficulty: {
            easy: "Fácil",
            easyDesc: "Computador Defensivo",
            medium: "Médio",
            mediumDesc: "Computador Equilibrado",
            hard: "Difícil",
            hardDesc: "Computador Estratégico"
        },
        settings: {
            title: "Configurações",
            background: "🎨 Fundo",
            cardTheme: "🎮 Tema de Cartas",
            bg: {
                default: "Padrão",
                ocean: "Oceano",
                sunset: "Pôr do Sol",
                forest: "Floresta",
                space: "Espaço",
                gradient: "Gradiente"
            },
            theme: {
                classic: "Clássico",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retrô"
            },
            close: "Concluído",
            version: "Versão 1.0.0"
        }
    },
    ja: {
        game: {
            title: "UNO",
            currentColor: "現在の色:",
            yourTurn: "あなたの番",
            drawCard: "カードを引く",
            uno: "UNO!",
            chooseColor: "色を選択:",
            playAgain: "もう一度プレイ"
        },
        start: {
            playerCount: "コンピューター対戦相手の数:",
            players2: "あなた + 1台のコンピューター",
            players3: "あなた + 2台のコンピューター",
            players4: "あなた + 3台のコンピューター",
            difficulty: "難易度を選択:",
            rules: "ルール",
            startGame: "ゲーム開始"
        },
        difficulty: {
            easy: "簡単",
            easyDesc: "防御的なコンピューター",
            medium: "普通",
            mediumDesc: "バランスの取れたコンピューター",
            hard: "難しい",
            hardDesc: "戦略的なコンピューター"
        },
        settings: {
            title: "設定",
            background: "🎨 背景",
            cardTheme: "🎮 カードテーマ",
            bg: {
                default: "デフォルト",
                ocean: "海",
                sunset: "夕日",
                forest: "森",
                space: "宇宙",
                gradient: "グラデーション"
            },
            theme: {
                classic: "クラシック",
                minecraft: "マインクラフト",
                mario: "マリオ",
                pokemon: "ポケモン",
                cyberpunk: "サイバーパンク",
                retro: "レトロ"
            },
            close: "完了",
            version: "バージョン 1.0.0"
        }
    },
    hu: {
        game: {
            title: "UNO",
            currentColor: "Jelenlegi Szín:",
            yourTurn: "Te Vagy",
            drawCard: "Kártya Húzása",
            uno: "UNO!",
            chooseColor: "Szín Választása:",
            playAgain: "Újra Játszás"
        },
        start: {
            playerCount: "Számítógépes Ellenfelek Száma:",
            players2: "Te + 1 Számítógép",
            players3: "Te + 2 Számítógép",
            players4: "Te + 3 Számítógép",
            difficulty: "Nehézség Választása:",
            rules: "Szabályok",
            startGame: "Játék Indítása"
        },
        difficulty: {
            easy: "Könnyű",
            easyDesc: "Védekező Számítógép",
            medium: "Közepes",
            mediumDesc: "Kiegyensúlyozott Számítógép",
            hard: "Nehéz",
            hardDesc: "Stratégiai Számítógép"
        },
        settings: {
            title: "Beállítások",
            background: "🎨 Háttér",
            cardTheme: "🎮 Kártya Téma",
            bg: {
                default: "Alapértelmezett",
                ocean: "Óceán",
                sunset: "Naplemente",
                forest: "Erdő",
                space: "Űr",
                gradient: "Átmenet"
            },
            theme: {
                classic: "Klasszikus",
                minecraft: "Minecraft",
                mario: "Mario",
                pokemon: "Pokemon",
                cyberpunk: "Cyberpunk",
                retro: "Retro"
            },
            close: "Kész",
            version: "Verzió 1.0.0"
        }
    },
    ru: {
        game: {
            title: "UNO",
            currentColor: "Текущий Цвет:",
            yourTurn: "Ваш Ход",
            drawCard: "Взять Карту",
            uno: "УНО!",
            chooseColor: "Выбрать Цвет:",
            playAgain: "Играть Снова"
        },
        start: {
            playerCount: "Количество Компьютерных Противников:",
            players2: "Вы + 1 Компьютер",
            players3: "Вы + 2 Компьютера",
            players4: "Вы + 3 Компьютера",
            difficulty: "Выбрать Сложность:",
            rules: "Правила",
            startGame: "Начать Игру"
        },
        difficulty: {
            easy: "Легко",
            easyDesc: "Защитный Компьютер",
            medium: "Средне",
            mediumDesc: "Сбалансированный Компьютер",
            hard: "Сложно",
            hardDesc: "Стратегический Компьютер"
        },
        settings: {
            title: "Настройки",
            background: "🎨 Фон",
            cardTheme: "🎮 Тема Карт",
            bg: {
                default: "По Умолчанию",
                ocean: "Океан",
                sunset: "Закат",
                forest: "Лес",
                space: "Космос",
                gradient: "Градиент"
            },
            theme: {
                classic: "Классическая",
                minecraft: "Майнкрафт",
                mario: "Марио",
                pokemon: "Покемон",
                cyberpunk: "Киберпанк",
                retro: "Ретро"
            },
            close: "Готово",
            version: "Версия 1.0.0"
        }
    },
    zh: {
        game: {
            title: "UNO",
            currentColor: "当前颜色:",
            yourTurn: "你的回合",
            drawCard: "抽卡",
            uno: "UNO!",
            chooseColor: "选择颜色:",
            playAgain: "再玩一次"
        },
        start: {
            playerCount: "电脑对手数量:",
            players2: "你 + 1个电脑",
            players3: "你 + 2个电脑",
            players4: "你 + 3个电脑",
            difficulty: "选择难度:",
            rules: "规则",
            startGame: "开始游戏"
        },
        difficulty: {
            easy: "简单",
            easyDesc: "防御型电脑",
            medium: "中等",
            mediumDesc: "平衡型电脑",
            hard: "困难",
            hardDesc: "策略型电脑"
        },
        settings: {
            title: "设置",
            background: "🎨 背景",
            cardTheme: "🎮 卡牌主题",
            bg: {
                default: "默认",
                ocean: "海洋",
                sunset: "日落",
                forest: "森林",
                space: "太空",
                gradient: "渐变"
            },
            theme: {
                classic: "经典",
                minecraft: "我的世界",
                mario: "马里奥",
                pokemon: "宝可梦",
                cyberpunk: "赛博朋克",
                retro: "复古"
            },
            close: "完成",
            version: "版本 1.0.0"
        }
    }
};

// Initialize language
let currentLanguage = localStorage.getItem('unoLanguage') || 'de';

// Function to translate text based on current language
function t(key, ...args) {
    const translation = translations[currentLanguage]?.[key] || translations['de'][key] || key;
    return args.length > 0 ? formatString(translation, ...args) : translation;
}

function formatString(str, ...args) {
    return str.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
}

// UNO Game Implementation
class UnoGame {
    constructor() {
        this.colors = ['red', 'blue', 'green', 'yellow'];
        this.numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.actions = ['skip', 'reverse', 'draw-two'];
        this.wilds = ['wild', 'wild-draw-four'];
        
        // Lustige Computer-Namen nach Sprachen
        this.computerNamesByLanguage = {
            de: [
                'KartenKaiser', 'UnoUlrich', 'BlitzBerta', 'TurboTina', 'MegaMax',
                'FlitzerFritz', 'ZaubererZoe', 'RaketenRudi', 'SuperSusi', 'BlitzerBob',
                'GigaGerta', 'TurbineTom', 'FlashFiona', 'BoosterBruno', 'ZoomZara',
                'SpeediSepp', 'RaserRita', 'TurboTeddy', 'FlitzerFee', 'RocketRalf',
                'UnoUlla', 'KartenKurt', 'BlitzBrigitte', 'PowerPaul', 'MegaMaria',
                'TurboThomas', 'SpeedySandra', 'FlashFelix', 'ZoomZoe', 'RaketaRose',
                'SuperSchnecke', 'BlitzBirne', 'TurboTomate', 'FlitzerFisch', 'UnoUhu',
                'KartenKaktus', 'BlitzBanane', 'PowerPinguin', 'MegaMaulwurf', 'TurboTiger'
            ],
            en: [
                'CardKing', 'UnoUnicorn', 'FlashFred', 'TurboTom', 'MegaMax',
                'SpeedySpike', 'WizardWanda', 'RocketRob', 'SuperSam', 'BlitzBella',
                'GigaGrace', 'TurboTed', 'FlashFiona', 'BoosterBen', 'ZoomZoe',
                'QuickQuinn', 'RushRuby', 'TurboTerry', 'FlashFay', 'RocketRyan',
                'UnoUrsula', 'CardCarl', 'BlitzBrian', 'PowerPat', 'MegaMia',
                'TurboTracy', 'SpeedySarah', 'FlashFinn', 'ZoomZack', 'RocketRose',
                'SuperSnail', 'BlitzBerry', 'TurboTomato', 'FlashFish', 'UnoOwl',
                'CardCactus', 'BlitzBanana', 'PowerPenguin', 'MegaMole', 'TurboTiger'
            ],
            hu: [
                'KártyaKirály', 'UnoUnikorn', 'VillámVilma', 'TurbóTamás', 'MegaMarci',
                'SebességiSzabi', 'VarázslóVera', 'RakétaRóbert', 'SzuperSzilvi', 'VillámViktor',
                'GigaGabi', 'TurbóTibor', 'VillámVanda', 'ErősítőErnő', 'ZoomZoltán',
                'GyorsGergő', 'RohamnéRita', 'TurbóTünde', 'VillámVivien', 'RakétaRéka',
                'UnoÚrsula', 'KártyaKálmán', 'VillámViktor', 'ErősErika', 'MegaMónika',
                'TurbóTeréz', 'GyorsSzandra', 'VillámFerenc', 'ZoomZsuzsa', 'RakétaRózsa',
                'SzuperCsiga', 'VillámBogyó', 'TurbóParadicsom', 'VillámHal', 'UnoBagoly',
                'KártyaKaktusz', 'VillámBanán', 'ErősPingvin', 'MegaVakond', 'TurbóTigris'
            ],
            ru: [
                'КарточныйКороль', 'УноЮникорн', 'МолнияМаша', 'ТурбоТоня', 'МегаМакс',
                'СкоростнойСергей', 'ВолшебникВера', 'РакетаРоман', 'СуперСаша', 'МолнияМиша',
                'ГигаГалина', 'ТурбоТимур', 'МолнияВанда', 'БустерБорис', 'ЗумЗоя',
                'БыстрыйБорис', 'СпешкаСвета', 'ТурбоТатьяна', 'МолнияВиктор', 'РакетаРита',
                'УноУльяна', 'КарточныйКостя', 'МолнияМарина', 'СилаСергей', 'МегаМария',
                'ТурбоТаня', 'СкорыйСаша', 'МолнияФёдор', 'ЗумЗинаида', 'РакетаРоза',
                'СуперУлитка', 'МолнияЯгода', 'ТурбоПомидор', 'МолнияРыба', 'УноСова',
                'КарточныйКактус', 'МолнияБанан', 'СильныйПингвин', 'МегаКрот', 'ТурбоТигр'
            ],
            es: [
                'ReyCartas', 'UnoUnicornio', 'RelámpagoRosa', 'TurboTeo', 'MegaMax',
                'VelocidadVera', 'MagoMario', 'CoheteCarlos', 'SuperSofia', 'RelámpagoRafa',
                'GigaGloria', 'TurboTomás', 'FlashFrancisca', 'BoosterBenji', 'ZoomZara',
                'RápidoRicardo', 'PrisaPatricia', 'TurboTere', 'FlashFelipe', 'CoheteClara',
                'UnoUrsula', 'CartasCarmen', 'RelámpagoRoberto', 'PoderPablo', 'MegaMaría',
                'TurboTania', 'VeloceSandra', 'FlashFernando', 'ZoomZoe', 'CoheteRosa',
                'SuperCaracol', 'RelámpagoUva', 'TurboTomate', 'FlashPez', 'UnoBúho',
                'CartasCactus', 'RelámpagoPlatano', 'PoderPingüino', 'MegaTopo', 'TurboTigre'
            ],
            fr: [
                'RoiCartes', 'UnoLicorne', 'ÉclairÉmilie', 'TurboThéo', 'MégaMax',
                'VitesseVictor', 'MagicienMarcel', 'FuséeFrançoise', 'SuperSylvie', 'ÉclairÉric',
                'GigaGabrielle', 'TurboThomas', 'FlashFanny', 'BoosterBenjamin', 'ZoomZoé',
                'RapideRaymond', 'PressePauline', 'TurboThérèse', 'FlashFabien', 'FuséeClaire',
                'UnoUrsule', 'CartesClément', 'ÉclairRenée', 'PouvoirPierre', 'MégaMarie',
                'TurboTanya', 'VéloceSandra', 'FlashFélix', 'ZoomZacharie', 'FuséeRose',
                'SuperEscargot', 'ÉclairRaisin', 'TurboTomate', 'FlashPoisson', 'UnoHibou',
                'CartesCactus', 'ÉclairBanane', 'PouvoirPingouin', 'MégaTaupe', 'TurboTigre'
            ],
            pt: [
                'ReiCartas', 'UnoUnicórnio', 'RelâmpagoRita', 'TurboTiago', 'MegaMax',
                'VelocidadeVera', 'MágicoMário', 'FogueteFelix', 'SuperSônia', 'RelâmpagoRafa',
                'GigaGisele', 'TurboTomás', 'FlashFernanda', 'BoosterBruno', 'ZoomZara',
                'RápidoRicardo', 'PressaPatrícia', 'TurboTina', 'FlashFábio', 'FogueteClara',
                'UnoÚrsula', 'CartasCarlos', 'RelâmpagoRenata', 'PoderPaulo', 'MegaMaria',
                'TurboTânia', 'VelozSandra', 'FlashFernando', 'ZoomZé', 'FogueteRosa',
                'SuperCaracol', 'RelâmpagoUva', 'TurboTomate', 'FlashPeixe', 'UnoCoruja',
                'CartasCacto', 'RelâmpagoBanana', 'PoderPinguim', 'MegaToupeira', 'TurboTigre'
            ],
            ja: [
                'カードキング', 'ウノユニコーン', 'イナズマアイ', 'ターボタロウ', 'メガマックス',
                'スピードサトシ', 'マジシャンミカ', 'ロケットリョウ', 'スーパーサキ', 'イナズマイチロウ',
                'ギガゴロウ', 'ターボタカシ', 'フラッシュフミ', 'ブースターベン', 'ズームゾエ',
                'クイックケンジ', 'ラッシュリカ', 'ターボテル', 'フラッシュフミオ', 'ロケットリナ',
                'ウノウララ', 'カードケン', 'イナズマイズミ', 'パワーポン', 'メガマミ',
                'ターボタミ', 'スピーディサチ', 'フラッシュフジ', 'ズームゼン', 'ロケットローズ',
                'スーパーカタツムリ', 'イナズマイチゴ', 'ターボトマト', 'フラッシュフィッシュ', 'ウノフクロウ',
                'カードカクタス', 'イナズマバナナ', 'パワーペンギン', 'メガモグラ', 'ターボトラ'
            ],
            zh: [
                '卡牌之王', '乌诺独角兽', '闪电丽丽', '涡轮小明', '超级麦克斯',
                '速度小薇', '魔法师马里奥', '火箭小飞', '超级小苏', '闪电小强',
                '千兆小刚', '涡轮小涛', '闪光小芳', '助推器小本', '缩放小柔',
                '快速小瑞', '匆忙小佩', '涡轮小婷', '闪光小飞', '火箭小克',
                '乌诺小雨', '卡牌小陈', '闪电小蕾', '力量小保', '超级小玛',
                '涡轮小谭', '快速小桑', '闪光小峰', '缩放小泽', '火箭小蔷',
                '超级蜗牛', '闪电葡萄', '涡轮番茄', '闪光小鱼', '乌诺猫头鹰',
                '卡牌仙人掌', '闪电香蕉', '力量企鹅', '超级鼹鼠', '涡轮老虎'
            ]
        };
        this.usedNames = [];  // Bereits verwendete Namen in diesem Spiel
        
        this.deck = [];
        this.players = []; // Array of all players (index 0 = human player)
        this.discardPile = [];
        this.currentColor = null;
        this.currentValue = null;
        this.currentPlayerIndex = 0; // Index of current player
        this.gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        this.difficulty = 'medium';
        this.playerCount = 2; // Total players (human + computers)
        
        this.calledUno = []; // Track UNO calls for each player
        this.gameInProgress = false; // Prevent multiple simultaneous actions
        this.currentLanguage = localStorage.getItem('unoLanguage') || 'de';
        this.currentBackground = localStorage.getItem('unoBackground') || 'default';
        this.currentCardTheme = localStorage.getItem('unoCardTheme') || 'classic';
        
        this.initializeElements();
        this.setupEventListeners();
        this.initializeLanguage();
        this.initializeBackground();
        this.initializeCardTheme();
        
        // Zeige eine Benachrichtigung über die automatisch erkannte Sprache beim ersten Laden
        this.showLanguageDetectionNotification();
    }
    
    initializeElements() {
        // Screen elements
        this.startScreen = document.getElementById('startScreen');
        this.gameScreen = document.getElementById('gameScreen');
        
        // Game elements
        this.playerCardsContainer = document.getElementById('playerCards');
        this.playersContainer = document.getElementById('playersContainer');
        this.discardPileElement = document.getElementById('discardPile');
        this.drawPileElement = document.getElementById('drawPile');
        
        // UI elements
        this.currentTurnElement = document.getElementById('currentTurn');
        this.colorDisplay = document.getElementById('colorDisplay');
        this.drawCardBtn = document.getElementById('drawCard');
        this.callUnoBtn = document.getElementById('callUno');
        
        // Modals
        this.colorModal = document.getElementById('colorModal');
        this.gameOverModal = document.getElementById('gameOverModal');
        this.rulesModal = document.getElementById('rulesModal');
        this.settingsModal = document.getElementById('settingsModal');
        
        // Start screen elements
        this.playerCountButtons = document.querySelectorAll('.player-count-btn');
        this.difficultyButtons = document.querySelectorAll('.difficulty-btn');
        this.startGameBtn = document.getElementById('startGame');
        
        // Game control elements
        this.restartBtn = document.getElementById('restartButton');
        this.rulesBtn = document.getElementById('rulesButton');
        this.rulesBtnGame = document.getElementById('rulesButtonGame');
        
        // Language elements
        this.languageToggle = document.getElementById('languageToggle');
        this.languageMenu = document.getElementById('languageMenu');
        this.languageOptions = document.querySelectorAll('.language-option');
        this.currentFlag = document.querySelector('.current-flag');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settingsButton');
        this.settingsBtnGame = document.getElementById('settingsButtonGame');
        this.backgroundOptions = document.querySelectorAll('.background-option');
        this.cardThemeOptions = document.querySelectorAll('.card-theme-option');
    }
    
    setupEventListeners() {
        // Player count selection
        this.playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.playerCountButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.playerCount = parseInt(btn.dataset.players);
                this.checkStartButtonEnabled();
            });
        });
        
        // Difficulty selection
        this.difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                this.difficultyButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = btn.dataset.difficulty;
                this.checkStartButtonEnabled();
            });
        });
        
        // Start game
        this.startGameBtn.addEventListener('click', () => {
            this.startGame();
        });
        
        // Game actions
        this.drawCardBtn.addEventListener('click', () => {
            this.drawCard(0);
        });
        
        this.callUnoBtn.addEventListener('click', () => {
            this.callUno(0);
        });
        
        // Color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectColor(btn.dataset.color);
            });
        });
        
        // Play again
        document.getElementById('playAgain').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Restart button
        this.restartBtn.addEventListener('click', () => {
            if (confirm('Möchtest du das Spiel wirklich neu starten?')) {
                this.resetGame();
            }
        });
        
        // Rules button (start screen)
        this.rulesBtn.addEventListener('click', () => {
            this.showRules();
        });
        
        // Rules button (in game)
        this.rulesBtnGame.addEventListener('click', () => {
            this.showRules();
        });
        
        // Close rules modal
        document.getElementById('closeRules').addEventListener('click', () => {
            this.hideRules();
        });
        
        document.getElementById('closeRulesBtn').addEventListener('click', () => {
            this.hideRules();
        });
        
        // Language dropdown
        this.languageToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleLanguageMenu();
        });
        
        this.languageOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.switchLanguage(option.dataset.lang);
                this.hideLanguageMenu();
            });
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            this.hideLanguageMenu();
        });
        
        // Settings
        this.settingsBtn.addEventListener('click', () => {
            this.showSettings();
        });
        
        this.settingsBtnGame.addEventListener('click', () => {
            this.showSettings();
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            this.hideSettings();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            this.hideSettings();
        });
        
        // Background selection
        this.backgroundOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeBackground(option.dataset.bg);
            });
        });
        
        // Card theme selection
        this.cardThemeOptions.forEach(option => {
            option.addEventListener('click', () => {
                this.changeCardTheme(option.dataset.theme);
            });
        });
        
        // Draw pile click
        this.drawPileElement.addEventListener('click', () => {
            if (this.currentPlayerIndex === 0 && this.deck.length > 0) {
                this.drawCard(0);
            }
        });
    }
    
    checkStartButtonEnabled() {
        const playerCountSelected = Array.from(this.playerCountButtons).some(btn => btn.classList.contains('selected'));
        const difficultySelected = Array.from(this.difficultyButtons).some(btn => btn.classList.contains('selected'));
        this.startGameBtn.disabled = !(playerCountSelected && difficultySelected);
    }
    
    getRandomComputerName() {
        // Hole die Namen für die aktuelle Sprache
        const computerNames = this.computerNamesByLanguage[this.currentLanguage] || this.computerNamesByLanguage['de'];
        
        // Wenn alle Namen verwendet wurden, leere die Liste
        if (this.usedNames.length >= computerNames.length) {
            this.usedNames = [];
        }
        
        // Wähle einen Namen, der noch nicht verwendet wurde
        let availableNames = computerNames.filter(name => !this.usedNames.includes(name));
        const randomIndex = Math.floor(Math.random() * availableNames.length);
        const selectedName = availableNames[randomIndex];
        
        // Markiere den Namen als verwendet
        this.usedNames.push(selectedName);
        
        return selectedName;
    }
    
    createDeck() {
        this.deck = [];
        
        // Number cards (0-9) - 0 has 1 of each color, 1-9 have 2 of each color
        this.colors.forEach(color => {
            this.deck.push({ color, value: '0', type: 'number' });
            for (let i = 1; i <= 9; i++) {
                this.deck.push({ color, value: i.toString(), type: 'number' });
                this.deck.push({ color, value: i.toString(), type: 'number' });
            }
        });
        
        // Action cards (2 of each per color)
        this.colors.forEach(color => {
            this.actions.forEach(action => {
                this.deck.push({ color, value: action, type: 'action' });
                this.deck.push({ color, value: action, type: 'action' });
            });
        });
        
        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
            this.deck.push({ color: 'wild', value: 'wild', type: 'wild' });
            this.deck.push({ color: 'wild', value: 'wild-draw-four', type: 'wild' });
        }
        
        this.shuffleDeck();
    }
    
    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }
    
    dealInitialCards() {
        // Initialize players array
        this.players = [];
        this.calledUno = [];
        
        for (let i = 0; i < this.playerCount; i++) {
            this.players[i] = [];
            this.calledUno[i] = false;
        }
        
        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < this.playerCount; j++) {
                this.players[j].push(this.deck.pop());
            }
        }
        
        // Place first card on discard pile (cannot be wild or action card)
        let firstCard;
        do {
            firstCard = this.deck.pop();
        } while (firstCard.type === 'wild' || firstCard.type === 'action');
        
        this.discardPile = [firstCard];
        this.currentColor = firstCard.color;
        this.currentValue = firstCard.value;
    }
    
    startGame() {
        this.startScreen.classList.add('hidden');
        this.gameScreen.classList.remove('hidden');
        
        this.createDeck();
        this.dealInitialCards();
        this.setupPlayersUI();
        this.currentPlayerIndex = 0;
        this.gameInProgress = true;
        this.updateUI();
        this.updateTurnDisplay();
        
        // Enable UNO button when human player has 2 cards
        this.updateUnoButton();
    }
    
    setupPlayersUI() {
        // Clear existing computer players
        this.playersContainer.innerHTML = '';
        
        // Reset used names for a new game
        this.usedNames = [];
        
        // Create computer player UI elements (skip index 0 = human player)
        for (let i = 1; i < this.playerCount; i++) {
            const computerName = this.getRandomComputerName();
            const playerDiv = document.createElement('div');
            playerDiv.className = 'computer-player';
            playerDiv.id = `player-${i}`;
            
            playerDiv.innerHTML = `
                <div class="player-info">
                    <h3>${computerName}</h3>
                    <div class="card-count">
                        <span id="cardCount-${i}">${this.players[i].length}</span>
                        <span class="cards-text">Karten</span>
                    </div>
                </div>
                <div class="computer-cards" id="computerCards-${i}">
                    <!-- Computer cards will be added here -->
                </div>
            `;
            
            this.playersContainer.appendChild(playerDiv);
            
            // Store the computer name for later use
            if (!this.computerPlayerNames) {
                this.computerPlayerNames = {};
            }
            this.computerPlayerNames[i] = computerName;
        }
    }
    
    resetGame() {
        this.gameInProgress = false; // Stop any ongoing actions
        this.gameOverModal.classList.add('hidden');
        this.gameScreen.classList.add('hidden');
        this.startScreen.classList.remove('hidden');
        
        // Reset game state
        this.calledUno = [];
        this.gameDirection = 1;
        this.currentPlayerIndex = 0;
        this.computerPlayerNames = {}; // Reset computer names
        this.usedNames = []; // Reset used names
        
        // Reset button states
        this.startGameBtn.disabled = true;
        this.playerCountButtons.forEach(btn => btn.classList.remove('selected'));
        this.difficultyButtons.forEach(btn => btn.classList.remove('selected'));
    }
    
    updateUI() {
        this.updatePlayerCards();
        this.updateComputerCards();
        this.updateDiscardPile();
        this.updateDrawPile();
        this.updateCardCounts();
        this.updateColorDisplay();
        this.updateActivePlayer();
    }
    
    updatePlayerCards() {
        this.playerCardsContainer.innerHTML = '';
        this.players[0].forEach((card, index) => {
            const cardElement = this.createCardElement(card, true);
            cardElement.addEventListener('click', () => {
                if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                    this.playCard(0, index);
                }
            });
            
            // Add playable highlight
            if (this.currentPlayerIndex === 0 && this.canPlayCard(card)) {
                cardElement.classList.add('playable');
            }
            
            this.playerCardsContainer.appendChild(cardElement);
        });
    }
    
    updateComputerCards() {
        for (let i = 1; i < this.playerCount; i++) {
            const computerCardsContainer = document.getElementById(`computerCards-${i}`);
            if (computerCardsContainer) {
                computerCardsContainer.innerHTML = '';
                this.players[i].forEach(() => {
                    const cardElement = document.createElement('div');
                    cardElement.className = `computer-card ${this.currentCardTheme}-theme`;
                    cardElement.innerHTML = this.createCardBackContent();
                    computerCardsContainer.appendChild(cardElement);
                });
            }
        }
    }
    
    updateDiscardPile() {
        const topCard = this.discardPile[this.discardPile.length - 1];
        this.discardPileElement.innerHTML = '';
        const cardElement = this.createCardElement(topCard, true);
        this.discardPileElement.appendChild(cardElement);
    }
    
    updateDrawPile() {
        this.drawPileElement.innerHTML = '';
        
        if (this.deck.length > 0) {
            // Show card back when cards are available
            const cardBack = document.createElement('div');
            cardBack.className = `card-back ${this.currentCardTheme}-theme`;
            cardBack.innerHTML = this.createCardBackContent();
            this.drawPileElement.appendChild(cardBack);
            
            // Enable draw button
            this.drawCardBtn.disabled = false;
            this.drawPileElement.style.cursor = 'pointer';
        } else {
            // Show empty state when no cards left
            const emptyPile = document.createElement('div');
            emptyPile.className = 'empty-pile';
            emptyPile.innerHTML = '<span>Leer</span>';
            this.drawPileElement.appendChild(emptyPile);
            
            // Disable draw button and pile
            this.drawCardBtn.disabled = true;
            this.drawPileElement.style.cursor = 'not-allowed';
        }
    }
    
    updateCardCounts() {
        // Update card counts for all computer players
        for (let i = 1; i < this.playerCount; i++) {
            const cardCountElement = document.getElementById(`cardCount-${i}`);
            if (cardCountElement) {
                cardCountElement.textContent = this.players[i].length;
            }
        }
    }
    
    updateActivePlayer() {
        // Remove active class from all players
        for (let i = 1; i < this.playerCount; i++) {
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                playerElement.classList.remove('active');
            }
        }
        
        // Add active class to current player (if computer)
        if (this.currentPlayerIndex > 0) {
            const activePlayerElement = document.getElementById(`player-${this.currentPlayerIndex}`);
            if (activePlayerElement) {
                activePlayerElement.classList.add('active');
            }
        }
    }
    
    updateColorDisplay() {
        // Remove all color classes
        this.colorDisplay.className = 'color-display';
        
        // Add current color class
        if (this.currentColor && this.currentColor !== 'wild') {
            this.colorDisplay.classList.add(this.currentColor);
        }
    }
    
    updateTurnDisplay() {
        if (this.currentPlayerIndex === 0) {
            this.currentTurnElement.textContent = t('game.yourTurn');
            this.currentTurnElement.style.background = 'rgba(76, 175, 80, 0.9)';
        } else {
            const computerName = this.computerPlayerNames && this.computerPlayerNames[this.currentPlayerIndex] 
                ? this.computerPlayerNames[this.currentPlayerIndex] 
                : `Computer ${this.currentPlayerIndex}`;
            this.currentTurnElement.textContent = t('game.computerTurn', computerName);
            this.currentTurnElement.style.background = 'rgba(244, 67, 54, 0.9)';
        }
    }
    
    updateUnoButton() {
        // Enable UNO button when human player has exactly 2 cards and hasn't called UNO yet
        this.callUnoBtn.disabled = !(this.players[0].length === 2 && !this.calledUno[0]);
    }
    
    createCardElement(card, showFace = true) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.color} ${this.currentCardTheme}-theme`;
        
        if (showFace) {
            if (card.type === 'number') {
                cardElement.innerHTML = `<span class="card-value">${card.value}</span>`;
            } else if (card.type === 'action') {
                const actionText = {
                    'skip': 'STOP',
                    'reverse': '⟲',
                    'draw-two': '+2'
                };
                cardElement.innerHTML = `<span class="card-value">${actionText[card.value]}</span>`;
            } else if (card.type === 'wild') {
                const wildText = card.value === 'wild' ? 'WILD' : '+4';
                cardElement.innerHTML = `<span class="card-value">${wildText}</span>`;
            }
        } else {
            // Rückseite der Karte mit Theme-spezifischem Design
            cardElement.innerHTML = this.createCardBackContent();
        }
        
        return cardElement;
    }
    
    createCardBackContent() {
        switch (this.currentCardTheme) {
            case 'minecraft':
                return '<div class="card-back-minecraft"><span class="pickaxe">⛏️</span></div>';
            case 'mario':
                return '<div class="card-back-mario"><span class="mushroom">🍄</span></div>';
            case 'pokemon':
                return '<div class="card-back-pokemon"><span class="pokeball">⚫</span></div>';
            case 'cyberpunk':
                return '<div class="card-back-cyberpunk"><span class="skull">💀</span></div>';
            case 'retro':
                return '<div class="card-back-retro"><span class="alien">👾</span></div>';
            case 'classic':
            default:
                return '<div class="card-back-classic"><span class="uno-text">UNO</span></div>';
        }
    }
    
    canPlayCard(card) {
        // Wild cards can always be played
        if (card.type === 'wild') {
            return true;
        }
        
        // Regular cards must match color or value
        return card.color === this.currentColor || card.value === this.currentValue;
    }
    
    playCard(playerIndex, cardIndex) {
        const hand = this.players[playerIndex];
        const card = hand[cardIndex];
        
        if (!this.canPlayCard(card)) {
            return false;
        }
        
        // Remove card from hand and add to discard pile
        hand.splice(cardIndex, 1);
        this.discardPile.push(card);
        
        // Add playing animation
        if (playerIndex === 0) {
            const cardElements = this.playerCardsContainer.children;
            if (cardElements[cardIndex]) {
                cardElements[cardIndex].classList.add('playing');
            }
        }
        
        // Handle card effects
        this.handleCardEffect(card);
        
        // Update current color and value
        if (card.type === 'wild') {
            if (playerIndex === 0) {
                this.showColorSelector();
                return true; // Color selector will handle turn switching
            } else {
                // Computer chooses color
                this.currentColor = this.chooseColorForComputer();
                this.showComputerColorChoice();
                // Continue to handle card effects below
            }
        } else {
            this.currentColor = card.color;
        }
        this.currentValue = card.value;
        
        // Check for win condition
        if (hand.length === 0) {
            this.endGame(playerIndex);
            return true;
        }
        
        // Check UNO call requirement
        if (hand.length === 1) {
            if (playerIndex === 0 && !this.calledUno[0]) {
                // Player forgot to call UNO - penalty
                this.penalizePlayer(0);
            } else if (playerIndex > 0 && !this.calledUno[playerIndex]) {
                // Computer calls UNO automatically
                this.callUno(playerIndex);
            }
        }
        
        // Update UI
        this.updateUI();
        this.updateUnoButton();
        
        // Switch turns (card effects handle their own turn logic)
        if (card.value === 'skip' || card.value === 'reverse' || 
            card.value === 'draw-two' || card.value === 'wild-draw-four' || 
            card.value === 'wild') {
            // Action cards and wild cards handle their own turn switching
            return true;
        } else {
            // Regular number cards
            this.switchTurns();
        }
        
        return true;
    }
    
    handleCardEffect(card) {
        switch (card.value) {
            case 'skip':
                // Skip next player's turn - switch twice to skip them
                this.switchTurns(); // Go to next player
                this.switchTurns(); // Skip that player
                break;
                
            case 'reverse':
                this.gameDirection *= -1;
                // In 2-player game, reverse acts like skip
                if (this.playerCount === 2) {
                    this.switchTurns(); // Go to next player
                    this.switchTurns(); // Skip that player (reverse effect)
                } else {
                    this.switchTurns(); // Just change direction
                }
                break;
                
            case 'draw-two':
                const drawTwoTarget = this.getNextPlayerIndex();
                this.drawCards(drawTwoTarget, 2);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild-draw-four':
                const drawFourTarget = this.getNextPlayerIndex();
                this.drawCards(drawFourTarget, 4);
                this.switchTurns(); // Move to next player after penalty
                break;
                
            case 'wild':
                // Regular wild card - just switch turns normally
                this.switchTurns();
                break;
        }
    }
    
    drawCard(playerIndex) {
        if (this.deck.length === 0) {
            this.reshuffleDeck();
        }
        
        // Check if we still have no cards after reshuffling (shouldn't happen normally)
        if (this.deck.length === 0) {
            console.warn('No cards available to draw!');
            return;
        }
        
        const card = this.deck.pop();
        this.players[playerIndex].push(card);
        
        this.updateUI();
        this.updateUnoButton();
        
        // Reset UNO call status when drawing cards
        this.calledUno[playerIndex] = false;
        
        // After drawing, human player auto-ends turn, computer continues
        if (playerIndex === 0 && this.currentPlayerIndex === 0) {
            // Auto-end human turn after drawing
            setTimeout(() => {
                if (this.currentPlayerIndex === 0) { // Double-check we're still on human turn
                    this.switchTurns();
                }
            }, 1000);
        }
    }
    
    drawCards(playerIndex, count) {
        for (let i = 0; i < count; i++) {
            this.drawCard(playerIndex);
        }
    }
    
    reshuffleDeck() {
        // Keep top card of discard pile, shuffle the rest back into deck
        const topCard = this.discardPile.pop();
        this.deck = [...this.discardPile];
        this.discardPile = [topCard];
        this.shuffleDeck();
    }
    
    getNextPlayerIndex() {
        let nextIndex = this.currentPlayerIndex + this.gameDirection;
        if (nextIndex >= this.playerCount) {
            nextIndex = 0;
        } else if (nextIndex < 0) {
            nextIndex = this.playerCount - 1;
        }
        return nextIndex;
    }
    
    switchTurns() {
        if (!this.gameInProgress) {
            return; // Game ended, don't continue
        }
        
        this.currentPlayerIndex = this.getNextPlayerIndex();
        this.updateTurnDisplay();
        this.updateUI();
        
        if (this.currentPlayerIndex > 0) {
            // Computer's turn
            setTimeout(() => {
                if (this.gameInProgress && this.currentPlayerIndex > 0) {
                    this.computerPlay();
                }
            }, 1500); // Delay for realism
        }
    }
    
    computerPlay() {
        // Safety check - make sure it's actually a computer's turn
        if (this.currentPlayerIndex === 0) {
            console.warn('computerPlay called but it\'s human player\'s turn!');
            return;
        }
        
        const playerIndex = this.currentPlayerIndex;
        const playableCards = this.players[playerIndex]
            .map((card, index) => ({ card, index }))
            .filter(({ card }) => this.canPlayCard(card));
        
        if (playableCards.length > 0) {
            const chosenCard = this.chooseCardForComputer(playableCards, playerIndex);
            this.playCard(playerIndex, chosenCard.index);
        } else {
            // Must draw a card
            this.drawCard(playerIndex);
            // Only switch turns if we're still at the same player (draw didn't trigger other effects)
            if (this.currentPlayerIndex === playerIndex) {
                this.switchTurns();
            }
        }
    }
    
    chooseCardForComputer(playableCards, playerIndex) {
        switch (this.difficulty) {
            case 'easy':
                return this.chooseCardEasy(playableCards, playerIndex);
            case 'medium':
                return this.chooseCardMedium(playableCards, playerIndex);
            case 'hard':
                return this.chooseCardHard(playableCards, playerIndex);
            default:
                return playableCards[0];
        }
    }
    
    chooseCardEasy(playableCards, playerIndex) {
        // Easy: Random selection, prefers regular cards over action cards
        const regularCards = playableCards.filter(({ card }) => card.type === 'number');
        const actionCards = playableCards.filter(({ card }) => card.type === 'action');
        const wildCards = playableCards.filter(({ card }) => card.type === 'wild');
        
        if (regularCards.length > 0 && Math.random() < 0.7) {
            return regularCards[Math.floor(Math.random() * regularCards.length)];
        } else if (actionCards.length > 0 && Math.random() < 0.6) {
            return actionCards[Math.floor(Math.random() * regularCards.length)];
        } else if (wildCards.length > 0) {
            return wildCards[Math.floor(Math.random() * wildCards.length)];
        }
        
        return playableCards[Math.floor(Math.random() * playableCards.length)];
    }
    
    chooseCardMedium(playableCards, playerIndex) {
        // Medium: Balanced strategy, considers card effects
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Check if human player has few cards
        const humanPlayerLowCards = this.players[0].length <= 3;
        
        // Prefer action cards when advantageous
        if (actionCards.length > 0 && humanPlayerLowCards) {
            const preferredActions = actionCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'skip'
            );
            if (preferredActions.length > 0) {
                return preferredActions[0];
            }
        }
        
        // Use wild cards strategically
        if (wildCards.length > 0 && this.players[playerIndex].length <= 2) {
            return wildCards[0];
        }
        
        // Otherwise prefer regular cards
        if (regularCards.length > 0) {
            return regularCards[0];
        }
        
        return playableCards[0];
    }
    
    chooseCardHard(playableCards, playerIndex) {
        // Hard: Advanced strategy, considers multiple factors
        const { actionCards, wildCards, regularCards } = this.categorizeCards(playableCards);
        
        // Aggressive play when human player has few cards
        if (this.players[0].length <= 2) {
            const drawCards = playableCards.filter(({ card }) => 
                card.value === 'draw-two' || card.value === 'wild-draw-four'
            );
            if (drawCards.length > 0) {
                // Prefer wild-draw-four over draw-two
                const wildDrawFour = drawCards.find(({ card }) => card.value === 'wild-draw-four');
                return wildDrawFour || drawCards[0];
            }
            
            // Skip player's turn
            const skipCards = actionCards.filter(({ card }) => card.value === 'skip');
            if (skipCards.length > 0) {
                return skipCards[0];
            }
        }
        
        // Color management strategy
        const colorCounts = this.countColorsByFrequency(playerIndex);
        const bestColorCards = regularCards.filter(({ card }) => 
            card.color === colorCounts[0]?.color
        );
        
        if (bestColorCards.length > 0) {
            return bestColorCards[0];
        }
        
        // Save wild cards for last resort unless hand is small
        if (this.players[playerIndex].length <= 3 && wildCards.length > 0) {
            return wildCards[0];
        }
        
        // Default to first available card
        return regularCards[0] || actionCards[0] || wildCards[0] || playableCards[0];
    }
    
    categorizeCards(playableCards) {
        return {
            regularCards: playableCards.filter(({ card }) => card.type === 'number'),
            actionCards: playableCards.filter(({ card }) => card.type === 'action'),
            wildCards: playableCards.filter(({ card }) => card.type === 'wild')
        };
    }
    
    countColorsByFrequency(playerIndex) {
        const colorCounts = {};
        this.players[playerIndex].forEach(card => {
            if (card.color !== 'wild') {
                colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
        });
        
        return Object.entries(colorCounts)
            .map(([color, count]) => ({ color, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    chooseColorForComputer() {
        const colorCounts = this.countColorsByFrequency();
        return colorCounts.length > 0 ? colorCounts[0].color : this.colors[Math.floor(Math.random() * this.colors.length)];
    }
    
    showColorSelector() {
        this.colorModal.classList.remove('hidden');
    }
    
    selectColor(color) {
        this.currentColor = color;
        this.colorModal.classList.add('hidden');
        this.updateUI();
        this.switchTurns();
    }
    
    showComputerColorChoice() {
        // Show feedback about computer's color choice
        const colorNames = {
            'red': 'Rot',
            'blue': 'Blau', 
            'green': 'Grün',
            'yellow': 'Gelb'
        };
        
        const colorName = colorNames[this.currentColor];
        const originalText = this.currentTurnElement.textContent;
        
        this.currentTurnElement.textContent = `Computer wählt: ${colorName}`;
        this.currentTurnElement.style.background = 'rgba(255, 193, 7, 0.9)';
        
        setTimeout(() => {
            this.updateTurnDisplay();
        }, 2000);
    }
    
    callUno(playerIndex) {
        this.calledUno[playerIndex] = true;
        
        if (playerIndex === 0) {
            this.callUnoBtn.disabled = true;
            
            // Show feedback
            this.currentTurnElement.textContent = t('game.unoCalled');
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        } else {
            // Show computer UNO call
            const computerName = this.computerPlayerNames && this.computerPlayerNames[playerIndex] 
                ? this.computerPlayerNames[playerIndex] 
                : `Computer ${playerIndex}`;
            this.currentTurnElement.textContent = t('game.computerCallsUno', computerName);
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 1500);
        }
    }
    
    penalizePlayer(playerIndex) {
        // Draw 2 penalty cards for not calling UNO
        this.drawCards(playerIndex, 2);
        
        if (playerIndex === 0) {
            this.currentTurnElement.textContent = t('game.penalized') + ' +2 Karten';
            setTimeout(() => {
                this.updateTurnDisplay();
            }, 2000);
        }
    }
    
    endGame(winnerIndex) {
        this.gameInProgress = false; // Stop all game actions
        
        const gameResult = document.getElementById('gameResult');
        const gameResultText = document.getElementById('gameResultText');
        
        if (winnerIndex === 0) {
            gameResult.textContent = t('game.won');
            gameResult.style.color = '#4caf50';
            gameResultText.textContent = t('game.wonText');
        } else {
            gameResult.textContent = t('game.lost');
            gameResult.style.color = '#f44336';
            const computerName = this.computerPlayerNames && this.computerPlayerNames[winnerIndex] 
                ? this.computerPlayerNames[winnerIndex] 
                : `Computer ${winnerIndex}`;
            gameResultText.textContent = t('game.lostText', computerName);
        }
        
        this.gameOverModal.classList.remove('hidden');
    }
    
    showRules() {
        this.rulesModal.classList.remove('hidden');
    }
    
    hideRules() {
        this.rulesModal.classList.add('hidden');
    }
    
    // Language System
    initializeLanguage() {
        // Automatische Spracherkennung basierend auf Browsersprache
        if (!localStorage.getItem('unoLanguage')) {
            const detectedLanguage = this.detectBrowserLanguage();
            this.currentLanguage = detectedLanguage;
            localStorage.setItem('unoLanguage', detectedLanguage);
        }
        
        this.updateLanguageDisplay();
        this.updateAllTexts();
    }
    
    detectBrowserLanguage() {
        // Browsersprache abrufen
        const browserLang = navigator.language || navigator.userLanguage || 'de';
        const primaryLang = browserLang.split('-')[0].toLowerCase();
        
        // Verfügbare Sprachen im Spiel
        const availableLanguages = ['de', 'en', 'es', 'fr', 'pt', 'ja', 'zh', 'hu', 'ru'];
        
        // Direkte Übereinstimmung finden
        if (availableLanguages.includes(primaryLang)) {
            return primaryLang;
        }
        
        // Sprachzuordnung für ähnliche Sprachen
        const languageMapping = {
            'en-us': 'en', 'en-gb': 'en', 'en-ca': 'en', 'en-au': 'en',
            'es-mx': 'es', 'es-ar': 'es', 'es-cl': 'es', 'es-co': 'es',
            'fr-ca': 'fr', 'fr-be': 'fr', 'fr-ch': 'fr', 'fr-lu': 'fr',
            'pt-pt': 'pt', 'pt-ao': 'pt', 'pt-mo': 'pt',
            'ja-jp': 'ja',
            'zh-cn': 'zh', 'zh-tw': 'zh', 'zh-hk': 'zh', 'zh-sg': 'zh',
            'hu-hu': 'hu',
            'ru-ru': 'ru', 'ru-ua': 'ru', 'ru-kz': 'ru', 'ru-by': 'ru'
        };
        
        // Vollständige Sprachcode-Übereinstimmung
        if (languageMapping[browserLang.toLowerCase()]) {
            return languageMapping[browserLang.toLowerCase()];
        }
        
        // Fallback auf Deutsch
        return 'de';
    }
    
    showLanguageDetectionNotification() {
        // Zeige nur beim ersten Laden eine Benachrichtigung über die erkannte Sprache
        if (!localStorage.getItem('unoLanguageNotificationShown')) {
            const languageNames = {
                'de': 'Deutsch',
                'en': 'English',
                'es': 'Español',
                'fr': 'Français',
                'pt': 'Português',
                'ja': '日本語',
                'zh': '中文',
                'hu': 'Magyar',
                'ru': 'Русский'
            };
            
            const detectedLangName = languageNames[this.currentLanguage] || 'Deutsch';
            
            // Erstelle eine temporäre Benachrichtigung
            const notification = document.createElement('div');
            notification.className = 'language-notification';
            notification.innerHTML = `
                <span>🌍 Sprache automatisch erkannt: ${detectedLangName}</span>
                <button class="notification-close">✕</button>
            `;
            
            // Styling für die Benachrichtigung
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideIn 0.3s ease-out;
            `;
            
            // Schließen-Button Styling
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
                padding: 0;
                margin: 0;
            `;
            
            // Event Listener für den Schließen-Button
            closeBtn.addEventListener('click', () => {
                notification.remove();
            });
            
            // Füge CSS-Animation hinzu
            if (!document.querySelector('#language-notification-styles')) {
                const style = document.createElement('style');
                style.id = 'language-notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Füge die Benachrichtigung zum DOM hinzu
            document.body.appendChild(notification);
            
            // Automatisch nach 5 Sekunden ausblenden
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
            
            // Markiere als angezeigt
            localStorage.setItem('unoLanguageNotificationShown', 'true');
        }
    }
    
    switchLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('unoLanguage', lang);
        this.updateLanguageDisplay();
        this.updateAllTexts();
        
        // Wenn ein Spiel läuft, regeneriere die Computer-Namen in der neuen Sprache
        if (this.gameInProgress && this.computerPlayerNames) {
            this.regenerateComputerNames();
        }
    }
    
    regenerateComputerNames() {
        // Reset verwendet Namen und generiere neue Namen für alle Computer
        this.usedNames = [];
        for (let i = 1; i < this.playerCount; i++) {
            const newName = this.getRandomComputerName();
            this.computerPlayerNames[i] = newName;
            
            // Update UI
            const playerElement = document.getElementById(`player-${i}`);
            if (playerElement) {
                const nameElement = playerElement.querySelector('.player-info h3');
                if (nameElement) {
                    nameElement.textContent = newName;
                }
            }
        }
        
        // Update turn display with new names
        this.updateTurnDisplay();
    }
    
    toggleLanguageMenu() {
        this.languageMenu.classList.toggle('hidden');
        this.languageToggle.classList.toggle('open');
    }
    
    hideLanguageMenu() {
        this.languageMenu.classList.add('hidden');
        this.languageToggle.classList.remove('open');
    }
    
    updateLanguageDisplay() {
        // Update current flag in toggle button
        const languageFlags = {
            'de': '🇩🇪',
            'en': '🇬🇧', 
            'es': '🇪🇸',
            'fr': '🇫🇷',
            'pt': '🇧🇷',
            'ja': '🇯🇵',
            'zh': '🇨🇳',
            'hu': '🇭🇺',
            'ru': '🇷🇺'
        };
        
        this.currentFlag.textContent = languageFlags[this.currentLanguage] || '🇩🇪';
        
        // Update active state in dropdown
        this.languageOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.lang === this.currentLanguage);
        });
    }
    
    updateAllTexts() {
        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = t(key);
        });
        
        // Update dynamic texts if game is running
        if (this.gameInProgress) {
            this.updateTurnDisplay();
        }
    }
    
    // Settings System
    showSettings() {
        this.settingsModal.classList.remove('hidden');
    }
    
    hideSettings() {
        this.settingsModal.classList.add('hidden');
    }
    
    initializeBackground() {
        this.applyBackground(this.currentBackground);
        this.updateBackgroundOptions();
    }
    
    changeBackground(bgName) {
        this.currentBackground = bgName;
        localStorage.setItem('unoBackground', bgName);
        this.applyBackground(bgName);
        this.updateBackgroundOptions();
    }
    
    applyBackground(bgName) {
        // Remove all background classes
        document.body.className = document.body.className.replace(/bg-\w+/g, '');
        // Add new background class
        document.body.classList.add(`bg-${bgName}`);
    }
    
    updateBackgroundOptions() {
        this.backgroundOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.bg === this.currentBackground);
        });
    }
    
    initializeCardTheme() {
        this.applyCardTheme(this.currentCardTheme);
        this.updateCardThemeOptions();
    }
    
    changeCardTheme(themeName) {
        this.currentCardTheme = themeName;
        localStorage.setItem('unoCardTheme', themeName);
        this.applyCardTheme(themeName);
        this.updateCardThemeOptions();
    }
    
    applyCardTheme(themeName) {
        // Remove all existing theme classes from cards
        const allCards = document.querySelectorAll('.card, .computer-card, .card-back');
        allCards.forEach(card => {
            card.classList.remove('classic-theme', 'minecraft-theme', 'mario-theme', 'pokemon-theme', 'cyberpunk-theme', 'retro-theme');
            card.classList.add(themeName + '-theme');
            
            // Update card back content if it's a back side
            if (card.classList.contains('computer-card') || card.classList.contains('card-back')) {
                card.innerHTML = this.createCardBackContent();
            }
        });
        
        // Store current theme for new cards
        document.body.setAttribute('data-card-theme', themeName);
    }
    
    updateCardThemeOptions() {
        this.cardThemeOptions.forEach(option => {
            option.classList.toggle('active', option.dataset.theme === this.currentCardTheme);
        });
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new UnoGame();
});